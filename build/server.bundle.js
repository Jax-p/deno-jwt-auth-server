// Copyright 2018-2020 the Deno authors. All rights reserved. MIT license.

// This is a specialised implementation of a System module loader.

"use strict";

// @ts-nocheck
/* eslint-disable */
let System, __instantiateAsync, __instantiate;

(() => {
  const r = new Map();

  System = {
    register(id, d, f) {
      r.set(id, { d, f, exp: {} });
    },
  };

  async function dI(mid, src) {
    let id = mid.replace(/\.\w+$/i, "");
    if (id.includes("./")) {
      const [o, ...ia] = id.split("/").reverse(),
        [, ...sa] = src.split("/").reverse(),
        oa = [o];
      let s = 0,
        i;
      while ((i = ia.shift())) {
        if (i === "..") s++;
        else if (i === ".") break;
        else oa.push(i);
      }
      if (s < sa.length) oa.push(...sa.slice(s));
      id = oa.reverse().join("/");
    }
    return r.has(id) ? gExpA(id) : import(mid);
  }

  function gC(id, main) {
    return {
      id,
      import: (m) => dI(m, id),
      meta: { url: id, main },
    };
  }

  function gE(exp) {
    return (id, v) => {
      v = typeof id === "string" ? { [id]: v } : id;
      for (const [id, value] of Object.entries(v)) {
        Object.defineProperty(exp, id, {
          value,
          writable: true,
          enumerable: true,
        });
      }
    };
  }

  function rF(main) {
    for (const [id, m] of r.entries()) {
      const { f, exp } = m;
      const { execute: e, setters: s } = f(gE(exp), gC(id, id === main));
      delete m.f;
      m.e = e;
      m.s = s;
    }
  }

  async function gExpA(id) {
    if (!r.has(id)) return;
    const m = r.get(id);
    if (m.s) {
      const { d, e, s } = m;
      delete m.s;
      delete m.e;
      for (let i = 0; i < s.length; i++) s[i](await gExpA(d[i]));
      const r = e();
      if (r) await r;
    }
    return m.exp;
  }

  function gExp(id) {
    if (!r.has(id)) return;
    const m = r.get(id);
    if (m.s) {
      const { d, e, s } = m;
      delete m.s;
      delete m.e;
      for (let i = 0; i < s.length; i++) s[i](gExp(d[i]));
      e();
    }
    return m.exp;
  }

  __instantiateAsync = async (m) => {
    System = __instantiateAsync = __instantiate = undefined;
    rF(m);
    return gExpA(m);
  };

  __instantiate = (m) => {
    System = __instantiateAsync = __instantiate = undefined;
    rF(m);
    return gExp(m);
  };
})();

"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
// Copyright the Browserify authors. MIT License.
// Ported from https://github.com/browserify/path-browserify/
/** This module is browser compatible. */
System.register("https://deno.land/std/path/_constants", [], function (exports_1, context_1) {
    "use strict";
    var CHAR_UPPERCASE_A, CHAR_LOWERCASE_A, CHAR_UPPERCASE_Z, CHAR_LOWERCASE_Z, CHAR_DOT, CHAR_FORWARD_SLASH, CHAR_BACKWARD_SLASH, CHAR_VERTICAL_LINE, CHAR_COLON, CHAR_QUESTION_MARK, CHAR_UNDERSCORE, CHAR_LINE_FEED, CHAR_CARRIAGE_RETURN, CHAR_TAB, CHAR_FORM_FEED, CHAR_EXCLAMATION_MARK, CHAR_HASH, CHAR_SPACE, CHAR_NO_BREAK_SPACE, CHAR_ZERO_WIDTH_NOBREAK_SPACE, CHAR_LEFT_SQUARE_BRACKET, CHAR_RIGHT_SQUARE_BRACKET, CHAR_LEFT_ANGLE_BRACKET, CHAR_RIGHT_ANGLE_BRACKET, CHAR_LEFT_CURLY_BRACKET, CHAR_RIGHT_CURLY_BRACKET, CHAR_HYPHEN_MINUS, CHAR_PLUS, CHAR_DOUBLE_QUOTE, CHAR_SINGLE_QUOTE, CHAR_PERCENT, CHAR_SEMICOLON, CHAR_CIRCUMFLEX_ACCENT, CHAR_GRAVE_ACCENT, CHAR_AT, CHAR_AMPERSAND, CHAR_EQUAL, CHAR_0, CHAR_9, navigator, isWindows;
    var __moduleName = context_1 && context_1.id;
    return {
        setters: [],
        execute: function () {
            // Alphabet chars.
            exports_1("CHAR_UPPERCASE_A", CHAR_UPPERCASE_A = 65); /* A */
            exports_1("CHAR_LOWERCASE_A", CHAR_LOWERCASE_A = 97); /* a */
            exports_1("CHAR_UPPERCASE_Z", CHAR_UPPERCASE_Z = 90); /* Z */
            exports_1("CHAR_LOWERCASE_Z", CHAR_LOWERCASE_Z = 122); /* z */
            // Non-alphabetic chars.
            exports_1("CHAR_DOT", CHAR_DOT = 46); /* . */
            exports_1("CHAR_FORWARD_SLASH", CHAR_FORWARD_SLASH = 47); /* / */
            exports_1("CHAR_BACKWARD_SLASH", CHAR_BACKWARD_SLASH = 92); /* \ */
            exports_1("CHAR_VERTICAL_LINE", CHAR_VERTICAL_LINE = 124); /* | */
            exports_1("CHAR_COLON", CHAR_COLON = 58); /* : */
            exports_1("CHAR_QUESTION_MARK", CHAR_QUESTION_MARK = 63); /* ? */
            exports_1("CHAR_UNDERSCORE", CHAR_UNDERSCORE = 95); /* _ */
            exports_1("CHAR_LINE_FEED", CHAR_LINE_FEED = 10); /* \n */
            exports_1("CHAR_CARRIAGE_RETURN", CHAR_CARRIAGE_RETURN = 13); /* \r */
            exports_1("CHAR_TAB", CHAR_TAB = 9); /* \t */
            exports_1("CHAR_FORM_FEED", CHAR_FORM_FEED = 12); /* \f */
            exports_1("CHAR_EXCLAMATION_MARK", CHAR_EXCLAMATION_MARK = 33); /* ! */
            exports_1("CHAR_HASH", CHAR_HASH = 35); /* # */
            exports_1("CHAR_SPACE", CHAR_SPACE = 32); /*   */
            exports_1("CHAR_NO_BREAK_SPACE", CHAR_NO_BREAK_SPACE = 160); /* \u00A0 */
            exports_1("CHAR_ZERO_WIDTH_NOBREAK_SPACE", CHAR_ZERO_WIDTH_NOBREAK_SPACE = 65279); /* \uFEFF */
            exports_1("CHAR_LEFT_SQUARE_BRACKET", CHAR_LEFT_SQUARE_BRACKET = 91); /* [ */
            exports_1("CHAR_RIGHT_SQUARE_BRACKET", CHAR_RIGHT_SQUARE_BRACKET = 93); /* ] */
            exports_1("CHAR_LEFT_ANGLE_BRACKET", CHAR_LEFT_ANGLE_BRACKET = 60); /* < */
            exports_1("CHAR_RIGHT_ANGLE_BRACKET", CHAR_RIGHT_ANGLE_BRACKET = 62); /* > */
            exports_1("CHAR_LEFT_CURLY_BRACKET", CHAR_LEFT_CURLY_BRACKET = 123); /* { */
            exports_1("CHAR_RIGHT_CURLY_BRACKET", CHAR_RIGHT_CURLY_BRACKET = 125); /* } */
            exports_1("CHAR_HYPHEN_MINUS", CHAR_HYPHEN_MINUS = 45); /* - */
            exports_1("CHAR_PLUS", CHAR_PLUS = 43); /* + */
            exports_1("CHAR_DOUBLE_QUOTE", CHAR_DOUBLE_QUOTE = 34); /* " */
            exports_1("CHAR_SINGLE_QUOTE", CHAR_SINGLE_QUOTE = 39); /* ' */
            exports_1("CHAR_PERCENT", CHAR_PERCENT = 37); /* % */
            exports_1("CHAR_SEMICOLON", CHAR_SEMICOLON = 59); /* ; */
            exports_1("CHAR_CIRCUMFLEX_ACCENT", CHAR_CIRCUMFLEX_ACCENT = 94); /* ^ */
            exports_1("CHAR_GRAVE_ACCENT", CHAR_GRAVE_ACCENT = 96); /* ` */
            exports_1("CHAR_AT", CHAR_AT = 64); /* @ */
            exports_1("CHAR_AMPERSAND", CHAR_AMPERSAND = 38); /* & */
            exports_1("CHAR_EQUAL", CHAR_EQUAL = 61); /* = */
            // Digits
            exports_1("CHAR_0", CHAR_0 = 48); /* 0 */
            exports_1("CHAR_9", CHAR_9 = 57); /* 9 */
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            navigator = globalThis.navigator;
            isWindows = false;
            exports_1("isWindows", isWindows);
            if (globalThis.Deno != null) {
                exports_1("isWindows", isWindows = Deno.build.os == "windows");
            }
            else if (navigator?.appVersion != null) {
                exports_1("isWindows", isWindows = navigator.appVersion.includes("Win"));
            }
        }
    };
});
/** This module is browser compatible. */
System.register("https://deno.land/std/path/_interface", [], function (exports_2, context_2) {
    "use strict";
    var __moduleName = context_2 && context_2.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
// Copyright the Browserify authors. MIT License.
// Ported from https://github.com/browserify/path-browserify/
/** This module is browser compatible. */
System.register("https://deno.land/std/path/_util", ["https://deno.land/std/path/_constants"], function (exports_3, context_3) {
    "use strict";
    var _constants_ts_1;
    var __moduleName = context_3 && context_3.id;
    function assertPath(path) {
        if (typeof path !== "string") {
            throw new TypeError(`Path must be a string. Received ${JSON.stringify(path)}`);
        }
    }
    exports_3("assertPath", assertPath);
    function isPosixPathSeparator(code) {
        return code === _constants_ts_1.CHAR_FORWARD_SLASH;
    }
    exports_3("isPosixPathSeparator", isPosixPathSeparator);
    function isPathSeparator(code) {
        return isPosixPathSeparator(code) || code === _constants_ts_1.CHAR_BACKWARD_SLASH;
    }
    exports_3("isPathSeparator", isPathSeparator);
    function isWindowsDeviceRoot(code) {
        return ((code >= _constants_ts_1.CHAR_LOWERCASE_A && code <= _constants_ts_1.CHAR_LOWERCASE_Z) ||
            (code >= _constants_ts_1.CHAR_UPPERCASE_A && code <= _constants_ts_1.CHAR_UPPERCASE_Z));
    }
    exports_3("isWindowsDeviceRoot", isWindowsDeviceRoot);
    // Resolves . and .. elements in a path with directory names
    function normalizeString(path, allowAboveRoot, separator, isPathSeparator) {
        let res = "";
        let lastSegmentLength = 0;
        let lastSlash = -1;
        let dots = 0;
        let code;
        for (let i = 0, len = path.length; i <= len; ++i) {
            if (i < len)
                code = path.charCodeAt(i);
            else if (isPathSeparator(code))
                break;
            else
                code = _constants_ts_1.CHAR_FORWARD_SLASH;
            if (isPathSeparator(code)) {
                if (lastSlash === i - 1 || dots === 1) {
                    // NOOP
                }
                else if (lastSlash !== i - 1 && dots === 2) {
                    if (res.length < 2 ||
                        lastSegmentLength !== 2 ||
                        res.charCodeAt(res.length - 1) !== _constants_ts_1.CHAR_DOT ||
                        res.charCodeAt(res.length - 2) !== _constants_ts_1.CHAR_DOT) {
                        if (res.length > 2) {
                            const lastSlashIndex = res.lastIndexOf(separator);
                            if (lastSlashIndex === -1) {
                                res = "";
                                lastSegmentLength = 0;
                            }
                            else {
                                res = res.slice(0, lastSlashIndex);
                                lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
                            }
                            lastSlash = i;
                            dots = 0;
                            continue;
                        }
                        else if (res.length === 2 || res.length === 1) {
                            res = "";
                            lastSegmentLength = 0;
                            lastSlash = i;
                            dots = 0;
                            continue;
                        }
                    }
                    if (allowAboveRoot) {
                        if (res.length > 0)
                            res += `${separator}..`;
                        else
                            res = "..";
                        lastSegmentLength = 2;
                    }
                }
                else {
                    if (res.length > 0)
                        res += separator + path.slice(lastSlash + 1, i);
                    else
                        res = path.slice(lastSlash + 1, i);
                    lastSegmentLength = i - lastSlash - 1;
                }
                lastSlash = i;
                dots = 0;
            }
            else if (code === _constants_ts_1.CHAR_DOT && dots !== -1) {
                ++dots;
            }
            else {
                dots = -1;
            }
        }
        return res;
    }
    exports_3("normalizeString", normalizeString);
    function _format(sep, pathObject) {
        const dir = pathObject.dir || pathObject.root;
        const base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
        if (!dir)
            return base;
        if (dir === pathObject.root)
            return dir + base;
        return dir + sep + base;
    }
    exports_3("_format", _format);
    return {
        setters: [
            function (_constants_ts_1_1) {
                _constants_ts_1 = _constants_ts_1_1;
            }
        ],
        execute: function () {
        }
    };
});
// Copyright 2018-2020 the Deno authors. All rights reserved. MIT license.
System.register("https://deno.land/std/_util/assert", [], function (exports_4, context_4) {
    "use strict";
    var DenoStdInternalError;
    var __moduleName = context_4 && context_4.id;
    /** Make an assertion, if not `true`, then throw. */
    function assert(expr, msg = "") {
        if (!expr) {
            throw new DenoStdInternalError(msg);
        }
    }
    exports_4("assert", assert);
    return {
        setters: [],
        execute: function () {
            DenoStdInternalError = class DenoStdInternalError extends Error {
                constructor(message) {
                    super(message);
                    this.name = "DenoStdInternalError";
                }
            };
            exports_4("DenoStdInternalError", DenoStdInternalError);
        }
    };
});
// Copyright the Browserify authors. MIT License.
// Ported from https://github.com/browserify/path-browserify/
/** This module is browser compatible. */
System.register("https://deno.land/std/path/win32", ["https://deno.land/std/path/_constants", "https://deno.land/std/path/_util", "https://deno.land/std/_util/assert"], function (exports_5, context_5) {
    "use strict";
    var _constants_ts_2, _util_ts_1, assert_ts_1, sep, delimiter;
    var __moduleName = context_5 && context_5.id;
    function resolve(...pathSegments) {
        let resolvedDevice = "";
        let resolvedTail = "";
        let resolvedAbsolute = false;
        for (let i = pathSegments.length - 1; i >= -1; i--) {
            let path;
            if (i >= 0) {
                path = pathSegments[i];
            }
            else if (!resolvedDevice) {
                if (globalThis.Deno == null) {
                    throw new TypeError("Resolved a drive-letter-less path without a CWD.");
                }
                path = Deno.cwd();
            }
            else {
                if (globalThis.Deno == null) {
                    throw new TypeError("Resolved a relative path without a CWD.");
                }
                // Windows has the concept of drive-specific current working
                // directories. If we've resolved a drive letter but not yet an
                // absolute path, get cwd for that drive, or the process cwd if
                // the drive cwd is not available. We're sure the device is not
                // a UNC path at this points, because UNC paths are always absolute.
                path = Deno.env.get(`=${resolvedDevice}`) || Deno.cwd();
                // Verify that a cwd was found and that it actually points
                // to our drive. If not, default to the drive's root.
                if (path === undefined ||
                    path.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\`) {
                    path = `${resolvedDevice}\\`;
                }
            }
            _util_ts_1.assertPath(path);
            const len = path.length;
            // Skip empty entries
            if (len === 0)
                continue;
            let rootEnd = 0;
            let device = "";
            let isAbsolute = false;
            const code = path.charCodeAt(0);
            // Try to match a root
            if (len > 1) {
                if (_util_ts_1.isPathSeparator(code)) {
                    // Possible UNC root
                    // If we started with a separator, we know we at least have an
                    // absolute path of some kind (UNC or otherwise)
                    isAbsolute = true;
                    if (_util_ts_1.isPathSeparator(path.charCodeAt(1))) {
                        // Matched double path separator at beginning
                        let j = 2;
                        let last = j;
                        // Match 1 or more non-path separators
                        for (; j < len; ++j) {
                            if (_util_ts_1.isPathSeparator(path.charCodeAt(j)))
                                break;
                        }
                        if (j < len && j !== last) {
                            const firstPart = path.slice(last, j);
                            // Matched!
                            last = j;
                            // Match 1 or more path separators
                            for (; j < len; ++j) {
                                if (!_util_ts_1.isPathSeparator(path.charCodeAt(j)))
                                    break;
                            }
                            if (j < len && j !== last) {
                                // Matched!
                                last = j;
                                // Match 1 or more non-path separators
                                for (; j < len; ++j) {
                                    if (_util_ts_1.isPathSeparator(path.charCodeAt(j)))
                                        break;
                                }
                                if (j === len) {
                                    // We matched a UNC root only
                                    device = `\\\\${firstPart}\\${path.slice(last)}`;
                                    rootEnd = j;
                                }
                                else if (j !== last) {
                                    // We matched a UNC root with leftovers
                                    device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                                    rootEnd = j;
                                }
                            }
                        }
                    }
                    else {
                        rootEnd = 1;
                    }
                }
                else if (_util_ts_1.isWindowsDeviceRoot(code)) {
                    // Possible device root
                    if (path.charCodeAt(1) === _constants_ts_2.CHAR_COLON) {
                        device = path.slice(0, 2);
                        rootEnd = 2;
                        if (len > 2) {
                            if (_util_ts_1.isPathSeparator(path.charCodeAt(2))) {
                                // Treat separator following drive name as an absolute path
                                // indicator
                                isAbsolute = true;
                                rootEnd = 3;
                            }
                        }
                    }
                }
            }
            else if (_util_ts_1.isPathSeparator(code)) {
                // `path` contains just a path separator
                rootEnd = 1;
                isAbsolute = true;
            }
            if (device.length > 0 &&
                resolvedDevice.length > 0 &&
                device.toLowerCase() !== resolvedDevice.toLowerCase()) {
                // This path points to another device so it is not applicable
                continue;
            }
            if (resolvedDevice.length === 0 && device.length > 0) {
                resolvedDevice = device;
            }
            if (!resolvedAbsolute) {
                resolvedTail = `${path.slice(rootEnd)}\\${resolvedTail}`;
                resolvedAbsolute = isAbsolute;
            }
            if (resolvedAbsolute && resolvedDevice.length > 0)
                break;
        }
        // At this point the path should be resolved to a full absolute path,
        // but handle relative paths to be safe (might happen when process.cwd()
        // fails)
        // Normalize the tail path
        resolvedTail = _util_ts_1.normalizeString(resolvedTail, !resolvedAbsolute, "\\", _util_ts_1.isPathSeparator);
        return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
    }
    exports_5("resolve", resolve);
    function normalize(path) {
        _util_ts_1.assertPath(path);
        const len = path.length;
        if (len === 0)
            return ".";
        let rootEnd = 0;
        let device;
        let isAbsolute = false;
        const code = path.charCodeAt(0);
        // Try to match a root
        if (len > 1) {
            if (_util_ts_1.isPathSeparator(code)) {
                // Possible UNC root
                // If we started with a separator, we know we at least have an absolute
                // path of some kind (UNC or otherwise)
                isAbsolute = true;
                if (_util_ts_1.isPathSeparator(path.charCodeAt(1))) {
                    // Matched double path separator at beginning
                    let j = 2;
                    let last = j;
                    // Match 1 or more non-path separators
                    for (; j < len; ++j) {
                        if (_util_ts_1.isPathSeparator(path.charCodeAt(j)))
                            break;
                    }
                    if (j < len && j !== last) {
                        const firstPart = path.slice(last, j);
                        // Matched!
                        last = j;
                        // Match 1 or more path separators
                        for (; j < len; ++j) {
                            if (!_util_ts_1.isPathSeparator(path.charCodeAt(j)))
                                break;
                        }
                        if (j < len && j !== last) {
                            // Matched!
                            last = j;
                            // Match 1 or more non-path separators
                            for (; j < len; ++j) {
                                if (_util_ts_1.isPathSeparator(path.charCodeAt(j)))
                                    break;
                            }
                            if (j === len) {
                                // We matched a UNC root only
                                // Return the normalized version of the UNC root since there
                                // is nothing left to process
                                return `\\\\${firstPart}\\${path.slice(last)}\\`;
                            }
                            else if (j !== last) {
                                // We matched a UNC root with leftovers
                                device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                                rootEnd = j;
                            }
                        }
                    }
                }
                else {
                    rootEnd = 1;
                }
            }
            else if (_util_ts_1.isWindowsDeviceRoot(code)) {
                // Possible device root
                if (path.charCodeAt(1) === _constants_ts_2.CHAR_COLON) {
                    device = path.slice(0, 2);
                    rootEnd = 2;
                    if (len > 2) {
                        if (_util_ts_1.isPathSeparator(path.charCodeAt(2))) {
                            // Treat separator following drive name as an absolute path
                            // indicator
                            isAbsolute = true;
                            rootEnd = 3;
                        }
                    }
                }
            }
        }
        else if (_util_ts_1.isPathSeparator(code)) {
            // `path` contains just a path separator, exit early to avoid unnecessary
            // work
            return "\\";
        }
        let tail;
        if (rootEnd < len) {
            tail = _util_ts_1.normalizeString(path.slice(rootEnd), !isAbsolute, "\\", _util_ts_1.isPathSeparator);
        }
        else {
            tail = "";
        }
        if (tail.length === 0 && !isAbsolute)
            tail = ".";
        if (tail.length > 0 && _util_ts_1.isPathSeparator(path.charCodeAt(len - 1))) {
            tail += "\\";
        }
        if (device === undefined) {
            if (isAbsolute) {
                if (tail.length > 0)
                    return `\\${tail}`;
                else
                    return "\\";
            }
            else if (tail.length > 0) {
                return tail;
            }
            else {
                return "";
            }
        }
        else if (isAbsolute) {
            if (tail.length > 0)
                return `${device}\\${tail}`;
            else
                return `${device}\\`;
        }
        else if (tail.length > 0) {
            return device + tail;
        }
        else {
            return device;
        }
    }
    exports_5("normalize", normalize);
    function isAbsolute(path) {
        _util_ts_1.assertPath(path);
        const len = path.length;
        if (len === 0)
            return false;
        const code = path.charCodeAt(0);
        if (_util_ts_1.isPathSeparator(code)) {
            return true;
        }
        else if (_util_ts_1.isWindowsDeviceRoot(code)) {
            // Possible device root
            if (len > 2 && path.charCodeAt(1) === _constants_ts_2.CHAR_COLON) {
                if (_util_ts_1.isPathSeparator(path.charCodeAt(2)))
                    return true;
            }
        }
        return false;
    }
    exports_5("isAbsolute", isAbsolute);
    function join(...paths) {
        const pathsCount = paths.length;
        if (pathsCount === 0)
            return ".";
        let joined;
        let firstPart = null;
        for (let i = 0; i < pathsCount; ++i) {
            const path = paths[i];
            _util_ts_1.assertPath(path);
            if (path.length > 0) {
                if (joined === undefined)
                    joined = firstPart = path;
                else
                    joined += `\\${path}`;
            }
        }
        if (joined === undefined)
            return ".";
        // Make sure that the joined path doesn't start with two slashes, because
        // normalize() will mistake it for an UNC path then.
        //
        // This step is skipped when it is very clear that the user actually
        // intended to point at an UNC path. This is assumed when the first
        // non-empty string arguments starts with exactly two slashes followed by
        // at least one more non-slash character.
        //
        // Note that for normalize() to treat a path as an UNC path it needs to
        // have at least 2 components, so we don't filter for that here.
        // This means that the user can use join to construct UNC paths from
        // a server name and a share name; for example:
        //   path.join('//server', 'share') -> '\\\\server\\share\\')
        let needsReplace = true;
        let slashCount = 0;
        assert_ts_1.assert(firstPart != null);
        if (_util_ts_1.isPathSeparator(firstPart.charCodeAt(0))) {
            ++slashCount;
            const firstLen = firstPart.length;
            if (firstLen > 1) {
                if (_util_ts_1.isPathSeparator(firstPart.charCodeAt(1))) {
                    ++slashCount;
                    if (firstLen > 2) {
                        if (_util_ts_1.isPathSeparator(firstPart.charCodeAt(2)))
                            ++slashCount;
                        else {
                            // We matched a UNC path in the first part
                            needsReplace = false;
                        }
                    }
                }
            }
        }
        if (needsReplace) {
            // Find any more consecutive slashes we need to replace
            for (; slashCount < joined.length; ++slashCount) {
                if (!_util_ts_1.isPathSeparator(joined.charCodeAt(slashCount)))
                    break;
            }
            // Replace the slashes if needed
            if (slashCount >= 2)
                joined = `\\${joined.slice(slashCount)}`;
        }
        return normalize(joined);
    }
    exports_5("join", join);
    // It will solve the relative path from `from` to `to`, for instance:
    //  from = 'C:\\orandea\\test\\aaa'
    //  to = 'C:\\orandea\\impl\\bbb'
    // The output of the function should be: '..\\..\\impl\\bbb'
    function relative(from, to) {
        _util_ts_1.assertPath(from);
        _util_ts_1.assertPath(to);
        if (from === to)
            return "";
        const fromOrig = resolve(from);
        const toOrig = resolve(to);
        if (fromOrig === toOrig)
            return "";
        from = fromOrig.toLowerCase();
        to = toOrig.toLowerCase();
        if (from === to)
            return "";
        // Trim any leading backslashes
        let fromStart = 0;
        let fromEnd = from.length;
        for (; fromStart < fromEnd; ++fromStart) {
            if (from.charCodeAt(fromStart) !== _constants_ts_2.CHAR_BACKWARD_SLASH)
                break;
        }
        // Trim trailing backslashes (applicable to UNC paths only)
        for (; fromEnd - 1 > fromStart; --fromEnd) {
            if (from.charCodeAt(fromEnd - 1) !== _constants_ts_2.CHAR_BACKWARD_SLASH)
                break;
        }
        const fromLen = fromEnd - fromStart;
        // Trim any leading backslashes
        let toStart = 0;
        let toEnd = to.length;
        for (; toStart < toEnd; ++toStart) {
            if (to.charCodeAt(toStart) !== _constants_ts_2.CHAR_BACKWARD_SLASH)
                break;
        }
        // Trim trailing backslashes (applicable to UNC paths only)
        for (; toEnd - 1 > toStart; --toEnd) {
            if (to.charCodeAt(toEnd - 1) !== _constants_ts_2.CHAR_BACKWARD_SLASH)
                break;
        }
        const toLen = toEnd - toStart;
        // Compare paths to find the longest common path from root
        const length = fromLen < toLen ? fromLen : toLen;
        let lastCommonSep = -1;
        let i = 0;
        for (; i <= length; ++i) {
            if (i === length) {
                if (toLen > length) {
                    if (to.charCodeAt(toStart + i) === _constants_ts_2.CHAR_BACKWARD_SLASH) {
                        // We get here if `from` is the exact base path for `to`.
                        // For example: from='C:\\foo\\bar'; to='C:\\foo\\bar\\baz'
                        return toOrig.slice(toStart + i + 1);
                    }
                    else if (i === 2) {
                        // We get here if `from` is the device root.
                        // For example: from='C:\\'; to='C:\\foo'
                        return toOrig.slice(toStart + i);
                    }
                }
                if (fromLen > length) {
                    if (from.charCodeAt(fromStart + i) === _constants_ts_2.CHAR_BACKWARD_SLASH) {
                        // We get here if `to` is the exact base path for `from`.
                        // For example: from='C:\\foo\\bar'; to='C:\\foo'
                        lastCommonSep = i;
                    }
                    else if (i === 2) {
                        // We get here if `to` is the device root.
                        // For example: from='C:\\foo\\bar'; to='C:\\'
                        lastCommonSep = 3;
                    }
                }
                break;
            }
            const fromCode = from.charCodeAt(fromStart + i);
            const toCode = to.charCodeAt(toStart + i);
            if (fromCode !== toCode)
                break;
            else if (fromCode === _constants_ts_2.CHAR_BACKWARD_SLASH)
                lastCommonSep = i;
        }
        // We found a mismatch before the first common path separator was seen, so
        // return the original `to`.
        if (i !== length && lastCommonSep === -1) {
            return toOrig;
        }
        let out = "";
        if (lastCommonSep === -1)
            lastCommonSep = 0;
        // Generate the relative path based on the path difference between `to` and
        // `from`
        for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
            if (i === fromEnd || from.charCodeAt(i) === _constants_ts_2.CHAR_BACKWARD_SLASH) {
                if (out.length === 0)
                    out += "..";
                else
                    out += "\\..";
            }
        }
        // Lastly, append the rest of the destination (`to`) path that comes after
        // the common path parts
        if (out.length > 0) {
            return out + toOrig.slice(toStart + lastCommonSep, toEnd);
        }
        else {
            toStart += lastCommonSep;
            if (toOrig.charCodeAt(toStart) === _constants_ts_2.CHAR_BACKWARD_SLASH)
                ++toStart;
            return toOrig.slice(toStart, toEnd);
        }
    }
    exports_5("relative", relative);
    function toNamespacedPath(path) {
        // Note: this will *probably* throw somewhere.
        if (typeof path !== "string")
            return path;
        if (path.length === 0)
            return "";
        const resolvedPath = resolve(path);
        if (resolvedPath.length >= 3) {
            if (resolvedPath.charCodeAt(0) === _constants_ts_2.CHAR_BACKWARD_SLASH) {
                // Possible UNC root
                if (resolvedPath.charCodeAt(1) === _constants_ts_2.CHAR_BACKWARD_SLASH) {
                    const code = resolvedPath.charCodeAt(2);
                    if (code !== _constants_ts_2.CHAR_QUESTION_MARK && code !== _constants_ts_2.CHAR_DOT) {
                        // Matched non-long UNC root, convert the path to a long UNC path
                        return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
                    }
                }
            }
            else if (_util_ts_1.isWindowsDeviceRoot(resolvedPath.charCodeAt(0))) {
                // Possible device root
                if (resolvedPath.charCodeAt(1) === _constants_ts_2.CHAR_COLON &&
                    resolvedPath.charCodeAt(2) === _constants_ts_2.CHAR_BACKWARD_SLASH) {
                    // Matched device root, convert the path to a long UNC path
                    return `\\\\?\\${resolvedPath}`;
                }
            }
        }
        return path;
    }
    exports_5("toNamespacedPath", toNamespacedPath);
    function dirname(path) {
        _util_ts_1.assertPath(path);
        const len = path.length;
        if (len === 0)
            return ".";
        let rootEnd = -1;
        let end = -1;
        let matchedSlash = true;
        let offset = 0;
        const code = path.charCodeAt(0);
        // Try to match a root
        if (len > 1) {
            if (_util_ts_1.isPathSeparator(code)) {
                // Possible UNC root
                rootEnd = offset = 1;
                if (_util_ts_1.isPathSeparator(path.charCodeAt(1))) {
                    // Matched double path separator at beginning
                    let j = 2;
                    let last = j;
                    // Match 1 or more non-path separators
                    for (; j < len; ++j) {
                        if (_util_ts_1.isPathSeparator(path.charCodeAt(j)))
                            break;
                    }
                    if (j < len && j !== last) {
                        // Matched!
                        last = j;
                        // Match 1 or more path separators
                        for (; j < len; ++j) {
                            if (!_util_ts_1.isPathSeparator(path.charCodeAt(j)))
                                break;
                        }
                        if (j < len && j !== last) {
                            // Matched!
                            last = j;
                            // Match 1 or more non-path separators
                            for (; j < len; ++j) {
                                if (_util_ts_1.isPathSeparator(path.charCodeAt(j)))
                                    break;
                            }
                            if (j === len) {
                                // We matched a UNC root only
                                return path;
                            }
                            if (j !== last) {
                                // We matched a UNC root with leftovers
                                // Offset by 1 to include the separator after the UNC root to
                                // treat it as a "normal root" on top of a (UNC) root
                                rootEnd = offset = j + 1;
                            }
                        }
                    }
                }
            }
            else if (_util_ts_1.isWindowsDeviceRoot(code)) {
                // Possible device root
                if (path.charCodeAt(1) === _constants_ts_2.CHAR_COLON) {
                    rootEnd = offset = 2;
                    if (len > 2) {
                        if (_util_ts_1.isPathSeparator(path.charCodeAt(2)))
                            rootEnd = offset = 3;
                    }
                }
            }
        }
        else if (_util_ts_1.isPathSeparator(code)) {
            // `path` contains just a path separator, exit early to avoid
            // unnecessary work
            return path;
        }
        for (let i = len - 1; i >= offset; --i) {
            if (_util_ts_1.isPathSeparator(path.charCodeAt(i))) {
                if (!matchedSlash) {
                    end = i;
                    break;
                }
            }
            else {
                // We saw the first non-path separator
                matchedSlash = false;
            }
        }
        if (end === -1) {
            if (rootEnd === -1)
                return ".";
            else
                end = rootEnd;
        }
        return path.slice(0, end);
    }
    exports_5("dirname", dirname);
    function basename(path, ext = "") {
        if (ext !== undefined && typeof ext !== "string") {
            throw new TypeError('"ext" argument must be a string');
        }
        _util_ts_1.assertPath(path);
        let start = 0;
        let end = -1;
        let matchedSlash = true;
        let i;
        // Check for a drive letter prefix so as not to mistake the following
        // path separator as an extra separator at the end of the path that can be
        // disregarded
        if (path.length >= 2) {
            const drive = path.charCodeAt(0);
            if (_util_ts_1.isWindowsDeviceRoot(drive)) {
                if (path.charCodeAt(1) === _constants_ts_2.CHAR_COLON)
                    start = 2;
            }
        }
        if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
            if (ext.length === path.length && ext === path)
                return "";
            let extIdx = ext.length - 1;
            let firstNonSlashEnd = -1;
            for (i = path.length - 1; i >= start; --i) {
                const code = path.charCodeAt(i);
                if (_util_ts_1.isPathSeparator(code)) {
                    // If we reached a path separator that was not part of a set of path
                    // separators at the end of the string, stop now
                    if (!matchedSlash) {
                        start = i + 1;
                        break;
                    }
                }
                else {
                    if (firstNonSlashEnd === -1) {
                        // We saw the first non-path separator, remember this index in case
                        // we need it if the extension ends up not matching
                        matchedSlash = false;
                        firstNonSlashEnd = i + 1;
                    }
                    if (extIdx >= 0) {
                        // Try to match the explicit extension
                        if (code === ext.charCodeAt(extIdx)) {
                            if (--extIdx === -1) {
                                // We matched the extension, so mark this as the end of our path
                                // component
                                end = i;
                            }
                        }
                        else {
                            // Extension does not match, so our result is the entire path
                            // component
                            extIdx = -1;
                            end = firstNonSlashEnd;
                        }
                    }
                }
            }
            if (start === end)
                end = firstNonSlashEnd;
            else if (end === -1)
                end = path.length;
            return path.slice(start, end);
        }
        else {
            for (i = path.length - 1; i >= start; --i) {
                if (_util_ts_1.isPathSeparator(path.charCodeAt(i))) {
                    // If we reached a path separator that was not part of a set of path
                    // separators at the end of the string, stop now
                    if (!matchedSlash) {
                        start = i + 1;
                        break;
                    }
                }
                else if (end === -1) {
                    // We saw the first non-path separator, mark this as the end of our
                    // path component
                    matchedSlash = false;
                    end = i + 1;
                }
            }
            if (end === -1)
                return "";
            return path.slice(start, end);
        }
    }
    exports_5("basename", basename);
    function extname(path) {
        _util_ts_1.assertPath(path);
        let start = 0;
        let startDot = -1;
        let startPart = 0;
        let end = -1;
        let matchedSlash = true;
        // Track the state of characters (if any) we see before our first dot and
        // after any path separator we find
        let preDotState = 0;
        // Check for a drive letter prefix so as not to mistake the following
        // path separator as an extra separator at the end of the path that can be
        // disregarded
        if (path.length >= 2 &&
            path.charCodeAt(1) === _constants_ts_2.CHAR_COLON &&
            _util_ts_1.isWindowsDeviceRoot(path.charCodeAt(0))) {
            start = startPart = 2;
        }
        for (let i = path.length - 1; i >= start; --i) {
            const code = path.charCodeAt(i);
            if (_util_ts_1.isPathSeparator(code)) {
                // If we reached a path separator that was not part of a set of path
                // separators at the end of the string, stop now
                if (!matchedSlash) {
                    startPart = i + 1;
                    break;
                }
                continue;
            }
            if (end === -1) {
                // We saw the first non-path separator, mark this as the end of our
                // extension
                matchedSlash = false;
                end = i + 1;
            }
            if (code === _constants_ts_2.CHAR_DOT) {
                // If this is our first dot, mark it as the start of our extension
                if (startDot === -1)
                    startDot = i;
                else if (preDotState !== 1)
                    preDotState = 1;
            }
            else if (startDot !== -1) {
                // We saw a non-dot and non-path separator before our dot, so we should
                // have a good chance at having a non-empty extension
                preDotState = -1;
            }
        }
        if (startDot === -1 ||
            end === -1 ||
            // We saw a non-dot character immediately before the dot
            preDotState === 0 ||
            // The (right-most) trimmed path component is exactly '..'
            (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)) {
            return "";
        }
        return path.slice(startDot, end);
    }
    exports_5("extname", extname);
    function format(pathObject) {
        /* eslint-disable max-len */
        if (pathObject === null || typeof pathObject !== "object") {
            throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
        }
        return _util_ts_1._format("\\", pathObject);
    }
    exports_5("format", format);
    function parse(path) {
        _util_ts_1.assertPath(path);
        const ret = { root: "", dir: "", base: "", ext: "", name: "" };
        const len = path.length;
        if (len === 0)
            return ret;
        let rootEnd = 0;
        let code = path.charCodeAt(0);
        // Try to match a root
        if (len > 1) {
            if (_util_ts_1.isPathSeparator(code)) {
                // Possible UNC root
                rootEnd = 1;
                if (_util_ts_1.isPathSeparator(path.charCodeAt(1))) {
                    // Matched double path separator at beginning
                    let j = 2;
                    let last = j;
                    // Match 1 or more non-path separators
                    for (; j < len; ++j) {
                        if (_util_ts_1.isPathSeparator(path.charCodeAt(j)))
                            break;
                    }
                    if (j < len && j !== last) {
                        // Matched!
                        last = j;
                        // Match 1 or more path separators
                        for (; j < len; ++j) {
                            if (!_util_ts_1.isPathSeparator(path.charCodeAt(j)))
                                break;
                        }
                        if (j < len && j !== last) {
                            // Matched!
                            last = j;
                            // Match 1 or more non-path separators
                            for (; j < len; ++j) {
                                if (_util_ts_1.isPathSeparator(path.charCodeAt(j)))
                                    break;
                            }
                            if (j === len) {
                                // We matched a UNC root only
                                rootEnd = j;
                            }
                            else if (j !== last) {
                                // We matched a UNC root with leftovers
                                rootEnd = j + 1;
                            }
                        }
                    }
                }
            }
            else if (_util_ts_1.isWindowsDeviceRoot(code)) {
                // Possible device root
                if (path.charCodeAt(1) === _constants_ts_2.CHAR_COLON) {
                    rootEnd = 2;
                    if (len > 2) {
                        if (_util_ts_1.isPathSeparator(path.charCodeAt(2))) {
                            if (len === 3) {
                                // `path` contains just a drive root, exit early to avoid
                                // unnecessary work
                                ret.root = ret.dir = path;
                                return ret;
                            }
                            rootEnd = 3;
                        }
                    }
                    else {
                        // `path` contains just a drive root, exit early to avoid
                        // unnecessary work
                        ret.root = ret.dir = path;
                        return ret;
                    }
                }
            }
        }
        else if (_util_ts_1.isPathSeparator(code)) {
            // `path` contains just a path separator, exit early to avoid
            // unnecessary work
            ret.root = ret.dir = path;
            return ret;
        }
        if (rootEnd > 0)
            ret.root = path.slice(0, rootEnd);
        let startDot = -1;
        let startPart = rootEnd;
        let end = -1;
        let matchedSlash = true;
        let i = path.length - 1;
        // Track the state of characters (if any) we see before our first dot and
        // after any path separator we find
        let preDotState = 0;
        // Get non-dir info
        for (; i >= rootEnd; --i) {
            code = path.charCodeAt(i);
            if (_util_ts_1.isPathSeparator(code)) {
                // If we reached a path separator that was not part of a set of path
                // separators at the end of the string, stop now
                if (!matchedSlash) {
                    startPart = i + 1;
                    break;
                }
                continue;
            }
            if (end === -1) {
                // We saw the first non-path separator, mark this as the end of our
                // extension
                matchedSlash = false;
                end = i + 1;
            }
            if (code === _constants_ts_2.CHAR_DOT) {
                // If this is our first dot, mark it as the start of our extension
                if (startDot === -1)
                    startDot = i;
                else if (preDotState !== 1)
                    preDotState = 1;
            }
            else if (startDot !== -1) {
                // We saw a non-dot and non-path separator before our dot, so we should
                // have a good chance at having a non-empty extension
                preDotState = -1;
            }
        }
        if (startDot === -1 ||
            end === -1 ||
            // We saw a non-dot character immediately before the dot
            preDotState === 0 ||
            // The (right-most) trimmed path component is exactly '..'
            (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)) {
            if (end !== -1) {
                ret.base = ret.name = path.slice(startPart, end);
            }
        }
        else {
            ret.name = path.slice(startPart, startDot);
            ret.base = path.slice(startPart, end);
            ret.ext = path.slice(startDot, end);
        }
        // If the directory is the root, use the entire root as the `dir` including
        // the trailing slash if any (`C:\abc` -> `C:\`). Otherwise, strip out the
        // trailing slash (`C:\abc\def` -> `C:\abc`).
        if (startPart > 0 && startPart !== rootEnd) {
            ret.dir = path.slice(0, startPart - 1);
        }
        else
            ret.dir = ret.root;
        return ret;
    }
    exports_5("parse", parse);
    /** Converts a file URL to a path string.
     *
     *      fromFileUrl("file:///C:/Users/foo"); // "C:\\Users\\foo"
     *      fromFileUrl("file:///home/foo"); // "\\home\\foo"
     *
     * Note that non-file URLs are treated as file URLs and irrelevant components
     * are ignored.
     */
    function fromFileUrl(url) {
        return new URL(url).pathname
            .replace(/^\/*([A-Za-z]:)(\/|$)/, "$1/")
            .replace(/\//g, "\\");
    }
    exports_5("fromFileUrl", fromFileUrl);
    return {
        setters: [
            function (_constants_ts_2_1) {
                _constants_ts_2 = _constants_ts_2_1;
            },
            function (_util_ts_1_1) {
                _util_ts_1 = _util_ts_1_1;
            },
            function (assert_ts_1_1) {
                assert_ts_1 = assert_ts_1_1;
            }
        ],
        execute: function () {
            exports_5("sep", sep = "\\");
            exports_5("delimiter", delimiter = ";");
        }
    };
});
// Copyright the Browserify authors. MIT License.
// Ported from https://github.com/browserify/path-browserify/
/** This module is browser compatible. */
System.register("https://deno.land/std/path/posix", ["https://deno.land/std/path/_constants", "https://deno.land/std/path/_util"], function (exports_6, context_6) {
    "use strict";
    var _constants_ts_3, _util_ts_2, sep, delimiter;
    var __moduleName = context_6 && context_6.id;
    // path.resolve([from ...], to)
    function resolve(...pathSegments) {
        let resolvedPath = "";
        let resolvedAbsolute = false;
        for (let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
            let path;
            if (i >= 0)
                path = pathSegments[i];
            else {
                if (globalThis.Deno == null) {
                    throw new TypeError("Resolved a relative path without a CWD.");
                }
                path = Deno.cwd();
            }
            _util_ts_2.assertPath(path);
            // Skip empty entries
            if (path.length === 0) {
                continue;
            }
            resolvedPath = `${path}/${resolvedPath}`;
            resolvedAbsolute = path.charCodeAt(0) === _constants_ts_3.CHAR_FORWARD_SLASH;
        }
        // At this point the path should be resolved to a full absolute path, but
        // handle relative paths to be safe (might happen when process.cwd() fails)
        // Normalize the path
        resolvedPath = _util_ts_2.normalizeString(resolvedPath, !resolvedAbsolute, "/", _util_ts_2.isPosixPathSeparator);
        if (resolvedAbsolute) {
            if (resolvedPath.length > 0)
                return `/${resolvedPath}`;
            else
                return "/";
        }
        else if (resolvedPath.length > 0)
            return resolvedPath;
        else
            return ".";
    }
    exports_6("resolve", resolve);
    function normalize(path) {
        _util_ts_2.assertPath(path);
        if (path.length === 0)
            return ".";
        const isAbsolute = path.charCodeAt(0) === _constants_ts_3.CHAR_FORWARD_SLASH;
        const trailingSeparator = path.charCodeAt(path.length - 1) === _constants_ts_3.CHAR_FORWARD_SLASH;
        // Normalize the path
        path = _util_ts_2.normalizeString(path, !isAbsolute, "/", _util_ts_2.isPosixPathSeparator);
        if (path.length === 0 && !isAbsolute)
            path = ".";
        if (path.length > 0 && trailingSeparator)
            path += "/";
        if (isAbsolute)
            return `/${path}`;
        return path;
    }
    exports_6("normalize", normalize);
    function isAbsolute(path) {
        _util_ts_2.assertPath(path);
        return path.length > 0 && path.charCodeAt(0) === _constants_ts_3.CHAR_FORWARD_SLASH;
    }
    exports_6("isAbsolute", isAbsolute);
    function join(...paths) {
        if (paths.length === 0)
            return ".";
        let joined;
        for (let i = 0, len = paths.length; i < len; ++i) {
            const path = paths[i];
            _util_ts_2.assertPath(path);
            if (path.length > 0) {
                if (!joined)
                    joined = path;
                else
                    joined += `/${path}`;
            }
        }
        if (!joined)
            return ".";
        return normalize(joined);
    }
    exports_6("join", join);
    function relative(from, to) {
        _util_ts_2.assertPath(from);
        _util_ts_2.assertPath(to);
        if (from === to)
            return "";
        from = resolve(from);
        to = resolve(to);
        if (from === to)
            return "";
        // Trim any leading backslashes
        let fromStart = 1;
        const fromEnd = from.length;
        for (; fromStart < fromEnd; ++fromStart) {
            if (from.charCodeAt(fromStart) !== _constants_ts_3.CHAR_FORWARD_SLASH)
                break;
        }
        const fromLen = fromEnd - fromStart;
        // Trim any leading backslashes
        let toStart = 1;
        const toEnd = to.length;
        for (; toStart < toEnd; ++toStart) {
            if (to.charCodeAt(toStart) !== _constants_ts_3.CHAR_FORWARD_SLASH)
                break;
        }
        const toLen = toEnd - toStart;
        // Compare paths to find the longest common path from root
        const length = fromLen < toLen ? fromLen : toLen;
        let lastCommonSep = -1;
        let i = 0;
        for (; i <= length; ++i) {
            if (i === length) {
                if (toLen > length) {
                    if (to.charCodeAt(toStart + i) === _constants_ts_3.CHAR_FORWARD_SLASH) {
                        // We get here if `from` is the exact base path for `to`.
                        // For example: from='/foo/bar'; to='/foo/bar/baz'
                        return to.slice(toStart + i + 1);
                    }
                    else if (i === 0) {
                        // We get here if `from` is the root
                        // For example: from='/'; to='/foo'
                        return to.slice(toStart + i);
                    }
                }
                else if (fromLen > length) {
                    if (from.charCodeAt(fromStart + i) === _constants_ts_3.CHAR_FORWARD_SLASH) {
                        // We get here if `to` is the exact base path for `from`.
                        // For example: from='/foo/bar/baz'; to='/foo/bar'
                        lastCommonSep = i;
                    }
                    else if (i === 0) {
                        // We get here if `to` is the root.
                        // For example: from='/foo'; to='/'
                        lastCommonSep = 0;
                    }
                }
                break;
            }
            const fromCode = from.charCodeAt(fromStart + i);
            const toCode = to.charCodeAt(toStart + i);
            if (fromCode !== toCode)
                break;
            else if (fromCode === _constants_ts_3.CHAR_FORWARD_SLASH)
                lastCommonSep = i;
        }
        let out = "";
        // Generate the relative path based on the path difference between `to`
        // and `from`
        for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
            if (i === fromEnd || from.charCodeAt(i) === _constants_ts_3.CHAR_FORWARD_SLASH) {
                if (out.length === 0)
                    out += "..";
                else
                    out += "/..";
            }
        }
        // Lastly, append the rest of the destination (`to`) path that comes after
        // the common path parts
        if (out.length > 0)
            return out + to.slice(toStart + lastCommonSep);
        else {
            toStart += lastCommonSep;
            if (to.charCodeAt(toStart) === _constants_ts_3.CHAR_FORWARD_SLASH)
                ++toStart;
            return to.slice(toStart);
        }
    }
    exports_6("relative", relative);
    function toNamespacedPath(path) {
        // Non-op on posix systems
        return path;
    }
    exports_6("toNamespacedPath", toNamespacedPath);
    function dirname(path) {
        _util_ts_2.assertPath(path);
        if (path.length === 0)
            return ".";
        const hasRoot = path.charCodeAt(0) === _constants_ts_3.CHAR_FORWARD_SLASH;
        let end = -1;
        let matchedSlash = true;
        for (let i = path.length - 1; i >= 1; --i) {
            if (path.charCodeAt(i) === _constants_ts_3.CHAR_FORWARD_SLASH) {
                if (!matchedSlash) {
                    end = i;
                    break;
                }
            }
            else {
                // We saw the first non-path separator
                matchedSlash = false;
            }
        }
        if (end === -1)
            return hasRoot ? "/" : ".";
        if (hasRoot && end === 1)
            return "//";
        return path.slice(0, end);
    }
    exports_6("dirname", dirname);
    function basename(path, ext = "") {
        if (ext !== undefined && typeof ext !== "string") {
            throw new TypeError('"ext" argument must be a string');
        }
        _util_ts_2.assertPath(path);
        let start = 0;
        let end = -1;
        let matchedSlash = true;
        let i;
        if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
            if (ext.length === path.length && ext === path)
                return "";
            let extIdx = ext.length - 1;
            let firstNonSlashEnd = -1;
            for (i = path.length - 1; i >= 0; --i) {
                const code = path.charCodeAt(i);
                if (code === _constants_ts_3.CHAR_FORWARD_SLASH) {
                    // If we reached a path separator that was not part of a set of path
                    // separators at the end of the string, stop now
                    if (!matchedSlash) {
                        start = i + 1;
                        break;
                    }
                }
                else {
                    if (firstNonSlashEnd === -1) {
                        // We saw the first non-path separator, remember this index in case
                        // we need it if the extension ends up not matching
                        matchedSlash = false;
                        firstNonSlashEnd = i + 1;
                    }
                    if (extIdx >= 0) {
                        // Try to match the explicit extension
                        if (code === ext.charCodeAt(extIdx)) {
                            if (--extIdx === -1) {
                                // We matched the extension, so mark this as the end of our path
                                // component
                                end = i;
                            }
                        }
                        else {
                            // Extension does not match, so our result is the entire path
                            // component
                            extIdx = -1;
                            end = firstNonSlashEnd;
                        }
                    }
                }
            }
            if (start === end)
                end = firstNonSlashEnd;
            else if (end === -1)
                end = path.length;
            return path.slice(start, end);
        }
        else {
            for (i = path.length - 1; i >= 0; --i) {
                if (path.charCodeAt(i) === _constants_ts_3.CHAR_FORWARD_SLASH) {
                    // If we reached a path separator that was not part of a set of path
                    // separators at the end of the string, stop now
                    if (!matchedSlash) {
                        start = i + 1;
                        break;
                    }
                }
                else if (end === -1) {
                    // We saw the first non-path separator, mark this as the end of our
                    // path component
                    matchedSlash = false;
                    end = i + 1;
                }
            }
            if (end === -1)
                return "";
            return path.slice(start, end);
        }
    }
    exports_6("basename", basename);
    function extname(path) {
        _util_ts_2.assertPath(path);
        let startDot = -1;
        let startPart = 0;
        let end = -1;
        let matchedSlash = true;
        // Track the state of characters (if any) we see before our first dot and
        // after any path separator we find
        let preDotState = 0;
        for (let i = path.length - 1; i >= 0; --i) {
            const code = path.charCodeAt(i);
            if (code === _constants_ts_3.CHAR_FORWARD_SLASH) {
                // If we reached a path separator that was not part of a set of path
                // separators at the end of the string, stop now
                if (!matchedSlash) {
                    startPart = i + 1;
                    break;
                }
                continue;
            }
            if (end === -1) {
                // We saw the first non-path separator, mark this as the end of our
                // extension
                matchedSlash = false;
                end = i + 1;
            }
            if (code === _constants_ts_3.CHAR_DOT) {
                // If this is our first dot, mark it as the start of our extension
                if (startDot === -1)
                    startDot = i;
                else if (preDotState !== 1)
                    preDotState = 1;
            }
            else if (startDot !== -1) {
                // We saw a non-dot and non-path separator before our dot, so we should
                // have a good chance at having a non-empty extension
                preDotState = -1;
            }
        }
        if (startDot === -1 ||
            end === -1 ||
            // We saw a non-dot character immediately before the dot
            preDotState === 0 ||
            // The (right-most) trimmed path component is exactly '..'
            (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)) {
            return "";
        }
        return path.slice(startDot, end);
    }
    exports_6("extname", extname);
    function format(pathObject) {
        /* eslint-disable max-len */
        if (pathObject === null || typeof pathObject !== "object") {
            throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
        }
        return _util_ts_2._format("/", pathObject);
    }
    exports_6("format", format);
    function parse(path) {
        _util_ts_2.assertPath(path);
        const ret = { root: "", dir: "", base: "", ext: "", name: "" };
        if (path.length === 0)
            return ret;
        const isAbsolute = path.charCodeAt(0) === _constants_ts_3.CHAR_FORWARD_SLASH;
        let start;
        if (isAbsolute) {
            ret.root = "/";
            start = 1;
        }
        else {
            start = 0;
        }
        let startDot = -1;
        let startPart = 0;
        let end = -1;
        let matchedSlash = true;
        let i = path.length - 1;
        // Track the state of characters (if any) we see before our first dot and
        // after any path separator we find
        let preDotState = 0;
        // Get non-dir info
        for (; i >= start; --i) {
            const code = path.charCodeAt(i);
            if (code === _constants_ts_3.CHAR_FORWARD_SLASH) {
                // If we reached a path separator that was not part of a set of path
                // separators at the end of the string, stop now
                if (!matchedSlash) {
                    startPart = i + 1;
                    break;
                }
                continue;
            }
            if (end === -1) {
                // We saw the first non-path separator, mark this as the end of our
                // extension
                matchedSlash = false;
                end = i + 1;
            }
            if (code === _constants_ts_3.CHAR_DOT) {
                // If this is our first dot, mark it as the start of our extension
                if (startDot === -1)
                    startDot = i;
                else if (preDotState !== 1)
                    preDotState = 1;
            }
            else if (startDot !== -1) {
                // We saw a non-dot and non-path separator before our dot, so we should
                // have a good chance at having a non-empty extension
                preDotState = -1;
            }
        }
        if (startDot === -1 ||
            end === -1 ||
            // We saw a non-dot character immediately before the dot
            preDotState === 0 ||
            // The (right-most) trimmed path component is exactly '..'
            (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)) {
            if (end !== -1) {
                if (startPart === 0 && isAbsolute) {
                    ret.base = ret.name = path.slice(1, end);
                }
                else {
                    ret.base = ret.name = path.slice(startPart, end);
                }
            }
        }
        else {
            if (startPart === 0 && isAbsolute) {
                ret.name = path.slice(1, startDot);
                ret.base = path.slice(1, end);
            }
            else {
                ret.name = path.slice(startPart, startDot);
                ret.base = path.slice(startPart, end);
            }
            ret.ext = path.slice(startDot, end);
        }
        if (startPart > 0)
            ret.dir = path.slice(0, startPart - 1);
        else if (isAbsolute)
            ret.dir = "/";
        return ret;
    }
    exports_6("parse", parse);
    /** Converts a file URL to a path string.
     *
     *      fromFileUrl("file:///home/foo"); // "/home/foo"
     *
     * Note that non-file URLs are treated as file URLs and irrelevant components
     * are ignored.
     */
    function fromFileUrl(url) {
        return new URL(url).pathname;
    }
    exports_6("fromFileUrl", fromFileUrl);
    return {
        setters: [
            function (_constants_ts_3_1) {
                _constants_ts_3 = _constants_ts_3_1;
            },
            function (_util_ts_2_1) {
                _util_ts_2 = _util_ts_2_1;
            }
        ],
        execute: function () {
            exports_6("sep", sep = "/");
            exports_6("delimiter", delimiter = ":");
        }
    };
});
// Copyright 2018-2020 the Deno authors. All rights reserved. MIT license.
/** This module is browser compatible. */
System.register("https://deno.land/std/path/separator", ["https://deno.land/std/path/_constants"], function (exports_7, context_7) {
    "use strict";
    var _constants_ts_4, SEP, SEP_PATTERN;
    var __moduleName = context_7 && context_7.id;
    return {
        setters: [
            function (_constants_ts_4_1) {
                _constants_ts_4 = _constants_ts_4_1;
            }
        ],
        execute: function () {
            exports_7("SEP", SEP = _constants_ts_4.isWindows ? "\\" : "/");
            exports_7("SEP_PATTERN", SEP_PATTERN = _constants_ts_4.isWindows ? /[\\/]+/ : /\/+/);
        }
    };
});
// Copyright 2018-2020 the Deno authors. All rights reserved. MIT license.
/** This module is browser compatible. */
System.register("https://deno.land/std/path/common", ["https://deno.land/std/path/separator"], function (exports_8, context_8) {
    "use strict";
    var separator_ts_1;
    var __moduleName = context_8 && context_8.id;
    /** Determines the common path from a set of paths, using an optional separator,
     * which defaults to the OS default separator.
     *
     *       import { common } from "https://deno.land/std/path/mod.ts";
     *       const p = common([
     *         "./deno/std/path/mod.ts",
     *         "./deno/std/fs/mod.ts",
     *       ]);
     *       console.log(p); // "./deno/std/"
     *
     */
    function common(paths, sep = separator_ts_1.SEP) {
        const [first = "", ...remaining] = paths;
        if (first === "" || remaining.length === 0) {
            return first.substring(0, first.lastIndexOf(sep) + 1);
        }
        const parts = first.split(sep);
        let endOfPrefix = parts.length;
        for (const path of remaining) {
            const compare = path.split(sep);
            for (let i = 0; i < endOfPrefix; i++) {
                if (compare[i] !== parts[i]) {
                    endOfPrefix = i;
                }
            }
            if (endOfPrefix === 0) {
                return "";
            }
        }
        const prefix = parts.slice(0, endOfPrefix).join(sep);
        return prefix.endsWith(sep) ? prefix : `${prefix}${sep}`;
    }
    exports_8("common", common);
    return {
        setters: [
            function (separator_ts_1_1) {
                separator_ts_1 = separator_ts_1_1;
            }
        ],
        execute: function () {
        }
    };
});
// This file is ported from globrex@0.1.2
// MIT License
// Copyright (c) 2018 Terkel Gjervig Nielsen
/** This module is browser compatible. */
System.register("https://deno.land/std/path/_globrex", ["https://deno.land/std/path/_constants"], function (exports_9, context_9) {
    "use strict";
    var _constants_ts_5, SEP, SEP_ESC, SEP_RAW, GLOBSTAR, WILDCARD, GLOBSTAR_SEGMENT, WILDCARD_SEGMENT;
    var __moduleName = context_9 && context_9.id;
    /**
     * Convert any glob pattern to a JavaScript Regexp object
     * @param glob Glob pattern to convert
     * @param opts Configuration object
     * @returns Converted object with string, segments and RegExp object
     */
    function globrex(glob, { extended = false, globstar = false, strict = false, filepath = false, flags = "", } = {}) {
        const sepPattern = new RegExp(`^${SEP}${strict ? "" : "+"}$`);
        let regex = "";
        let segment = "";
        let pathRegexStr = "";
        const pathSegments = [];
        // If we are doing extended matching, this boolean is true when we are inside
        // a group (eg {*.html,*.js}), and false otherwise.
        let inGroup = false;
        let inRange = false;
        // extglob stack. Keep track of scope
        const ext = [];
        // Helper function to build string and segments
        function add(str, options = { split: false, last: false, only: "" }) {
            const { split, last, only } = options;
            if (only !== "path")
                regex += str;
            if (filepath && only !== "regex") {
                pathRegexStr += str.match(sepPattern) ? SEP : str;
                if (split) {
                    if (last)
                        segment += str;
                    if (segment !== "") {
                        // change it 'includes'
                        if (!flags.includes("g"))
                            segment = `^${segment}$`;
                        pathSegments.push(new RegExp(segment, flags));
                    }
                    segment = "";
                }
                else {
                    segment += str;
                }
            }
        }
        let c, n;
        for (let i = 0; i < glob.length; i++) {
            c = glob[i];
            n = glob[i + 1];
            if (["\\", "$", "^", ".", "="].includes(c)) {
                add(`\\${c}`);
                continue;
            }
            if (c.match(sepPattern)) {
                add(SEP, { split: true });
                if (n != null && n.match(sepPattern) && !strict)
                    regex += "?";
                continue;
            }
            if (c === "(") {
                if (ext.length) {
                    add(`${c}?:`);
                    continue;
                }
                add(`\\${c}`);
                continue;
            }
            if (c === ")") {
                if (ext.length) {
                    add(c);
                    const type = ext.pop();
                    if (type === "@") {
                        add("{1}");
                    }
                    else if (type === "!") {
                        add(WILDCARD);
                    }
                    else {
                        add(type);
                    }
                    continue;
                }
                add(`\\${c}`);
                continue;
            }
            if (c === "|") {
                if (ext.length) {
                    add(c);
                    continue;
                }
                add(`\\${c}`);
                continue;
            }
            if (c === "+") {
                if (n === "(" && extended) {
                    ext.push(c);
                    continue;
                }
                add(`\\${c}`);
                continue;
            }
            if (c === "@" && extended) {
                if (n === "(") {
                    ext.push(c);
                    continue;
                }
            }
            if (c === "!") {
                if (extended) {
                    if (inRange) {
                        add("^");
                        continue;
                    }
                    if (n === "(") {
                        ext.push(c);
                        add("(?!");
                        i++;
                        continue;
                    }
                    add(`\\${c}`);
                    continue;
                }
                add(`\\${c}`);
                continue;
            }
            if (c === "?") {
                if (extended) {
                    if (n === "(") {
                        ext.push(c);
                    }
                    else {
                        add(".");
                    }
                    continue;
                }
                add(`\\${c}`);
                continue;
            }
            if (c === "[") {
                if (inRange && n === ":") {
                    i++; // skip [
                    let value = "";
                    while (glob[++i] !== ":")
                        value += glob[i];
                    if (value === "alnum")
                        add("(?:\\w|\\d)");
                    else if (value === "space")
                        add("\\s");
                    else if (value === "digit")
                        add("\\d");
                    i++; // skip last ]
                    continue;
                }
                if (extended) {
                    inRange = true;
                    add(c);
                    continue;
                }
                add(`\\${c}`);
                continue;
            }
            if (c === "]") {
                if (extended) {
                    inRange = false;
                    add(c);
                    continue;
                }
                add(`\\${c}`);
                continue;
            }
            if (c === "{") {
                if (extended) {
                    inGroup = true;
                    add("(?:");
                    continue;
                }
                add(`\\${c}`);
                continue;
            }
            if (c === "}") {
                if (extended) {
                    inGroup = false;
                    add(")");
                    continue;
                }
                add(`\\${c}`);
                continue;
            }
            if (c === ",") {
                if (inGroup) {
                    add("|");
                    continue;
                }
                add(`\\${c}`);
                continue;
            }
            if (c === "*") {
                if (n === "(" && extended) {
                    ext.push(c);
                    continue;
                }
                // Move over all consecutive "*"'s.
                // Also store the previous and next characters
                const prevChar = glob[i - 1];
                let starCount = 1;
                while (glob[i + 1] === "*") {
                    starCount++;
                    i++;
                }
                const nextChar = glob[i + 1];
                if (!globstar) {
                    // globstar is disabled, so treat any number of "*" as one
                    add(".*");
                }
                else {
                    // globstar is enabled, so determine if this is a globstar segment
                    const isGlobstar = starCount > 1 && // multiple "*"'s
                        // from the start of the segment
                        [SEP_RAW, "/", undefined].includes(prevChar) &&
                        // to the end of the segment
                        [SEP_RAW, "/", undefined].includes(nextChar);
                    if (isGlobstar) {
                        // it's a globstar, so match zero or more path segments
                        add(GLOBSTAR, { only: "regex" });
                        add(GLOBSTAR_SEGMENT, { only: "path", last: true, split: true });
                        i++; // move over the "/"
                    }
                    else {
                        // it's not a globstar, so only match one path segment
                        add(WILDCARD, { only: "regex" });
                        add(WILDCARD_SEGMENT, { only: "path" });
                    }
                }
                continue;
            }
            add(c);
        }
        // When regexp 'g' flag is specified don't
        // constrain the regular expression with ^ & $
        if (!flags.includes("g")) {
            regex = `^${regex}$`;
            segment = `^${segment}$`;
            if (filepath)
                pathRegexStr = `^${pathRegexStr}$`;
        }
        const result = { regex: new RegExp(regex, flags) };
        // Push the last segment
        if (filepath) {
            pathSegments.push(new RegExp(segment, flags));
            result.path = {
                regex: new RegExp(pathRegexStr, flags),
                segments: pathSegments,
                globstar: new RegExp(!flags.includes("g") ? `^${GLOBSTAR_SEGMENT}$` : GLOBSTAR_SEGMENT, flags),
            };
        }
        return result;
    }
    exports_9("globrex", globrex);
    return {
        setters: [
            function (_constants_ts_5_1) {
                _constants_ts_5 = _constants_ts_5_1;
            }
        ],
        execute: function () {
            SEP = _constants_ts_5.isWindows ? `(?:\\\\|\\/)` : `\\/`;
            SEP_ESC = _constants_ts_5.isWindows ? `\\\\` : `/`;
            SEP_RAW = _constants_ts_5.isWindows ? `\\` : `/`;
            GLOBSTAR = `(?:(?:[^${SEP_ESC}/]*(?:${SEP_ESC}|\/|$))*)`;
            WILDCARD = `(?:[^${SEP_ESC}/]*)`;
            GLOBSTAR_SEGMENT = `((?:[^${SEP_ESC}/]*(?:${SEP_ESC}|\/|$))*)`;
            WILDCARD_SEGMENT = `(?:[^${SEP_ESC}/]*)`;
        }
    };
});
// Copyright 2018-2020 the Deno authors. All rights reserved. MIT license.
/** This module is browser compatible. */
System.register("https://deno.land/std/path/glob", ["https://deno.land/std/path/separator", "https://deno.land/std/path/_globrex", "https://deno.land/std/path/mod", "https://deno.land/std/_util/assert"], function (exports_10, context_10) {
    "use strict";
    var separator_ts_2, _globrex_ts_1, mod_ts_1, assert_ts_2;
    var __moduleName = context_10 && context_10.id;
    /**
     * Generate a regex based on glob pattern and options
     * This was meant to be using the the `fs.walk` function
     * but can be used anywhere else.
     * Examples:
     *
     *     Looking for all the `ts` files:
     *     walkSync(".", {
     *       match: [globToRegExp("*.ts")]
     *     })
     *
     *     Looking for all the `.json` files in any subfolder:
     *     walkSync(".", {
     *       match: [globToRegExp(join("a", "**", "*.json"),{
     *         flags: "g",
     *         extended: true,
     *         globstar: true
     *       })]
     *     })
     *
     * @param glob - Glob pattern to be used
     * @param options - Specific options for the glob pattern
     * @returns A RegExp for the glob pattern
     */
    function globToRegExp(glob, { extended = false, globstar = true } = {}) {
        const result = _globrex_ts_1.globrex(glob, {
            extended,
            globstar,
            strict: false,
            filepath: true,
        });
        assert_ts_2.assert(result.path != null);
        return result.path.regex;
    }
    exports_10("globToRegExp", globToRegExp);
    /** Test whether the given string is a glob */
    function isGlob(str) {
        const chars = { "{": "}", "(": ")", "[": "]" };
        /* eslint-disable-next-line max-len */
        const regex = /\\(.)|(^!|\*|[\].+)]\?|\[[^\\\]]+\]|\{[^\\}]+\}|\(\?[:!=][^\\)]+\)|\([^|]+\|[^\\)]+\))/;
        if (str === "") {
            return false;
        }
        let match;
        while ((match = regex.exec(str))) {
            if (match[2])
                return true;
            let idx = match.index + match[0].length;
            // if an open bracket/brace/paren is escaped,
            // set the index to the next closing character
            const open = match[1];
            const close = open ? chars[open] : null;
            if (open && close) {
                const n = str.indexOf(close, idx);
                if (n !== -1) {
                    idx = n + 1;
                }
            }
            str = str.slice(idx);
        }
        return false;
    }
    exports_10("isGlob", isGlob);
    /** Like normalize(), but doesn't collapse "**\/.." when `globstar` is true. */
    function normalizeGlob(glob, { globstar = false } = {}) {
        if (!!glob.match(/\0/g)) {
            throw new Error(`Glob contains invalid characters: "${glob}"`);
        }
        if (!globstar) {
            return mod_ts_1.normalize(glob);
        }
        const s = separator_ts_2.SEP_PATTERN.source;
        const badParentPattern = new RegExp(`(?<=(${s}|^)\\*\\*${s})\\.\\.(?=${s}|$)`, "g");
        return mod_ts_1.normalize(glob.replace(badParentPattern, "\0")).replace(/\0/g, "..");
    }
    exports_10("normalizeGlob", normalizeGlob);
    /** Like join(), but doesn't collapse "**\/.." when `globstar` is true. */
    function joinGlobs(globs, { extended = false, globstar = false } = {}) {
        if (!globstar || globs.length == 0) {
            return mod_ts_1.join(...globs);
        }
        if (globs.length === 0)
            return ".";
        let joined;
        for (const glob of globs) {
            const path = glob;
            if (path.length > 0) {
                if (!joined)
                    joined = path;
                else
                    joined += `${separator_ts_2.SEP}${path}`;
            }
        }
        if (!joined)
            return ".";
        return normalizeGlob(joined, { extended, globstar });
    }
    exports_10("joinGlobs", joinGlobs);
    return {
        setters: [
            function (separator_ts_2_1) {
                separator_ts_2 = separator_ts_2_1;
            },
            function (_globrex_ts_1_1) {
                _globrex_ts_1 = _globrex_ts_1_1;
            },
            function (mod_ts_1_1) {
                mod_ts_1 = mod_ts_1_1;
            },
            function (assert_ts_2_1) {
                assert_ts_2 = assert_ts_2_1;
            }
        ],
        execute: function () {
        }
    };
});
// Copyright the Browserify authors. MIT License.
// Ported mostly from https://github.com/browserify/path-browserify/
/** This module is browser compatible. */
System.register("https://deno.land/std/path/mod", ["https://deno.land/std/path/_constants", "https://deno.land/std/path/win32", "https://deno.land/std/path/posix", "https://deno.land/std/path/common", "https://deno.land/std/path/separator", "https://deno.land/std/path/_interface", "https://deno.land/std/path/glob"], function (exports_11, context_11) {
    "use strict";
    var _constants_ts_6, _win32, _posix, path, win32, posix, basename, delimiter, dirname, extname, format, fromFileUrl, isAbsolute, join, normalize, parse, relative, resolve, sep, toNamespacedPath;
    var __moduleName = context_11 && context_11.id;
    var exportedNames_1 = {
        "win32": true,
        "posix": true,
        "basename": true,
        "delimiter": true,
        "dirname": true,
        "extname": true,
        "format": true,
        "fromFileUrl": true,
        "isAbsolute": true,
        "join": true,
        "normalize": true,
        "parse": true,
        "relative": true,
        "resolve": true,
        "sep": true,
        "toNamespacedPath": true,
        "SEP": true,
        "SEP_PATTERN": true
    };
    function exportStar_1(m) {
        var exports = {};
        for (var n in m) {
            if (n !== "default" && !exportedNames_1.hasOwnProperty(n)) exports[n] = m[n];
        }
        exports_11(exports);
    }
    return {
        setters: [
            function (_constants_ts_6_1) {
                _constants_ts_6 = _constants_ts_6_1;
            },
            function (_win32_1) {
                _win32 = _win32_1;
            },
            function (_posix_1) {
                _posix = _posix_1;
            },
            function (common_ts_1_1) {
                exportStar_1(common_ts_1_1);
            },
            function (separator_ts_3_1) {
                exports_11({
                    "SEP": separator_ts_3_1["SEP"],
                    "SEP_PATTERN": separator_ts_3_1["SEP_PATTERN"]
                });
            },
            function (_interface_ts_1_1) {
                exportStar_1(_interface_ts_1_1);
            },
            function (glob_ts_1_1) {
                exportStar_1(glob_ts_1_1);
            }
        ],
        execute: function () {
            path = _constants_ts_6.isWindows ? _win32 : _posix;
            exports_11("win32", win32 = _win32);
            exports_11("posix", posix = _posix);
            exports_11("basename", basename = path.basename), exports_11("delimiter", delimiter = path.delimiter), exports_11("dirname", dirname = path.dirname), exports_11("extname", extname = path.extname), exports_11("format", format = path.format), exports_11("fromFileUrl", fromFileUrl = path.fromFileUrl), exports_11("isAbsolute", isAbsolute = path.isAbsolute), exports_11("join", join = path.join), exports_11("normalize", normalize = path.normalize), exports_11("parse", parse = path.parse), exports_11("relative", relative = path.relative), exports_11("resolve", resolve = path.resolve), exports_11("sep", sep = path.sep), exports_11("toNamespacedPath", toNamespacedPath = path.toNamespacedPath);
        }
    };
});
System.register("https://deno.land/std/fs/empty_dir", ["https://deno.land/std/path/mod"], function (exports_12, context_12) {
    "use strict";
    var mod_ts_2;
    var __moduleName = context_12 && context_12.id;
    /**
     * Ensures that a directory is empty.
     * Deletes directory contents if the directory is not empty.
     * If the directory does not exist, it is created.
     * The directory itself is not deleted.
     * Requires the `--allow-read` and `--allow-write` flag.
     */
    async function emptyDir(dir) {
        try {
            const items = [];
            for await (const dirEntry of Deno.readDir(dir)) {
                items.push(dirEntry);
            }
            while (items.length) {
                const item = items.shift();
                if (item && item.name) {
                    const filepath = mod_ts_2.join(dir, item.name);
                    await Deno.remove(filepath, { recursive: true });
                }
            }
        }
        catch (err) {
            if (!(err instanceof Deno.errors.NotFound)) {
                throw err;
            }
            // if not exist. then create it
            await Deno.mkdir(dir, { recursive: true });
        }
    }
    exports_12("emptyDir", emptyDir);
    /**
     * Ensures that a directory is empty.
     * Deletes directory contents if the directory is not empty.
     * If the directory does not exist, it is created.
     * The directory itself is not deleted.
     * Requires the `--allow-read` and `--allow-write` flag.
     */
    function emptyDirSync(dir) {
        try {
            const items = [...Deno.readDirSync(dir)];
            // If the directory exists, remove all entries inside it.
            while (items.length) {
                const item = items.shift();
                if (item && item.name) {
                    const filepath = mod_ts_2.join(dir, item.name);
                    Deno.removeSync(filepath, { recursive: true });
                }
            }
        }
        catch (err) {
            if (!(err instanceof Deno.errors.NotFound)) {
                throw err;
            }
            // if not exist. then create it
            Deno.mkdirSync(dir, { recursive: true });
            return;
        }
    }
    exports_12("emptyDirSync", emptyDirSync);
    return {
        setters: [
            function (mod_ts_2_1) {
                mod_ts_2 = mod_ts_2_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std/fs/_util", ["https://deno.land/std/path/mod"], function (exports_13, context_13) {
    "use strict";
    var path;
    var __moduleName = context_13 && context_13.id;
    /**
     * Test whether or not `dest` is a sub-directory of `src`
     * @param src src file path
     * @param dest dest file path
     * @param sep path separator
     */
    function isSubdir(src, dest, sep = path.sep) {
        if (src === dest) {
            return false;
        }
        const srcArray = src.split(sep);
        const destArray = dest.split(sep);
        return srcArray.every((current, i) => destArray[i] === current);
    }
    exports_13("isSubdir", isSubdir);
    /**
     * Get a human readable file type string.
     *
     * @param fileInfo A FileInfo describes a file and is returned by `stat`,
     *                 `lstat`
     */
    function getFileInfoType(fileInfo) {
        return fileInfo.isFile
            ? "file"
            : fileInfo.isDirectory
                ? "dir"
                : fileInfo.isSymlink
                    ? "symlink"
                    : undefined;
    }
    exports_13("getFileInfoType", getFileInfoType);
    return {
        setters: [
            function (path_1) {
                path = path_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std/fs/ensure_dir", ["https://deno.land/std/fs/_util"], function (exports_14, context_14) {
    "use strict";
    var _util_ts_3;
    var __moduleName = context_14 && context_14.id;
    /**
     * Ensures that the directory exists.
     * If the directory structure does not exist, it is created. Like mkdir -p.
     * Requires the `--allow-read` and `--allow-write` flag.
     */
    async function ensureDir(dir) {
        try {
            const fileInfo = await Deno.lstat(dir);
            if (!fileInfo.isDirectory) {
                throw new Error(`Ensure path exists, expected 'dir', got '${_util_ts_3.getFileInfoType(fileInfo)}'`);
            }
        }
        catch (err) {
            if (err instanceof Deno.errors.NotFound) {
                // if dir not exists. then create it.
                await Deno.mkdir(dir, { recursive: true });
                return;
            }
            throw err;
        }
    }
    exports_14("ensureDir", ensureDir);
    /**
     * Ensures that the directory exists.
     * If the directory structure does not exist, it is created. Like mkdir -p.
     * Requires the `--allow-read` and `--allow-write` flag.
     */
    function ensureDirSync(dir) {
        try {
            const fileInfo = Deno.lstatSync(dir);
            if (!fileInfo.isDirectory) {
                throw new Error(`Ensure path exists, expected 'dir', got '${_util_ts_3.getFileInfoType(fileInfo)}'`);
            }
        }
        catch (err) {
            if (err instanceof Deno.errors.NotFound) {
                // if dir not exists. then create it.
                Deno.mkdirSync(dir, { recursive: true });
                return;
            }
            throw err;
        }
    }
    exports_14("ensureDirSync", ensureDirSync);
    return {
        setters: [
            function (_util_ts_3_1) {
                _util_ts_3 = _util_ts_3_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std/fs/ensure_file", ["https://deno.land/std/path/mod", "https://deno.land/std/fs/ensure_dir", "https://deno.land/std/fs/_util"], function (exports_15, context_15) {
    "use strict";
    var path, ensure_dir_ts_1, _util_ts_4;
    var __moduleName = context_15 && context_15.id;
    /**
     * Ensures that the file exists.
     * If the file that is requested to be created is in directories that do not
     * exist.
     * these directories are created. If the file already exists,
     * it is NOTMODIFIED.
     * Requires the `--allow-read` and `--allow-write` flag.
     */
    async function ensureFile(filePath) {
        try {
            // if file exists
            const stat = await Deno.lstat(filePath);
            if (!stat.isFile) {
                throw new Error(`Ensure path exists, expected 'file', got '${_util_ts_4.getFileInfoType(stat)}'`);
            }
        }
        catch (err) {
            // if file not exists
            if (err instanceof Deno.errors.NotFound) {
                // ensure dir exists
                await ensure_dir_ts_1.ensureDir(path.dirname(filePath));
                // create file
                await Deno.writeFile(filePath, new Uint8Array());
                return;
            }
            throw err;
        }
    }
    exports_15("ensureFile", ensureFile);
    /**
     * Ensures that the file exists.
     * If the file that is requested to be created is in directories that do not
     * exist,
     * these directories are created. If the file already exists,
     * it is NOT MODIFIED.
     * Requires the `--allow-read` and `--allow-write` flag.
     */
    function ensureFileSync(filePath) {
        try {
            // if file exists
            const stat = Deno.lstatSync(filePath);
            if (!stat.isFile) {
                throw new Error(`Ensure path exists, expected 'file', got '${_util_ts_4.getFileInfoType(stat)}'`);
            }
        }
        catch (err) {
            // if file not exists
            if (err instanceof Deno.errors.NotFound) {
                // ensure dir exists
                ensure_dir_ts_1.ensureDirSync(path.dirname(filePath));
                // create file
                Deno.writeFileSync(filePath, new Uint8Array());
                return;
            }
            throw err;
        }
    }
    exports_15("ensureFileSync", ensureFileSync);
    return {
        setters: [
            function (path_2) {
                path = path_2;
            },
            function (ensure_dir_ts_1_1) {
                ensure_dir_ts_1 = ensure_dir_ts_1_1;
            },
            function (_util_ts_4_1) {
                _util_ts_4 = _util_ts_4_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std/fs/exists", [], function (exports_16, context_16) {
    "use strict";
    var __moduleName = context_16 && context_16.id;
    // Copyright 2018-2020 the Deno authors. All rights reserved. MIT license.
    /**
     * Test whether or not the given path exists by checking with the file system
     */
    async function exists(filePath) {
        try {
            await Deno.lstat(filePath);
            return true;
        }
        catch (err) {
            if (err instanceof Deno.errors.NotFound) {
                return false;
            }
            throw err;
        }
    }
    exports_16("exists", exists);
    /**
     * Test whether or not the given path exists by checking with the file system
     */
    function existsSync(filePath) {
        try {
            Deno.lstatSync(filePath);
            return true;
        }
        catch (err) {
            if (err instanceof Deno.errors.NotFound) {
                return false;
            }
            throw err;
        }
    }
    exports_16("existsSync", existsSync);
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std/fs/ensure_link", ["https://deno.land/std/path/mod", "https://deno.land/std/fs/ensure_dir", "https://deno.land/std/fs/exists", "https://deno.land/std/fs/_util"], function (exports_17, context_17) {
    "use strict";
    var path, ensure_dir_ts_2, exists_ts_1, _util_ts_5;
    var __moduleName = context_17 && context_17.id;
    /**
     * Ensures that the hard link exists.
     * If the directory structure does not exist, it is created.
     *
     * @param src the source file path. Directory hard links are not allowed.
     * @param dest the destination link path
     */
    async function ensureLink(src, dest) {
        if (await exists_ts_1.exists(dest)) {
            const destStatInfo = await Deno.lstat(dest);
            const destFilePathType = _util_ts_5.getFileInfoType(destStatInfo);
            if (destFilePathType !== "file") {
                throw new Error(`Ensure path exists, expected 'file', got '${destFilePathType}'`);
            }
            return;
        }
        await ensure_dir_ts_2.ensureDir(path.dirname(dest));
        await Deno.link(src, dest);
    }
    exports_17("ensureLink", ensureLink);
    /**
     * Ensures that the hard link exists.
     * If the directory structure does not exist, it is created.
     *
     * @param src the source file path. Directory hard links are not allowed.
     * @param dest the destination link path
     */
    function ensureLinkSync(src, dest) {
        if (exists_ts_1.existsSync(dest)) {
            const destStatInfo = Deno.lstatSync(dest);
            const destFilePathType = _util_ts_5.getFileInfoType(destStatInfo);
            if (destFilePathType !== "file") {
                throw new Error(`Ensure path exists, expected 'file', got '${destFilePathType}'`);
            }
            return;
        }
        ensure_dir_ts_2.ensureDirSync(path.dirname(dest));
        Deno.linkSync(src, dest);
    }
    exports_17("ensureLinkSync", ensureLinkSync);
    return {
        setters: [
            function (path_3) {
                path = path_3;
            },
            function (ensure_dir_ts_2_1) {
                ensure_dir_ts_2 = ensure_dir_ts_2_1;
            },
            function (exists_ts_1_1) {
                exists_ts_1 = exists_ts_1_1;
            },
            function (_util_ts_5_1) {
                _util_ts_5 = _util_ts_5_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std/fs/ensure_symlink", ["https://deno.land/std/path/mod", "https://deno.land/std/fs/ensure_dir", "https://deno.land/std/fs/exists", "https://deno.land/std/fs/_util"], function (exports_18, context_18) {
    "use strict";
    var path, ensure_dir_ts_3, exists_ts_2, _util_ts_6;
    var __moduleName = context_18 && context_18.id;
    /**
     * Ensures that the link exists.
     * If the directory structure does not exist, it is created.
     *
     * @param src the source file path
     * @param dest the destination link path
     */
    async function ensureSymlink(src, dest) {
        const srcStatInfo = await Deno.lstat(src);
        const srcFilePathType = _util_ts_6.getFileInfoType(srcStatInfo);
        if (await exists_ts_2.exists(dest)) {
            const destStatInfo = await Deno.lstat(dest);
            const destFilePathType = _util_ts_6.getFileInfoType(destStatInfo);
            if (destFilePathType !== "symlink") {
                throw new Error(`Ensure path exists, expected 'symlink', got '${destFilePathType}'`);
            }
            return;
        }
        await ensure_dir_ts_3.ensureDir(path.dirname(dest));
        if (Deno.build.os === "windows") {
            await Deno.symlink(src, dest, {
                type: srcFilePathType === "dir" ? "dir" : "file",
            });
        }
        else {
            await Deno.symlink(src, dest);
        }
    }
    exports_18("ensureSymlink", ensureSymlink);
    /**
     * Ensures that the link exists.
     * If the directory structure does not exist, it is created.
     *
     * @param src the source file path
     * @param dest the destination link path
     */
    function ensureSymlinkSync(src, dest) {
        const srcStatInfo = Deno.lstatSync(src);
        const srcFilePathType = _util_ts_6.getFileInfoType(srcStatInfo);
        if (exists_ts_2.existsSync(dest)) {
            const destStatInfo = Deno.lstatSync(dest);
            const destFilePathType = _util_ts_6.getFileInfoType(destStatInfo);
            if (destFilePathType !== "symlink") {
                throw new Error(`Ensure path exists, expected 'symlink', got '${destFilePathType}'`);
            }
            return;
        }
        ensure_dir_ts_3.ensureDirSync(path.dirname(dest));
        if (Deno.build.os === "windows") {
            Deno.symlinkSync(src, dest, {
                type: srcFilePathType === "dir" ? "dir" : "file",
            });
        }
        else {
            Deno.symlinkSync(src, dest);
        }
    }
    exports_18("ensureSymlinkSync", ensureSymlinkSync);
    return {
        setters: [
            function (path_4) {
                path = path_4;
            },
            function (ensure_dir_ts_3_1) {
                ensure_dir_ts_3 = ensure_dir_ts_3_1;
            },
            function (exists_ts_2_1) {
                exists_ts_2 = exists_ts_2_1;
            },
            function (_util_ts_6_1) {
                _util_ts_6 = _util_ts_6_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std/fs/walk", ["https://deno.land/std/_util/assert", "https://deno.land/std/path/mod"], function (exports_19, context_19) {
    "use strict";
    var assert_ts_3, mod_ts_3;
    var __moduleName = context_19 && context_19.id;
    function createWalkEntrySync(path) {
        path = mod_ts_3.normalize(path);
        const name = mod_ts_3.basename(path);
        const info = Deno.statSync(path);
        return {
            path,
            name,
            isFile: info.isFile,
            isDirectory: info.isDirectory,
            isSymlink: info.isSymlink,
        };
    }
    exports_19("createWalkEntrySync", createWalkEntrySync);
    async function createWalkEntry(path) {
        path = mod_ts_3.normalize(path);
        const name = mod_ts_3.basename(path);
        const info = await Deno.stat(path);
        return {
            path,
            name,
            isFile: info.isFile,
            isDirectory: info.isDirectory,
            isSymlink: info.isSymlink,
        };
    }
    exports_19("createWalkEntry", createWalkEntry);
    function include(path, exts, match, skip) {
        if (exts && !exts.some((ext) => path.endsWith(ext))) {
            return false;
        }
        if (match && !match.some((pattern) => !!path.match(pattern))) {
            return false;
        }
        if (skip && skip.some((pattern) => !!path.match(pattern))) {
            return false;
        }
        return true;
    }
    /** Walks the file tree rooted at root, yielding each file or directory in the
     * tree filtered according to the given options. The files are walked in lexical
     * order, which makes the output deterministic but means that for very large
     * directories walk() can be inefficient.
     *
     * Options:
     * - maxDepth?: number = Infinity;
     * - includeFiles?: boolean = true;
     * - includeDirs?: boolean = true;
     * - followSymlinks?: boolean = false;
     * - exts?: string[];
     * - match?: RegExp[];
     * - skip?: RegExp[];
     *
     *      for await (const entry of walk(".")) {
     *        console.log(entry.path);
     *        assert(entry.isFile);
     *      };
     */
    async function* walk(root, { maxDepth = Infinity, includeFiles = true, includeDirs = true, followSymlinks = false, exts = undefined, match = undefined, skip = undefined, } = {}) {
        if (maxDepth < 0) {
            return;
        }
        if (includeDirs && include(root, exts, match, skip)) {
            yield await createWalkEntry(root);
        }
        if (maxDepth < 1 || !include(root, undefined, undefined, skip)) {
            return;
        }
        for await (const entry of Deno.readDir(root)) {
            if (entry.isSymlink) {
                if (followSymlinks) {
                    // TODO(ry) Re-enable followSymlinks.
                    throw new Error("unimplemented");
                }
                else {
                    continue;
                }
            }
            assert_ts_3.assert(entry.name != null);
            const path = mod_ts_3.join(root, entry.name);
            if (entry.isFile) {
                if (includeFiles && include(path, exts, match, skip)) {
                    yield { path, ...entry };
                }
            }
            else {
                yield* walk(path, {
                    maxDepth: maxDepth - 1,
                    includeFiles,
                    includeDirs,
                    followSymlinks,
                    exts,
                    match,
                    skip,
                });
            }
        }
    }
    exports_19("walk", walk);
    /** Same as walk() but uses synchronous ops */
    function* walkSync(root, { maxDepth = Infinity, includeFiles = true, includeDirs = true, followSymlinks = false, exts = undefined, match = undefined, skip = undefined, } = {}) {
        if (maxDepth < 0) {
            return;
        }
        if (includeDirs && include(root, exts, match, skip)) {
            yield createWalkEntrySync(root);
        }
        if (maxDepth < 1 || !include(root, undefined, undefined, skip)) {
            return;
        }
        for (const entry of Deno.readDirSync(root)) {
            if (entry.isSymlink) {
                if (followSymlinks) {
                    throw new Error("unimplemented");
                }
                else {
                    continue;
                }
            }
            assert_ts_3.assert(entry.name != null);
            const path = mod_ts_3.join(root, entry.name);
            if (entry.isFile) {
                if (includeFiles && include(path, exts, match, skip)) {
                    yield { path, ...entry };
                }
            }
            else {
                yield* walkSync(path, {
                    maxDepth: maxDepth - 1,
                    includeFiles,
                    includeDirs,
                    followSymlinks,
                    exts,
                    match,
                    skip,
                });
            }
        }
    }
    exports_19("walkSync", walkSync);
    return {
        setters: [
            function (assert_ts_3_1) {
                assert_ts_3 = assert_ts_3_1;
            },
            function (mod_ts_3_1) {
                mod_ts_3 = mod_ts_3_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std/fs/expand_glob", ["https://deno.land/std/path/mod", "https://deno.land/std/fs/walk", "https://deno.land/std/_util/assert"], function (exports_20, context_20) {
    "use strict";
    var mod_ts_4, walk_ts_1, assert_ts_4, isWindows;
    var __moduleName = context_20 && context_20.id;
    // TODO: Maybe make this public somewhere.
    function split(path) {
        const s = mod_ts_4.SEP_PATTERN.source;
        const segments = path
            .replace(new RegExp(`^${s}|${s}$`, "g"), "")
            .split(mod_ts_4.SEP_PATTERN);
        const isAbsolute_ = mod_ts_4.isAbsolute(path);
        return {
            segments,
            isAbsolute: isAbsolute_,
            hasTrailingSep: !!path.match(new RegExp(`${s}$`)),
            winRoot: isWindows && isAbsolute_ ? segments.shift() : undefined,
        };
    }
    function throwUnlessNotFound(error) {
        if (!(error instanceof Deno.errors.NotFound)) {
            throw error;
        }
    }
    function comparePath(a, b) {
        if (a.path < b.path)
            return -1;
        if (a.path > b.path)
            return 1;
        return 0;
    }
    /**
     * Expand the glob string from the specified `root` directory and yield each
     * result as a `WalkEntry` object.
     *
     * Examples:
     *
     *     for await (const file of expandGlob("**\/*.ts")) {
     *       console.log(file);
     *     }
     */
    async function* expandGlob(glob, { root = Deno.cwd(), exclude = [], includeDirs = true, extended = false, globstar = false, } = {}) {
        const globOptions = { extended, globstar };
        const absRoot = mod_ts_4.isAbsolute(root)
            ? mod_ts_4.normalize(root)
            : mod_ts_4.joinGlobs([Deno.cwd(), root], globOptions);
        const resolveFromRoot = (path) => mod_ts_4.isAbsolute(path)
            ? mod_ts_4.normalize(path)
            : mod_ts_4.joinGlobs([absRoot, path], globOptions);
        const excludePatterns = exclude
            .map(resolveFromRoot)
            .map((s) => mod_ts_4.globToRegExp(s, globOptions));
        const shouldInclude = (path) => !excludePatterns.some((p) => !!path.match(p));
        const { segments, hasTrailingSep, winRoot } = split(resolveFromRoot(glob));
        let fixedRoot = winRoot != undefined ? winRoot : "/";
        while (segments.length > 0 && !mod_ts_4.isGlob(segments[0])) {
            const seg = segments.shift();
            assert_ts_4.assert(seg != null);
            fixedRoot = mod_ts_4.joinGlobs([fixedRoot, seg], globOptions);
        }
        let fixedRootInfo;
        try {
            fixedRootInfo = await walk_ts_1.createWalkEntry(fixedRoot);
        }
        catch (error) {
            return throwUnlessNotFound(error);
        }
        async function* advanceMatch(walkInfo, globSegment) {
            if (!walkInfo.isDirectory) {
                return;
            }
            else if (globSegment == "..") {
                const parentPath = mod_ts_4.joinGlobs([walkInfo.path, ".."], globOptions);
                try {
                    if (shouldInclude(parentPath)) {
                        return yield await walk_ts_1.createWalkEntry(parentPath);
                    }
                }
                catch (error) {
                    throwUnlessNotFound(error);
                }
                return;
            }
            else if (globSegment == "**") {
                return yield* walk_ts_1.walk(walkInfo.path, {
                    includeFiles: false,
                    skip: excludePatterns,
                });
            }
            yield* walk_ts_1.walk(walkInfo.path, {
                maxDepth: 1,
                match: [
                    mod_ts_4.globToRegExp(mod_ts_4.joinGlobs([walkInfo.path, globSegment], globOptions), globOptions),
                ],
                skip: excludePatterns,
            });
        }
        let currentMatches = [fixedRootInfo];
        for (const segment of segments) {
            // Advancing the list of current matches may introduce duplicates, so we
            // pass everything through this Map.
            const nextMatchMap = new Map();
            for (const currentMatch of currentMatches) {
                for await (const nextMatch of advanceMatch(currentMatch, segment)) {
                    nextMatchMap.set(nextMatch.path, nextMatch);
                }
            }
            currentMatches = [...nextMatchMap.values()].sort(comparePath);
        }
        if (hasTrailingSep) {
            currentMatches = currentMatches.filter((entry) => entry.isDirectory);
        }
        if (!includeDirs) {
            currentMatches = currentMatches.filter((entry) => !entry.isDirectory);
        }
        yield* currentMatches;
    }
    exports_20("expandGlob", expandGlob);
    /**
     * Synchronous version of `expandGlob()`.
     *
     * Examples:
     *
     *     for (const file of expandGlobSync("**\/*.ts")) {
     *       console.log(file);
     *     }
     */
    function* expandGlobSync(glob, { root = Deno.cwd(), exclude = [], includeDirs = true, extended = false, globstar = false, } = {}) {
        const globOptions = { extended, globstar };
        const absRoot = mod_ts_4.isAbsolute(root)
            ? mod_ts_4.normalize(root)
            : mod_ts_4.joinGlobs([Deno.cwd(), root], globOptions);
        const resolveFromRoot = (path) => mod_ts_4.isAbsolute(path)
            ? mod_ts_4.normalize(path)
            : mod_ts_4.joinGlobs([absRoot, path], globOptions);
        const excludePatterns = exclude
            .map(resolveFromRoot)
            .map((s) => mod_ts_4.globToRegExp(s, globOptions));
        const shouldInclude = (path) => !excludePatterns.some((p) => !!path.match(p));
        const { segments, hasTrailingSep, winRoot } = split(resolveFromRoot(glob));
        let fixedRoot = winRoot != undefined ? winRoot : "/";
        while (segments.length > 0 && !mod_ts_4.isGlob(segments[0])) {
            const seg = segments.shift();
            assert_ts_4.assert(seg != null);
            fixedRoot = mod_ts_4.joinGlobs([fixedRoot, seg], globOptions);
        }
        let fixedRootInfo;
        try {
            fixedRootInfo = walk_ts_1.createWalkEntrySync(fixedRoot);
        }
        catch (error) {
            return throwUnlessNotFound(error);
        }
        function* advanceMatch(walkInfo, globSegment) {
            if (!walkInfo.isDirectory) {
                return;
            }
            else if (globSegment == "..") {
                const parentPath = mod_ts_4.joinGlobs([walkInfo.path, ".."], globOptions);
                try {
                    if (shouldInclude(parentPath)) {
                        return yield walk_ts_1.createWalkEntrySync(parentPath);
                    }
                }
                catch (error) {
                    throwUnlessNotFound(error);
                }
                return;
            }
            else if (globSegment == "**") {
                return yield* walk_ts_1.walkSync(walkInfo.path, {
                    includeFiles: false,
                    skip: excludePatterns,
                });
            }
            yield* walk_ts_1.walkSync(walkInfo.path, {
                maxDepth: 1,
                match: [
                    mod_ts_4.globToRegExp(mod_ts_4.joinGlobs([walkInfo.path, globSegment], globOptions), globOptions),
                ],
                skip: excludePatterns,
            });
        }
        let currentMatches = [fixedRootInfo];
        for (const segment of segments) {
            // Advancing the list of current matches may introduce duplicates, so we
            // pass everything through this Map.
            const nextMatchMap = new Map();
            for (const currentMatch of currentMatches) {
                for (const nextMatch of advanceMatch(currentMatch, segment)) {
                    nextMatchMap.set(nextMatch.path, nextMatch);
                }
            }
            currentMatches = [...nextMatchMap.values()].sort(comparePath);
        }
        if (hasTrailingSep) {
            currentMatches = currentMatches.filter((entry) => entry.isDirectory);
        }
        if (!includeDirs) {
            currentMatches = currentMatches.filter((entry) => !entry.isDirectory);
        }
        yield* currentMatches;
    }
    exports_20("expandGlobSync", expandGlobSync);
    return {
        setters: [
            function (mod_ts_4_1) {
                mod_ts_4 = mod_ts_4_1;
            },
            function (walk_ts_1_1) {
                walk_ts_1 = walk_ts_1_1;
            },
            function (assert_ts_4_1) {
                assert_ts_4 = assert_ts_4_1;
            }
        ],
        execute: function () {
            isWindows = Deno.build.os == "windows";
        }
    };
});
System.register("https://deno.land/std/fs/move", ["https://deno.land/std/fs/exists", "https://deno.land/std/fs/_util"], function (exports_21, context_21) {
    "use strict";
    var exists_ts_3, _util_ts_7;
    var __moduleName = context_21 && context_21.id;
    /** Moves a file or directory */
    async function move(src, dest, { overwrite = false } = {}) {
        const srcStat = await Deno.stat(src);
        if (srcStat.isDirectory && _util_ts_7.isSubdir(src, dest)) {
            throw new Error(`Cannot move '${src}' to a subdirectory of itself, '${dest}'.`);
        }
        if (overwrite) {
            if (await exists_ts_3.exists(dest)) {
                await Deno.remove(dest, { recursive: true });
            }
            await Deno.rename(src, dest);
        }
        else {
            if (await exists_ts_3.exists(dest)) {
                throw new Error("dest already exists.");
            }
            await Deno.rename(src, dest);
        }
        return;
    }
    exports_21("move", move);
    /** Moves a file or directory synchronously */
    function moveSync(src, dest, { overwrite = false } = {}) {
        const srcStat = Deno.statSync(src);
        if (srcStat.isDirectory && _util_ts_7.isSubdir(src, dest)) {
            throw new Error(`Cannot move '${src}' to a subdirectory of itself, '${dest}'.`);
        }
        if (overwrite) {
            if (exists_ts_3.existsSync(dest)) {
                Deno.removeSync(dest, { recursive: true });
            }
            Deno.renameSync(src, dest);
        }
        else {
            if (exists_ts_3.existsSync(dest)) {
                throw new Error("dest already exists.");
            }
            Deno.renameSync(src, dest);
        }
    }
    exports_21("moveSync", moveSync);
    return {
        setters: [
            function (exists_ts_3_1) {
                exists_ts_3 = exists_ts_3_1;
            },
            function (_util_ts_7_1) {
                _util_ts_7 = _util_ts_7_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std/fs/copy", ["https://deno.land/std/path/mod", "https://deno.land/std/fs/ensure_dir", "https://deno.land/std/fs/_util", "https://deno.land/std/_util/assert"], function (exports_22, context_22) {
    "use strict";
    var path, ensure_dir_ts_4, _util_ts_8, assert_ts_5, isWindows;
    var __moduleName = context_22 && context_22.id;
    async function ensureValidCopy(src, dest, options, isCopyFolder = false) {
        let destStat;
        try {
            destStat = await Deno.lstat(dest);
        }
        catch (err) {
            if (err instanceof Deno.errors.NotFound) {
                return;
            }
            throw err;
        }
        if (isCopyFolder && !destStat.isDirectory) {
            throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
        }
        if (!options.overwrite) {
            throw new Error(`'${dest}' already exists.`);
        }
        return destStat;
    }
    function ensureValidCopySync(src, dest, options, isCopyFolder = false) {
        let destStat;
        try {
            destStat = Deno.lstatSync(dest);
        }
        catch (err) {
            if (err instanceof Deno.errors.NotFound) {
                return;
            }
            throw err;
        }
        if (isCopyFolder && !destStat.isDirectory) {
            throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
        }
        if (!options.overwrite) {
            throw new Error(`'${dest}' already exists.`);
        }
        return destStat;
    }
    /* copy file to dest */
    async function copyFile(src, dest, options) {
        await ensureValidCopy(src, dest, options);
        await Deno.copyFile(src, dest);
        if (options.preserveTimestamps) {
            const statInfo = await Deno.stat(src);
            assert_ts_5.assert(statInfo.atime instanceof Date, `statInfo.atime is unavailable`);
            assert_ts_5.assert(statInfo.mtime instanceof Date, `statInfo.mtime is unavailable`);
            await Deno.utime(dest, statInfo.atime, statInfo.mtime);
        }
    }
    /* copy file to dest synchronously */
    function copyFileSync(src, dest, options) {
        ensureValidCopySync(src, dest, options);
        Deno.copyFileSync(src, dest);
        if (options.preserveTimestamps) {
            const statInfo = Deno.statSync(src);
            assert_ts_5.assert(statInfo.atime instanceof Date, `statInfo.atime is unavailable`);
            assert_ts_5.assert(statInfo.mtime instanceof Date, `statInfo.mtime is unavailable`);
            Deno.utimeSync(dest, statInfo.atime, statInfo.mtime);
        }
    }
    /* copy symlink to dest */
    async function copySymLink(src, dest, options) {
        await ensureValidCopy(src, dest, options);
        const originSrcFilePath = await Deno.readLink(src);
        const type = _util_ts_8.getFileInfoType(await Deno.lstat(src));
        if (isWindows) {
            await Deno.symlink(originSrcFilePath, dest, {
                type: type === "dir" ? "dir" : "file",
            });
        }
        else {
            await Deno.symlink(originSrcFilePath, dest);
        }
        if (options.preserveTimestamps) {
            const statInfo = await Deno.lstat(src);
            assert_ts_5.assert(statInfo.atime instanceof Date, `statInfo.atime is unavailable`);
            assert_ts_5.assert(statInfo.mtime instanceof Date, `statInfo.mtime is unavailable`);
            await Deno.utime(dest, statInfo.atime, statInfo.mtime);
        }
    }
    /* copy symlink to dest synchronously */
    function copySymlinkSync(src, dest, options) {
        ensureValidCopySync(src, dest, options);
        const originSrcFilePath = Deno.readLinkSync(src);
        const type = _util_ts_8.getFileInfoType(Deno.lstatSync(src));
        if (isWindows) {
            Deno.symlinkSync(originSrcFilePath, dest, {
                type: type === "dir" ? "dir" : "file",
            });
        }
        else {
            Deno.symlinkSync(originSrcFilePath, dest);
        }
        if (options.preserveTimestamps) {
            const statInfo = Deno.lstatSync(src);
            assert_ts_5.assert(statInfo.atime instanceof Date, `statInfo.atime is unavailable`);
            assert_ts_5.assert(statInfo.mtime instanceof Date, `statInfo.mtime is unavailable`);
            Deno.utimeSync(dest, statInfo.atime, statInfo.mtime);
        }
    }
    /* copy folder from src to dest. */
    async function copyDir(src, dest, options) {
        const destStat = await ensureValidCopy(src, dest, options, true);
        if (!destStat) {
            await ensure_dir_ts_4.ensureDir(dest);
        }
        if (options.preserveTimestamps) {
            const srcStatInfo = await Deno.stat(src);
            assert_ts_5.assert(srcStatInfo.atime instanceof Date, `statInfo.atime is unavailable`);
            assert_ts_5.assert(srcStatInfo.mtime instanceof Date, `statInfo.mtime is unavailable`);
            await Deno.utime(dest, srcStatInfo.atime, srcStatInfo.mtime);
        }
        for await (const entry of Deno.readDir(src)) {
            const srcPath = path.join(src, entry.name);
            const destPath = path.join(dest, path.basename(srcPath));
            if (entry.isSymlink) {
                await copySymLink(srcPath, destPath, options);
            }
            else if (entry.isDirectory) {
                await copyDir(srcPath, destPath, options);
            }
            else if (entry.isFile) {
                await copyFile(srcPath, destPath, options);
            }
        }
    }
    /* copy folder from src to dest synchronously */
    function copyDirSync(src, dest, options) {
        const destStat = ensureValidCopySync(src, dest, options, true);
        if (!destStat) {
            ensure_dir_ts_4.ensureDirSync(dest);
        }
        if (options.preserveTimestamps) {
            const srcStatInfo = Deno.statSync(src);
            assert_ts_5.assert(srcStatInfo.atime instanceof Date, `statInfo.atime is unavailable`);
            assert_ts_5.assert(srcStatInfo.mtime instanceof Date, `statInfo.mtime is unavailable`);
            Deno.utimeSync(dest, srcStatInfo.atime, srcStatInfo.mtime);
        }
        for (const entry of Deno.readDirSync(src)) {
            assert_ts_5.assert(entry.name != null, "file.name must be set");
            const srcPath = path.join(src, entry.name);
            const destPath = path.join(dest, path.basename(srcPath));
            if (entry.isSymlink) {
                copySymlinkSync(srcPath, destPath, options);
            }
            else if (entry.isDirectory) {
                copyDirSync(srcPath, destPath, options);
            }
            else if (entry.isFile) {
                copyFileSync(srcPath, destPath, options);
            }
        }
    }
    /**
     * Copy a file or directory. The directory can have contents. Like `cp -r`.
     * Requires the `--allow-read` and `--allow-write` flag.
     * @param src the file/directory path.
     *            Note that if `src` is a directory it will copy everything inside
     *            of this directory, not the entire directory itself
     * @param dest the destination path. Note that if `src` is a file, `dest` cannot
     *             be a directory
     * @param options
     */
    async function copy(src, dest, options = {}) {
        src = path.resolve(src);
        dest = path.resolve(dest);
        if (src === dest) {
            throw new Error("Source and destination cannot be the same.");
        }
        const srcStat = await Deno.lstat(src);
        if (srcStat.isDirectory && _util_ts_8.isSubdir(src, dest)) {
            throw new Error(`Cannot copy '${src}' to a subdirectory of itself, '${dest}'.`);
        }
        if (srcStat.isSymlink) {
            await copySymLink(src, dest, options);
        }
        else if (srcStat.isDirectory) {
            await copyDir(src, dest, options);
        }
        else if (srcStat.isFile) {
            await copyFile(src, dest, options);
        }
    }
    exports_22("copy", copy);
    /**
     * Copy a file or directory. The directory can have contents. Like `cp -r`.
     * Requires the `--allow-read` and `--allow-write` flag.
     * @param src the file/directory path.
     *            Note that if `src` is a directory it will copy everything inside
     *            of this directory, not the entire directory itself
     * @param dest the destination path. Note that if `src` is a file, `dest` cannot
     *             be a directory
     * @param options
     */
    function copySync(src, dest, options = {}) {
        src = path.resolve(src);
        dest = path.resolve(dest);
        if (src === dest) {
            throw new Error("Source and destination cannot be the same.");
        }
        const srcStat = Deno.lstatSync(src);
        if (srcStat.isDirectory && _util_ts_8.isSubdir(src, dest)) {
            throw new Error(`Cannot copy '${src}' to a subdirectory of itself, '${dest}'.`);
        }
        if (srcStat.isSymlink) {
            copySymlinkSync(src, dest, options);
        }
        else if (srcStat.isDirectory) {
            copyDirSync(src, dest, options);
        }
        else if (srcStat.isFile) {
            copyFileSync(src, dest, options);
        }
    }
    exports_22("copySync", copySync);
    return {
        setters: [
            function (path_5) {
                path = path_5;
            },
            function (ensure_dir_ts_4_1) {
                ensure_dir_ts_4 = ensure_dir_ts_4_1;
            },
            function (_util_ts_8_1) {
                _util_ts_8 = _util_ts_8_1;
            },
            function (assert_ts_5_1) {
                assert_ts_5 = assert_ts_5_1;
            }
        ],
        execute: function () {
            isWindows = Deno.build.os === "windows";
        }
    };
});
// Copyright 2018-2020 the Deno authors. All rights reserved. MIT license.
System.register("https://deno.land/std/fs/read_file_str", [], function (exports_23, context_23) {
    "use strict";
    var __moduleName = context_23 && context_23.id;
    /**
     * Read file synchronously and output it as a string.
     *
     * @param filename File to read
     * @param opts Read options
     */
    function readFileStrSync(filename, opts = {}) {
        const decoder = new TextDecoder(opts.encoding);
        return decoder.decode(Deno.readFileSync(filename));
    }
    exports_23("readFileStrSync", readFileStrSync);
    /**
     * Read file and output it as a string.
     *
     * @param filename File to read
     * @param opts Read options
     */
    async function readFileStr(filename, opts = {}) {
        const decoder = new TextDecoder(opts.encoding);
        return decoder.decode(await Deno.readFile(filename));
    }
    exports_23("readFileStr", readFileStr);
    return {
        setters: [],
        execute: function () {
        }
    };
});
// Copyright 2018-2020 the Deno authors. All rights reserved. MIT license.
System.register("https://deno.land/std/fs/write_file_str", [], function (exports_24, context_24) {
    "use strict";
    var __moduleName = context_24 && context_24.id;
    /**
     * Write the string to file synchronously.
     *
     * @param filename File to write
     * @param content The content write to file
     * @returns void
     */
    function writeFileStrSync(filename, content) {
        const encoder = new TextEncoder();
        Deno.writeFileSync(filename, encoder.encode(content));
    }
    exports_24("writeFileStrSync", writeFileStrSync);
    /**
     * Write the string to file.
     *
     * @param filename File to write
     * @param content The content write to file
     * @returns Promise<void>
     */
    async function writeFileStr(filename, content) {
        const encoder = new TextEncoder();
        await Deno.writeFile(filename, encoder.encode(content));
    }
    exports_24("writeFileStr", writeFileStr);
    return {
        setters: [],
        execute: function () {
        }
    };
});
// Copyright 2018-2020 the Deno authors. All rights reserved. MIT license.
System.register("https://deno.land/std/fs/read_json", [], function (exports_25, context_25) {
    "use strict";
    var __moduleName = context_25 && context_25.id;
    /** Reads a JSON file and then parses it into an object */
    async function readJson(filePath) {
        const decoder = new TextDecoder("utf-8");
        const content = decoder.decode(await Deno.readFile(filePath));
        try {
            return JSON.parse(content);
        }
        catch (err) {
            err.message = `${filePath}: ${err.message}`;
            throw err;
        }
    }
    exports_25("readJson", readJson);
    /** Reads a JSON file and then parses it into an object */
    function readJsonSync(filePath) {
        const decoder = new TextDecoder("utf-8");
        const content = decoder.decode(Deno.readFileSync(filePath));
        try {
            return JSON.parse(content);
        }
        catch (err) {
            err.message = `${filePath}: ${err.message}`;
            throw err;
        }
    }
    exports_25("readJsonSync", readJsonSync);
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std/fs/write_json", [], function (exports_26, context_26) {
    "use strict";
    var __moduleName = context_26 && context_26.id;
    /* Writes an object to a JSON file. */
    async function writeJson(filePath, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    object, options = {}) {
        let contentRaw = "";
        try {
            contentRaw = JSON.stringify(object, options.replacer, options.spaces);
        }
        catch (err) {
            err.message = `${filePath}: ${err.message}`;
            throw err;
        }
        await Deno.writeFile(filePath, new TextEncoder().encode(contentRaw));
    }
    exports_26("writeJson", writeJson);
    /* Writes an object to a JSON file. */
    function writeJsonSync(filePath, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    object, options = {}) {
        let contentRaw = "";
        try {
            contentRaw = JSON.stringify(object, options.replacer, options.spaces);
        }
        catch (err) {
            err.message = `${filePath}: ${err.message}`;
            throw err;
        }
        Deno.writeFileSync(filePath, new TextEncoder().encode(contentRaw));
    }
    exports_26("writeJsonSync", writeJsonSync);
    return {
        setters: [],
        execute: function () {
        }
    };
});
// Copyright 2018-2020 the Deno authors. All rights reserved. MIT license.
System.register("https://deno.land/std/fs/eol", [], function (exports_27, context_27) {
    "use strict";
    var EOL, regDetect;
    var __moduleName = context_27 && context_27.id;
    /**
     * Detect the EOL character for string input.
     * returns null if no newline
     */
    function detect(content) {
        const d = content.match(regDetect);
        if (!d || d.length === 0) {
            return null;
        }
        const crlf = d.filter((x) => x === EOL.CRLF);
        if (crlf.length > 0) {
            return EOL.CRLF;
        }
        else {
            return EOL.LF;
        }
    }
    exports_27("detect", detect);
    /** Format the file to the targeted EOL */
    function format(content, eol) {
        return content.replace(regDetect, eol);
    }
    exports_27("format", format);
    return {
        setters: [],
        execute: function () {
            /** EndOfLine character enum */
            (function (EOL) {
                EOL["LF"] = "\n";
                EOL["CRLF"] = "\r\n";
            })(EOL || (EOL = {}));
            exports_27("EOL", EOL);
            regDetect = /(?:\r?\n)/g;
        }
    };
});
System.register("https://deno.land/std/fs/mod", ["https://deno.land/std/fs/empty_dir", "https://deno.land/std/fs/ensure_dir", "https://deno.land/std/fs/ensure_file", "https://deno.land/std/fs/ensure_link", "https://deno.land/std/fs/ensure_symlink", "https://deno.land/std/fs/exists", "https://deno.land/std/fs/expand_glob", "https://deno.land/std/fs/move", "https://deno.land/std/fs/copy", "https://deno.land/std/fs/read_file_str", "https://deno.land/std/fs/write_file_str", "https://deno.land/std/fs/read_json", "https://deno.land/std/fs/write_json", "https://deno.land/std/fs/walk", "https://deno.land/std/fs/eol"], function (exports_28, context_28) {
    "use strict";
    var __moduleName = context_28 && context_28.id;
    function exportStar_2(m) {
        var exports = {};
        for (var n in m) {
            if (n !== "default") exports[n] = m[n];
        }
        exports_28(exports);
    }
    return {
        setters: [
            function (empty_dir_ts_1_1) {
                exportStar_2(empty_dir_ts_1_1);
            },
            function (ensure_dir_ts_5_1) {
                exportStar_2(ensure_dir_ts_5_1);
            },
            function (ensure_file_ts_1_1) {
                exportStar_2(ensure_file_ts_1_1);
            },
            function (ensure_link_ts_1_1) {
                exportStar_2(ensure_link_ts_1_1);
            },
            function (ensure_symlink_ts_1_1) {
                exportStar_2(ensure_symlink_ts_1_1);
            },
            function (exists_ts_4_1) {
                exportStar_2(exists_ts_4_1);
            },
            function (expand_glob_ts_1_1) {
                exportStar_2(expand_glob_ts_1_1);
            },
            function (move_ts_1_1) {
                exportStar_2(move_ts_1_1);
            },
            function (copy_ts_1_1) {
                exportStar_2(copy_ts_1_1);
            },
            function (read_file_str_ts_1_1) {
                exportStar_2(read_file_str_ts_1_1);
            },
            function (write_file_str_ts_1_1) {
                exportStar_2(write_file_str_ts_1_1);
            },
            function (read_json_ts_1_1) {
                exportStar_2(read_json_ts_1_1);
            },
            function (write_json_ts_1_1) {
                exportStar_2(write_json_ts_1_1);
            },
            function (walk_ts_2_1) {
                exportStar_2(walk_ts_2_1);
            },
            function (eol_ts_1_1) {
                exportStar_2(eol_ts_1_1);
            }
        ],
        execute: function () {
        }
    };
});
// Copyright the Browserify authors. MIT License.
// Ported from https://github.com/browserify/path-browserify/
/** This module is browser compatible. */
System.register("https://deno.land/std@0.57.0/path/_constants", [], function (exports_29, context_29) {
    "use strict";
    var CHAR_UPPERCASE_A, CHAR_LOWERCASE_A, CHAR_UPPERCASE_Z, CHAR_LOWERCASE_Z, CHAR_DOT, CHAR_FORWARD_SLASH, CHAR_BACKWARD_SLASH, CHAR_VERTICAL_LINE, CHAR_COLON, CHAR_QUESTION_MARK, CHAR_UNDERSCORE, CHAR_LINE_FEED, CHAR_CARRIAGE_RETURN, CHAR_TAB, CHAR_FORM_FEED, CHAR_EXCLAMATION_MARK, CHAR_HASH, CHAR_SPACE, CHAR_NO_BREAK_SPACE, CHAR_ZERO_WIDTH_NOBREAK_SPACE, CHAR_LEFT_SQUARE_BRACKET, CHAR_RIGHT_SQUARE_BRACKET, CHAR_LEFT_ANGLE_BRACKET, CHAR_RIGHT_ANGLE_BRACKET, CHAR_LEFT_CURLY_BRACKET, CHAR_RIGHT_CURLY_BRACKET, CHAR_HYPHEN_MINUS, CHAR_PLUS, CHAR_DOUBLE_QUOTE, CHAR_SINGLE_QUOTE, CHAR_PERCENT, CHAR_SEMICOLON, CHAR_CIRCUMFLEX_ACCENT, CHAR_GRAVE_ACCENT, CHAR_AT, CHAR_AMPERSAND, CHAR_EQUAL, CHAR_0, CHAR_9, navigator, isWindows;
    var __moduleName = context_29 && context_29.id;
    return {
        setters: [],
        execute: function () {
            // Alphabet chars.
            exports_29("CHAR_UPPERCASE_A", CHAR_UPPERCASE_A = 65); /* A */
            exports_29("CHAR_LOWERCASE_A", CHAR_LOWERCASE_A = 97); /* a */
            exports_29("CHAR_UPPERCASE_Z", CHAR_UPPERCASE_Z = 90); /* Z */
            exports_29("CHAR_LOWERCASE_Z", CHAR_LOWERCASE_Z = 122); /* z */
            // Non-alphabetic chars.
            exports_29("CHAR_DOT", CHAR_DOT = 46); /* . */
            exports_29("CHAR_FORWARD_SLASH", CHAR_FORWARD_SLASH = 47); /* / */
            exports_29("CHAR_BACKWARD_SLASH", CHAR_BACKWARD_SLASH = 92); /* \ */
            exports_29("CHAR_VERTICAL_LINE", CHAR_VERTICAL_LINE = 124); /* | */
            exports_29("CHAR_COLON", CHAR_COLON = 58); /* : */
            exports_29("CHAR_QUESTION_MARK", CHAR_QUESTION_MARK = 63); /* ? */
            exports_29("CHAR_UNDERSCORE", CHAR_UNDERSCORE = 95); /* _ */
            exports_29("CHAR_LINE_FEED", CHAR_LINE_FEED = 10); /* \n */
            exports_29("CHAR_CARRIAGE_RETURN", CHAR_CARRIAGE_RETURN = 13); /* \r */
            exports_29("CHAR_TAB", CHAR_TAB = 9); /* \t */
            exports_29("CHAR_FORM_FEED", CHAR_FORM_FEED = 12); /* \f */
            exports_29("CHAR_EXCLAMATION_MARK", CHAR_EXCLAMATION_MARK = 33); /* ! */
            exports_29("CHAR_HASH", CHAR_HASH = 35); /* # */
            exports_29("CHAR_SPACE", CHAR_SPACE = 32); /*   */
            exports_29("CHAR_NO_BREAK_SPACE", CHAR_NO_BREAK_SPACE = 160); /* \u00A0 */
            exports_29("CHAR_ZERO_WIDTH_NOBREAK_SPACE", CHAR_ZERO_WIDTH_NOBREAK_SPACE = 65279); /* \uFEFF */
            exports_29("CHAR_LEFT_SQUARE_BRACKET", CHAR_LEFT_SQUARE_BRACKET = 91); /* [ */
            exports_29("CHAR_RIGHT_SQUARE_BRACKET", CHAR_RIGHT_SQUARE_BRACKET = 93); /* ] */
            exports_29("CHAR_LEFT_ANGLE_BRACKET", CHAR_LEFT_ANGLE_BRACKET = 60); /* < */
            exports_29("CHAR_RIGHT_ANGLE_BRACKET", CHAR_RIGHT_ANGLE_BRACKET = 62); /* > */
            exports_29("CHAR_LEFT_CURLY_BRACKET", CHAR_LEFT_CURLY_BRACKET = 123); /* { */
            exports_29("CHAR_RIGHT_CURLY_BRACKET", CHAR_RIGHT_CURLY_BRACKET = 125); /* } */
            exports_29("CHAR_HYPHEN_MINUS", CHAR_HYPHEN_MINUS = 45); /* - */
            exports_29("CHAR_PLUS", CHAR_PLUS = 43); /* + */
            exports_29("CHAR_DOUBLE_QUOTE", CHAR_DOUBLE_QUOTE = 34); /* " */
            exports_29("CHAR_SINGLE_QUOTE", CHAR_SINGLE_QUOTE = 39); /* ' */
            exports_29("CHAR_PERCENT", CHAR_PERCENT = 37); /* % */
            exports_29("CHAR_SEMICOLON", CHAR_SEMICOLON = 59); /* ; */
            exports_29("CHAR_CIRCUMFLEX_ACCENT", CHAR_CIRCUMFLEX_ACCENT = 94); /* ^ */
            exports_29("CHAR_GRAVE_ACCENT", CHAR_GRAVE_ACCENT = 96); /* ` */
            exports_29("CHAR_AT", CHAR_AT = 64); /* @ */
            exports_29("CHAR_AMPERSAND", CHAR_AMPERSAND = 38); /* & */
            exports_29("CHAR_EQUAL", CHAR_EQUAL = 61); /* = */
            // Digits
            exports_29("CHAR_0", CHAR_0 = 48); /* 0 */
            exports_29("CHAR_9", CHAR_9 = 57); /* 9 */
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            navigator = globalThis.navigator;
            isWindows = false;
            exports_29("isWindows", isWindows);
            if (globalThis.Deno != null) {
                exports_29("isWindows", isWindows = Deno.build.os == "windows");
            }
            else if (navigator?.appVersion != null) {
                exports_29("isWindows", isWindows = navigator.appVersion.includes("Win"));
            }
        }
    };
});
/** This module is browser compatible. */
System.register("https://deno.land/std@0.57.0/path/_interface", [], function (exports_30, context_30) {
    "use strict";
    var __moduleName = context_30 && context_30.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
// Copyright the Browserify authors. MIT License.
// Ported from https://github.com/browserify/path-browserify/
/** This module is browser compatible. */
System.register("https://deno.land/std@0.57.0/path/_util", ["https://deno.land/std@0.57.0/path/_constants"], function (exports_31, context_31) {
    "use strict";
    var _constants_ts_7;
    var __moduleName = context_31 && context_31.id;
    function assertPath(path) {
        if (typeof path !== "string") {
            throw new TypeError(`Path must be a string. Received ${JSON.stringify(path)}`);
        }
    }
    exports_31("assertPath", assertPath);
    function isPosixPathSeparator(code) {
        return code === _constants_ts_7.CHAR_FORWARD_SLASH;
    }
    exports_31("isPosixPathSeparator", isPosixPathSeparator);
    function isPathSeparator(code) {
        return isPosixPathSeparator(code) || code === _constants_ts_7.CHAR_BACKWARD_SLASH;
    }
    exports_31("isPathSeparator", isPathSeparator);
    function isWindowsDeviceRoot(code) {
        return ((code >= _constants_ts_7.CHAR_LOWERCASE_A && code <= _constants_ts_7.CHAR_LOWERCASE_Z) ||
            (code >= _constants_ts_7.CHAR_UPPERCASE_A && code <= _constants_ts_7.CHAR_UPPERCASE_Z));
    }
    exports_31("isWindowsDeviceRoot", isWindowsDeviceRoot);
    // Resolves . and .. elements in a path with directory names
    function normalizeString(path, allowAboveRoot, separator, isPathSeparator) {
        let res = "";
        let lastSegmentLength = 0;
        let lastSlash = -1;
        let dots = 0;
        let code;
        for (let i = 0, len = path.length; i <= len; ++i) {
            if (i < len)
                code = path.charCodeAt(i);
            else if (isPathSeparator(code))
                break;
            else
                code = _constants_ts_7.CHAR_FORWARD_SLASH;
            if (isPathSeparator(code)) {
                if (lastSlash === i - 1 || dots === 1) {
                    // NOOP
                }
                else if (lastSlash !== i - 1 && dots === 2) {
                    if (res.length < 2 ||
                        lastSegmentLength !== 2 ||
                        res.charCodeAt(res.length - 1) !== _constants_ts_7.CHAR_DOT ||
                        res.charCodeAt(res.length - 2) !== _constants_ts_7.CHAR_DOT) {
                        if (res.length > 2) {
                            const lastSlashIndex = res.lastIndexOf(separator);
                            if (lastSlashIndex === -1) {
                                res = "";
                                lastSegmentLength = 0;
                            }
                            else {
                                res = res.slice(0, lastSlashIndex);
                                lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
                            }
                            lastSlash = i;
                            dots = 0;
                            continue;
                        }
                        else if (res.length === 2 || res.length === 1) {
                            res = "";
                            lastSegmentLength = 0;
                            lastSlash = i;
                            dots = 0;
                            continue;
                        }
                    }
                    if (allowAboveRoot) {
                        if (res.length > 0)
                            res += `${separator}..`;
                        else
                            res = "..";
                        lastSegmentLength = 2;
                    }
                }
                else {
                    if (res.length > 0)
                        res += separator + path.slice(lastSlash + 1, i);
                    else
                        res = path.slice(lastSlash + 1, i);
                    lastSegmentLength = i - lastSlash - 1;
                }
                lastSlash = i;
                dots = 0;
            }
            else if (code === _constants_ts_7.CHAR_DOT && dots !== -1) {
                ++dots;
            }
            else {
                dots = -1;
            }
        }
        return res;
    }
    exports_31("normalizeString", normalizeString);
    function _format(sep, pathObject) {
        const dir = pathObject.dir || pathObject.root;
        const base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
        if (!dir)
            return base;
        if (dir === pathObject.root)
            return dir + base;
        return dir + sep + base;
    }
    exports_31("_format", _format);
    return {
        setters: [
            function (_constants_ts_7_1) {
                _constants_ts_7 = _constants_ts_7_1;
            }
        ],
        execute: function () {
        }
    };
});
// Copyright 2018-2020 the Deno authors. All rights reserved. MIT license.
System.register("https://deno.land/std@0.57.0/_util/assert", [], function (exports_32, context_32) {
    "use strict";
    var DenoStdInternalError;
    var __moduleName = context_32 && context_32.id;
    /** Make an assertion, if not `true`, then throw. */
    function assert(expr, msg = "") {
        if (!expr) {
            throw new DenoStdInternalError(msg);
        }
    }
    exports_32("assert", assert);
    return {
        setters: [],
        execute: function () {
            DenoStdInternalError = class DenoStdInternalError extends Error {
                constructor(message) {
                    super(message);
                    this.name = "DenoStdInternalError";
                }
            };
            exports_32("DenoStdInternalError", DenoStdInternalError);
        }
    };
});
// Copyright the Browserify authors. MIT License.
// Ported from https://github.com/browserify/path-browserify/
/** This module is browser compatible. */
System.register("https://deno.land/std@0.57.0/path/win32", ["https://deno.land/std@0.57.0/path/_constants", "https://deno.land/std@0.57.0/path/_util", "https://deno.land/std@0.57.0/_util/assert"], function (exports_33, context_33) {
    "use strict";
    var _constants_ts_8, _util_ts_9, assert_ts_6, sep, delimiter;
    var __moduleName = context_33 && context_33.id;
    function resolve(...pathSegments) {
        let resolvedDevice = "";
        let resolvedTail = "";
        let resolvedAbsolute = false;
        for (let i = pathSegments.length - 1; i >= -1; i--) {
            let path;
            if (i >= 0) {
                path = pathSegments[i];
            }
            else if (!resolvedDevice) {
                if (globalThis.Deno == null) {
                    throw new TypeError("Resolved a drive-letter-less path without a CWD.");
                }
                path = Deno.cwd();
            }
            else {
                if (globalThis.Deno == null) {
                    throw new TypeError("Resolved a relative path without a CWD.");
                }
                // Windows has the concept of drive-specific current working
                // directories. If we've resolved a drive letter but not yet an
                // absolute path, get cwd for that drive, or the process cwd if
                // the drive cwd is not available. We're sure the device is not
                // a UNC path at this points, because UNC paths are always absolute.
                path = Deno.env.get(`=${resolvedDevice}`) || Deno.cwd();
                // Verify that a cwd was found and that it actually points
                // to our drive. If not, default to the drive's root.
                if (path === undefined ||
                    path.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\`) {
                    path = `${resolvedDevice}\\`;
                }
            }
            _util_ts_9.assertPath(path);
            const len = path.length;
            // Skip empty entries
            if (len === 0)
                continue;
            let rootEnd = 0;
            let device = "";
            let isAbsolute = false;
            const code = path.charCodeAt(0);
            // Try to match a root
            if (len > 1) {
                if (_util_ts_9.isPathSeparator(code)) {
                    // Possible UNC root
                    // If we started with a separator, we know we at least have an
                    // absolute path of some kind (UNC or otherwise)
                    isAbsolute = true;
                    if (_util_ts_9.isPathSeparator(path.charCodeAt(1))) {
                        // Matched double path separator at beginning
                        let j = 2;
                        let last = j;
                        // Match 1 or more non-path separators
                        for (; j < len; ++j) {
                            if (_util_ts_9.isPathSeparator(path.charCodeAt(j)))
                                break;
                        }
                        if (j < len && j !== last) {
                            const firstPart = path.slice(last, j);
                            // Matched!
                            last = j;
                            // Match 1 or more path separators
                            for (; j < len; ++j) {
                                if (!_util_ts_9.isPathSeparator(path.charCodeAt(j)))
                                    break;
                            }
                            if (j < len && j !== last) {
                                // Matched!
                                last = j;
                                // Match 1 or more non-path separators
                                for (; j < len; ++j) {
                                    if (_util_ts_9.isPathSeparator(path.charCodeAt(j)))
                                        break;
                                }
                                if (j === len) {
                                    // We matched a UNC root only
                                    device = `\\\\${firstPart}\\${path.slice(last)}`;
                                    rootEnd = j;
                                }
                                else if (j !== last) {
                                    // We matched a UNC root with leftovers
                                    device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                                    rootEnd = j;
                                }
                            }
                        }
                    }
                    else {
                        rootEnd = 1;
                    }
                }
                else if (_util_ts_9.isWindowsDeviceRoot(code)) {
                    // Possible device root
                    if (path.charCodeAt(1) === _constants_ts_8.CHAR_COLON) {
                        device = path.slice(0, 2);
                        rootEnd = 2;
                        if (len > 2) {
                            if (_util_ts_9.isPathSeparator(path.charCodeAt(2))) {
                                // Treat separator following drive name as an absolute path
                                // indicator
                                isAbsolute = true;
                                rootEnd = 3;
                            }
                        }
                    }
                }
            }
            else if (_util_ts_9.isPathSeparator(code)) {
                // `path` contains just a path separator
                rootEnd = 1;
                isAbsolute = true;
            }
            if (device.length > 0 &&
                resolvedDevice.length > 0 &&
                device.toLowerCase() !== resolvedDevice.toLowerCase()) {
                // This path points to another device so it is not applicable
                continue;
            }
            if (resolvedDevice.length === 0 && device.length > 0) {
                resolvedDevice = device;
            }
            if (!resolvedAbsolute) {
                resolvedTail = `${path.slice(rootEnd)}\\${resolvedTail}`;
                resolvedAbsolute = isAbsolute;
            }
            if (resolvedAbsolute && resolvedDevice.length > 0)
                break;
        }
        // At this point the path should be resolved to a full absolute path,
        // but handle relative paths to be safe (might happen when process.cwd()
        // fails)
        // Normalize the tail path
        resolvedTail = _util_ts_9.normalizeString(resolvedTail, !resolvedAbsolute, "\\", _util_ts_9.isPathSeparator);
        return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
    }
    exports_33("resolve", resolve);
    function normalize(path) {
        _util_ts_9.assertPath(path);
        const len = path.length;
        if (len === 0)
            return ".";
        let rootEnd = 0;
        let device;
        let isAbsolute = false;
        const code = path.charCodeAt(0);
        // Try to match a root
        if (len > 1) {
            if (_util_ts_9.isPathSeparator(code)) {
                // Possible UNC root
                // If we started with a separator, we know we at least have an absolute
                // path of some kind (UNC or otherwise)
                isAbsolute = true;
                if (_util_ts_9.isPathSeparator(path.charCodeAt(1))) {
                    // Matched double path separator at beginning
                    let j = 2;
                    let last = j;
                    // Match 1 or more non-path separators
                    for (; j < len; ++j) {
                        if (_util_ts_9.isPathSeparator(path.charCodeAt(j)))
                            break;
                    }
                    if (j < len && j !== last) {
                        const firstPart = path.slice(last, j);
                        // Matched!
                        last = j;
                        // Match 1 or more path separators
                        for (; j < len; ++j) {
                            if (!_util_ts_9.isPathSeparator(path.charCodeAt(j)))
                                break;
                        }
                        if (j < len && j !== last) {
                            // Matched!
                            last = j;
                            // Match 1 or more non-path separators
                            for (; j < len; ++j) {
                                if (_util_ts_9.isPathSeparator(path.charCodeAt(j)))
                                    break;
                            }
                            if (j === len) {
                                // We matched a UNC root only
                                // Return the normalized version of the UNC root since there
                                // is nothing left to process
                                return `\\\\${firstPart}\\${path.slice(last)}\\`;
                            }
                            else if (j !== last) {
                                // We matched a UNC root with leftovers
                                device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                                rootEnd = j;
                            }
                        }
                    }
                }
                else {
                    rootEnd = 1;
                }
            }
            else if (_util_ts_9.isWindowsDeviceRoot(code)) {
                // Possible device root
                if (path.charCodeAt(1) === _constants_ts_8.CHAR_COLON) {
                    device = path.slice(0, 2);
                    rootEnd = 2;
                    if (len > 2) {
                        if (_util_ts_9.isPathSeparator(path.charCodeAt(2))) {
                            // Treat separator following drive name as an absolute path
                            // indicator
                            isAbsolute = true;
                            rootEnd = 3;
                        }
                    }
                }
            }
        }
        else if (_util_ts_9.isPathSeparator(code)) {
            // `path` contains just a path separator, exit early to avoid unnecessary
            // work
            return "\\";
        }
        let tail;
        if (rootEnd < len) {
            tail = _util_ts_9.normalizeString(path.slice(rootEnd), !isAbsolute, "\\", _util_ts_9.isPathSeparator);
        }
        else {
            tail = "";
        }
        if (tail.length === 0 && !isAbsolute)
            tail = ".";
        if (tail.length > 0 && _util_ts_9.isPathSeparator(path.charCodeAt(len - 1))) {
            tail += "\\";
        }
        if (device === undefined) {
            if (isAbsolute) {
                if (tail.length > 0)
                    return `\\${tail}`;
                else
                    return "\\";
            }
            else if (tail.length > 0) {
                return tail;
            }
            else {
                return "";
            }
        }
        else if (isAbsolute) {
            if (tail.length > 0)
                return `${device}\\${tail}`;
            else
                return `${device}\\`;
        }
        else if (tail.length > 0) {
            return device + tail;
        }
        else {
            return device;
        }
    }
    exports_33("normalize", normalize);
    function isAbsolute(path) {
        _util_ts_9.assertPath(path);
        const len = path.length;
        if (len === 0)
            return false;
        const code = path.charCodeAt(0);
        if (_util_ts_9.isPathSeparator(code)) {
            return true;
        }
        else if (_util_ts_9.isWindowsDeviceRoot(code)) {
            // Possible device root
            if (len > 2 && path.charCodeAt(1) === _constants_ts_8.CHAR_COLON) {
                if (_util_ts_9.isPathSeparator(path.charCodeAt(2)))
                    return true;
            }
        }
        return false;
    }
    exports_33("isAbsolute", isAbsolute);
    function join(...paths) {
        const pathsCount = paths.length;
        if (pathsCount === 0)
            return ".";
        let joined;
        let firstPart = null;
        for (let i = 0; i < pathsCount; ++i) {
            const path = paths[i];
            _util_ts_9.assertPath(path);
            if (path.length > 0) {
                if (joined === undefined)
                    joined = firstPart = path;
                else
                    joined += `\\${path}`;
            }
        }
        if (joined === undefined)
            return ".";
        // Make sure that the joined path doesn't start with two slashes, because
        // normalize() will mistake it for an UNC path then.
        //
        // This step is skipped when it is very clear that the user actually
        // intended to point at an UNC path. This is assumed when the first
        // non-empty string arguments starts with exactly two slashes followed by
        // at least one more non-slash character.
        //
        // Note that for normalize() to treat a path as an UNC path it needs to
        // have at least 2 components, so we don't filter for that here.
        // This means that the user can use join to construct UNC paths from
        // a server name and a share name; for example:
        //   path.join('//server', 'share') -> '\\\\server\\share\\')
        let needsReplace = true;
        let slashCount = 0;
        assert_ts_6.assert(firstPart != null);
        if (_util_ts_9.isPathSeparator(firstPart.charCodeAt(0))) {
            ++slashCount;
            const firstLen = firstPart.length;
            if (firstLen > 1) {
                if (_util_ts_9.isPathSeparator(firstPart.charCodeAt(1))) {
                    ++slashCount;
                    if (firstLen > 2) {
                        if (_util_ts_9.isPathSeparator(firstPart.charCodeAt(2)))
                            ++slashCount;
                        else {
                            // We matched a UNC path in the first part
                            needsReplace = false;
                        }
                    }
                }
            }
        }
        if (needsReplace) {
            // Find any more consecutive slashes we need to replace
            for (; slashCount < joined.length; ++slashCount) {
                if (!_util_ts_9.isPathSeparator(joined.charCodeAt(slashCount)))
                    break;
            }
            // Replace the slashes if needed
            if (slashCount >= 2)
                joined = `\\${joined.slice(slashCount)}`;
        }
        return normalize(joined);
    }
    exports_33("join", join);
    // It will solve the relative path from `from` to `to`, for instance:
    //  from = 'C:\\orandea\\test\\aaa'
    //  to = 'C:\\orandea\\impl\\bbb'
    // The output of the function should be: '..\\..\\impl\\bbb'
    function relative(from, to) {
        _util_ts_9.assertPath(from);
        _util_ts_9.assertPath(to);
        if (from === to)
            return "";
        const fromOrig = resolve(from);
        const toOrig = resolve(to);
        if (fromOrig === toOrig)
            return "";
        from = fromOrig.toLowerCase();
        to = toOrig.toLowerCase();
        if (from === to)
            return "";
        // Trim any leading backslashes
        let fromStart = 0;
        let fromEnd = from.length;
        for (; fromStart < fromEnd; ++fromStart) {
            if (from.charCodeAt(fromStart) !== _constants_ts_8.CHAR_BACKWARD_SLASH)
                break;
        }
        // Trim trailing backslashes (applicable to UNC paths only)
        for (; fromEnd - 1 > fromStart; --fromEnd) {
            if (from.charCodeAt(fromEnd - 1) !== _constants_ts_8.CHAR_BACKWARD_SLASH)
                break;
        }
        const fromLen = fromEnd - fromStart;
        // Trim any leading backslashes
        let toStart = 0;
        let toEnd = to.length;
        for (; toStart < toEnd; ++toStart) {
            if (to.charCodeAt(toStart) !== _constants_ts_8.CHAR_BACKWARD_SLASH)
                break;
        }
        // Trim trailing backslashes (applicable to UNC paths only)
        for (; toEnd - 1 > toStart; --toEnd) {
            if (to.charCodeAt(toEnd - 1) !== _constants_ts_8.CHAR_BACKWARD_SLASH)
                break;
        }
        const toLen = toEnd - toStart;
        // Compare paths to find the longest common path from root
        const length = fromLen < toLen ? fromLen : toLen;
        let lastCommonSep = -1;
        let i = 0;
        for (; i <= length; ++i) {
            if (i === length) {
                if (toLen > length) {
                    if (to.charCodeAt(toStart + i) === _constants_ts_8.CHAR_BACKWARD_SLASH) {
                        // We get here if `from` is the exact base path for `to`.
                        // For example: from='C:\\foo\\bar'; to='C:\\foo\\bar\\baz'
                        return toOrig.slice(toStart + i + 1);
                    }
                    else if (i === 2) {
                        // We get here if `from` is the device root.
                        // For example: from='C:\\'; to='C:\\foo'
                        return toOrig.slice(toStart + i);
                    }
                }
                if (fromLen > length) {
                    if (from.charCodeAt(fromStart + i) === _constants_ts_8.CHAR_BACKWARD_SLASH) {
                        // We get here if `to` is the exact base path for `from`.
                        // For example: from='C:\\foo\\bar'; to='C:\\foo'
                        lastCommonSep = i;
                    }
                    else if (i === 2) {
                        // We get here if `to` is the device root.
                        // For example: from='C:\\foo\\bar'; to='C:\\'
                        lastCommonSep = 3;
                    }
                }
                break;
            }
            const fromCode = from.charCodeAt(fromStart + i);
            const toCode = to.charCodeAt(toStart + i);
            if (fromCode !== toCode)
                break;
            else if (fromCode === _constants_ts_8.CHAR_BACKWARD_SLASH)
                lastCommonSep = i;
        }
        // We found a mismatch before the first common path separator was seen, so
        // return the original `to`.
        if (i !== length && lastCommonSep === -1) {
            return toOrig;
        }
        let out = "";
        if (lastCommonSep === -1)
            lastCommonSep = 0;
        // Generate the relative path based on the path difference between `to` and
        // `from`
        for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
            if (i === fromEnd || from.charCodeAt(i) === _constants_ts_8.CHAR_BACKWARD_SLASH) {
                if (out.length === 0)
                    out += "..";
                else
                    out += "\\..";
            }
        }
        // Lastly, append the rest of the destination (`to`) path that comes after
        // the common path parts
        if (out.length > 0) {
            return out + toOrig.slice(toStart + lastCommonSep, toEnd);
        }
        else {
            toStart += lastCommonSep;
            if (toOrig.charCodeAt(toStart) === _constants_ts_8.CHAR_BACKWARD_SLASH)
                ++toStart;
            return toOrig.slice(toStart, toEnd);
        }
    }
    exports_33("relative", relative);
    function toNamespacedPath(path) {
        // Note: this will *probably* throw somewhere.
        if (typeof path !== "string")
            return path;
        if (path.length === 0)
            return "";
        const resolvedPath = resolve(path);
        if (resolvedPath.length >= 3) {
            if (resolvedPath.charCodeAt(0) === _constants_ts_8.CHAR_BACKWARD_SLASH) {
                // Possible UNC root
                if (resolvedPath.charCodeAt(1) === _constants_ts_8.CHAR_BACKWARD_SLASH) {
                    const code = resolvedPath.charCodeAt(2);
                    if (code !== _constants_ts_8.CHAR_QUESTION_MARK && code !== _constants_ts_8.CHAR_DOT) {
                        // Matched non-long UNC root, convert the path to a long UNC path
                        return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
                    }
                }
            }
            else if (_util_ts_9.isWindowsDeviceRoot(resolvedPath.charCodeAt(0))) {
                // Possible device root
                if (resolvedPath.charCodeAt(1) === _constants_ts_8.CHAR_COLON &&
                    resolvedPath.charCodeAt(2) === _constants_ts_8.CHAR_BACKWARD_SLASH) {
                    // Matched device root, convert the path to a long UNC path
                    return `\\\\?\\${resolvedPath}`;
                }
            }
        }
        return path;
    }
    exports_33("toNamespacedPath", toNamespacedPath);
    function dirname(path) {
        _util_ts_9.assertPath(path);
        const len = path.length;
        if (len === 0)
            return ".";
        let rootEnd = -1;
        let end = -1;
        let matchedSlash = true;
        let offset = 0;
        const code = path.charCodeAt(0);
        // Try to match a root
        if (len > 1) {
            if (_util_ts_9.isPathSeparator(code)) {
                // Possible UNC root
                rootEnd = offset = 1;
                if (_util_ts_9.isPathSeparator(path.charCodeAt(1))) {
                    // Matched double path separator at beginning
                    let j = 2;
                    let last = j;
                    // Match 1 or more non-path separators
                    for (; j < len; ++j) {
                        if (_util_ts_9.isPathSeparator(path.charCodeAt(j)))
                            break;
                    }
                    if (j < len && j !== last) {
                        // Matched!
                        last = j;
                        // Match 1 or more path separators
                        for (; j < len; ++j) {
                            if (!_util_ts_9.isPathSeparator(path.charCodeAt(j)))
                                break;
                        }
                        if (j < len && j !== last) {
                            // Matched!
                            last = j;
                            // Match 1 or more non-path separators
                            for (; j < len; ++j) {
                                if (_util_ts_9.isPathSeparator(path.charCodeAt(j)))
                                    break;
                            }
                            if (j === len) {
                                // We matched a UNC root only
                                return path;
                            }
                            if (j !== last) {
                                // We matched a UNC root with leftovers
                                // Offset by 1 to include the separator after the UNC root to
                                // treat it as a "normal root" on top of a (UNC) root
                                rootEnd = offset = j + 1;
                            }
                        }
                    }
                }
            }
            else if (_util_ts_9.isWindowsDeviceRoot(code)) {
                // Possible device root
                if (path.charCodeAt(1) === _constants_ts_8.CHAR_COLON) {
                    rootEnd = offset = 2;
                    if (len > 2) {
                        if (_util_ts_9.isPathSeparator(path.charCodeAt(2)))
                            rootEnd = offset = 3;
                    }
                }
            }
        }
        else if (_util_ts_9.isPathSeparator(code)) {
            // `path` contains just a path separator, exit early to avoid
            // unnecessary work
            return path;
        }
        for (let i = len - 1; i >= offset; --i) {
            if (_util_ts_9.isPathSeparator(path.charCodeAt(i))) {
                if (!matchedSlash) {
                    end = i;
                    break;
                }
            }
            else {
                // We saw the first non-path separator
                matchedSlash = false;
            }
        }
        if (end === -1) {
            if (rootEnd === -1)
                return ".";
            else
                end = rootEnd;
        }
        return path.slice(0, end);
    }
    exports_33("dirname", dirname);
    function basename(path, ext = "") {
        if (ext !== undefined && typeof ext !== "string") {
            throw new TypeError('"ext" argument must be a string');
        }
        _util_ts_9.assertPath(path);
        let start = 0;
        let end = -1;
        let matchedSlash = true;
        let i;
        // Check for a drive letter prefix so as not to mistake the following
        // path separator as an extra separator at the end of the path that can be
        // disregarded
        if (path.length >= 2) {
            const drive = path.charCodeAt(0);
            if (_util_ts_9.isWindowsDeviceRoot(drive)) {
                if (path.charCodeAt(1) === _constants_ts_8.CHAR_COLON)
                    start = 2;
            }
        }
        if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
            if (ext.length === path.length && ext === path)
                return "";
            let extIdx = ext.length - 1;
            let firstNonSlashEnd = -1;
            for (i = path.length - 1; i >= start; --i) {
                const code = path.charCodeAt(i);
                if (_util_ts_9.isPathSeparator(code)) {
                    // If we reached a path separator that was not part of a set of path
                    // separators at the end of the string, stop now
                    if (!matchedSlash) {
                        start = i + 1;
                        break;
                    }
                }
                else {
                    if (firstNonSlashEnd === -1) {
                        // We saw the first non-path separator, remember this index in case
                        // we need it if the extension ends up not matching
                        matchedSlash = false;
                        firstNonSlashEnd = i + 1;
                    }
                    if (extIdx >= 0) {
                        // Try to match the explicit extension
                        if (code === ext.charCodeAt(extIdx)) {
                            if (--extIdx === -1) {
                                // We matched the extension, so mark this as the end of our path
                                // component
                                end = i;
                            }
                        }
                        else {
                            // Extension does not match, so our result is the entire path
                            // component
                            extIdx = -1;
                            end = firstNonSlashEnd;
                        }
                    }
                }
            }
            if (start === end)
                end = firstNonSlashEnd;
            else if (end === -1)
                end = path.length;
            return path.slice(start, end);
        }
        else {
            for (i = path.length - 1; i >= start; --i) {
                if (_util_ts_9.isPathSeparator(path.charCodeAt(i))) {
                    // If we reached a path separator that was not part of a set of path
                    // separators at the end of the string, stop now
                    if (!matchedSlash) {
                        start = i + 1;
                        break;
                    }
                }
                else if (end === -1) {
                    // We saw the first non-path separator, mark this as the end of our
                    // path component
                    matchedSlash = false;
                    end = i + 1;
                }
            }
            if (end === -1)
                return "";
            return path.slice(start, end);
        }
    }
    exports_33("basename", basename);
    function extname(path) {
        _util_ts_9.assertPath(path);
        let start = 0;
        let startDot = -1;
        let startPart = 0;
        let end = -1;
        let matchedSlash = true;
        // Track the state of characters (if any) we see before our first dot and
        // after any path separator we find
        let preDotState = 0;
        // Check for a drive letter prefix so as not to mistake the following
        // path separator as an extra separator at the end of the path that can be
        // disregarded
        if (path.length >= 2 &&
            path.charCodeAt(1) === _constants_ts_8.CHAR_COLON &&
            _util_ts_9.isWindowsDeviceRoot(path.charCodeAt(0))) {
            start = startPart = 2;
        }
        for (let i = path.length - 1; i >= start; --i) {
            const code = path.charCodeAt(i);
            if (_util_ts_9.isPathSeparator(code)) {
                // If we reached a path separator that was not part of a set of path
                // separators at the end of the string, stop now
                if (!matchedSlash) {
                    startPart = i + 1;
                    break;
                }
                continue;
            }
            if (end === -1) {
                // We saw the first non-path separator, mark this as the end of our
                // extension
                matchedSlash = false;
                end = i + 1;
            }
            if (code === _constants_ts_8.CHAR_DOT) {
                // If this is our first dot, mark it as the start of our extension
                if (startDot === -1)
                    startDot = i;
                else if (preDotState !== 1)
                    preDotState = 1;
            }
            else if (startDot !== -1) {
                // We saw a non-dot and non-path separator before our dot, so we should
                // have a good chance at having a non-empty extension
                preDotState = -1;
            }
        }
        if (startDot === -1 ||
            end === -1 ||
            // We saw a non-dot character immediately before the dot
            preDotState === 0 ||
            // The (right-most) trimmed path component is exactly '..'
            (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)) {
            return "";
        }
        return path.slice(startDot, end);
    }
    exports_33("extname", extname);
    function format(pathObject) {
        /* eslint-disable max-len */
        if (pathObject === null || typeof pathObject !== "object") {
            throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
        }
        return _util_ts_9._format("\\", pathObject);
    }
    exports_33("format", format);
    function parse(path) {
        _util_ts_9.assertPath(path);
        const ret = { root: "", dir: "", base: "", ext: "", name: "" };
        const len = path.length;
        if (len === 0)
            return ret;
        let rootEnd = 0;
        let code = path.charCodeAt(0);
        // Try to match a root
        if (len > 1) {
            if (_util_ts_9.isPathSeparator(code)) {
                // Possible UNC root
                rootEnd = 1;
                if (_util_ts_9.isPathSeparator(path.charCodeAt(1))) {
                    // Matched double path separator at beginning
                    let j = 2;
                    let last = j;
                    // Match 1 or more non-path separators
                    for (; j < len; ++j) {
                        if (_util_ts_9.isPathSeparator(path.charCodeAt(j)))
                            break;
                    }
                    if (j < len && j !== last) {
                        // Matched!
                        last = j;
                        // Match 1 or more path separators
                        for (; j < len; ++j) {
                            if (!_util_ts_9.isPathSeparator(path.charCodeAt(j)))
                                break;
                        }
                        if (j < len && j !== last) {
                            // Matched!
                            last = j;
                            // Match 1 or more non-path separators
                            for (; j < len; ++j) {
                                if (_util_ts_9.isPathSeparator(path.charCodeAt(j)))
                                    break;
                            }
                            if (j === len) {
                                // We matched a UNC root only
                                rootEnd = j;
                            }
                            else if (j !== last) {
                                // We matched a UNC root with leftovers
                                rootEnd = j + 1;
                            }
                        }
                    }
                }
            }
            else if (_util_ts_9.isWindowsDeviceRoot(code)) {
                // Possible device root
                if (path.charCodeAt(1) === _constants_ts_8.CHAR_COLON) {
                    rootEnd = 2;
                    if (len > 2) {
                        if (_util_ts_9.isPathSeparator(path.charCodeAt(2))) {
                            if (len === 3) {
                                // `path` contains just a drive root, exit early to avoid
                                // unnecessary work
                                ret.root = ret.dir = path;
                                return ret;
                            }
                            rootEnd = 3;
                        }
                    }
                    else {
                        // `path` contains just a drive root, exit early to avoid
                        // unnecessary work
                        ret.root = ret.dir = path;
                        return ret;
                    }
                }
            }
        }
        else if (_util_ts_9.isPathSeparator(code)) {
            // `path` contains just a path separator, exit early to avoid
            // unnecessary work
            ret.root = ret.dir = path;
            return ret;
        }
        if (rootEnd > 0)
            ret.root = path.slice(0, rootEnd);
        let startDot = -1;
        let startPart = rootEnd;
        let end = -1;
        let matchedSlash = true;
        let i = path.length - 1;
        // Track the state of characters (if any) we see before our first dot and
        // after any path separator we find
        let preDotState = 0;
        // Get non-dir info
        for (; i >= rootEnd; --i) {
            code = path.charCodeAt(i);
            if (_util_ts_9.isPathSeparator(code)) {
                // If we reached a path separator that was not part of a set of path
                // separators at the end of the string, stop now
                if (!matchedSlash) {
                    startPart = i + 1;
                    break;
                }
                continue;
            }
            if (end === -1) {
                // We saw the first non-path separator, mark this as the end of our
                // extension
                matchedSlash = false;
                end = i + 1;
            }
            if (code === _constants_ts_8.CHAR_DOT) {
                // If this is our first dot, mark it as the start of our extension
                if (startDot === -1)
                    startDot = i;
                else if (preDotState !== 1)
                    preDotState = 1;
            }
            else if (startDot !== -1) {
                // We saw a non-dot and non-path separator before our dot, so we should
                // have a good chance at having a non-empty extension
                preDotState = -1;
            }
        }
        if (startDot === -1 ||
            end === -1 ||
            // We saw a non-dot character immediately before the dot
            preDotState === 0 ||
            // The (right-most) trimmed path component is exactly '..'
            (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)) {
            if (end !== -1) {
                ret.base = ret.name = path.slice(startPart, end);
            }
        }
        else {
            ret.name = path.slice(startPart, startDot);
            ret.base = path.slice(startPart, end);
            ret.ext = path.slice(startDot, end);
        }
        // If the directory is the root, use the entire root as the `dir` including
        // the trailing slash if any (`C:\abc` -> `C:\`). Otherwise, strip out the
        // trailing slash (`C:\abc\def` -> `C:\abc`).
        if (startPart > 0 && startPart !== rootEnd) {
            ret.dir = path.slice(0, startPart - 1);
        }
        else
            ret.dir = ret.root;
        return ret;
    }
    exports_33("parse", parse);
    /** Converts a file URL to a path string.
     *
     *      fromFileUrl("file:///C:/Users/foo"); // "C:\\Users\\foo"
     *      fromFileUrl("file:///home/foo"); // "\\home\\foo"
     *
     * Note that non-file URLs are treated as file URLs and irrelevant components
     * are ignored.
     */
    function fromFileUrl(url) {
        return new URL(url).pathname
            .replace(/^\/*([A-Za-z]:)(\/|$)/, "$1/")
            .replace(/\//g, "\\");
    }
    exports_33("fromFileUrl", fromFileUrl);
    return {
        setters: [
            function (_constants_ts_8_1) {
                _constants_ts_8 = _constants_ts_8_1;
            },
            function (_util_ts_9_1) {
                _util_ts_9 = _util_ts_9_1;
            },
            function (assert_ts_6_1) {
                assert_ts_6 = assert_ts_6_1;
            }
        ],
        execute: function () {
            exports_33("sep", sep = "\\");
            exports_33("delimiter", delimiter = ";");
        }
    };
});
// Copyright the Browserify authors. MIT License.
// Ported from https://github.com/browserify/path-browserify/
/** This module is browser compatible. */
System.register("https://deno.land/std@0.57.0/path/posix", ["https://deno.land/std@0.57.0/path/_constants", "https://deno.land/std@0.57.0/path/_util"], function (exports_34, context_34) {
    "use strict";
    var _constants_ts_9, _util_ts_10, sep, delimiter;
    var __moduleName = context_34 && context_34.id;
    // path.resolve([from ...], to)
    function resolve(...pathSegments) {
        let resolvedPath = "";
        let resolvedAbsolute = false;
        for (let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
            let path;
            if (i >= 0)
                path = pathSegments[i];
            else {
                if (globalThis.Deno == null) {
                    throw new TypeError("Resolved a relative path without a CWD.");
                }
                path = Deno.cwd();
            }
            _util_ts_10.assertPath(path);
            // Skip empty entries
            if (path.length === 0) {
                continue;
            }
            resolvedPath = `${path}/${resolvedPath}`;
            resolvedAbsolute = path.charCodeAt(0) === _constants_ts_9.CHAR_FORWARD_SLASH;
        }
        // At this point the path should be resolved to a full absolute path, but
        // handle relative paths to be safe (might happen when process.cwd() fails)
        // Normalize the path
        resolvedPath = _util_ts_10.normalizeString(resolvedPath, !resolvedAbsolute, "/", _util_ts_10.isPosixPathSeparator);
        if (resolvedAbsolute) {
            if (resolvedPath.length > 0)
                return `/${resolvedPath}`;
            else
                return "/";
        }
        else if (resolvedPath.length > 0)
            return resolvedPath;
        else
            return ".";
    }
    exports_34("resolve", resolve);
    function normalize(path) {
        _util_ts_10.assertPath(path);
        if (path.length === 0)
            return ".";
        const isAbsolute = path.charCodeAt(0) === _constants_ts_9.CHAR_FORWARD_SLASH;
        const trailingSeparator = path.charCodeAt(path.length - 1) === _constants_ts_9.CHAR_FORWARD_SLASH;
        // Normalize the path
        path = _util_ts_10.normalizeString(path, !isAbsolute, "/", _util_ts_10.isPosixPathSeparator);
        if (path.length === 0 && !isAbsolute)
            path = ".";
        if (path.length > 0 && trailingSeparator)
            path += "/";
        if (isAbsolute)
            return `/${path}`;
        return path;
    }
    exports_34("normalize", normalize);
    function isAbsolute(path) {
        _util_ts_10.assertPath(path);
        return path.length > 0 && path.charCodeAt(0) === _constants_ts_9.CHAR_FORWARD_SLASH;
    }
    exports_34("isAbsolute", isAbsolute);
    function join(...paths) {
        if (paths.length === 0)
            return ".";
        let joined;
        for (let i = 0, len = paths.length; i < len; ++i) {
            const path = paths[i];
            _util_ts_10.assertPath(path);
            if (path.length > 0) {
                if (!joined)
                    joined = path;
                else
                    joined += `/${path}`;
            }
        }
        if (!joined)
            return ".";
        return normalize(joined);
    }
    exports_34("join", join);
    function relative(from, to) {
        _util_ts_10.assertPath(from);
        _util_ts_10.assertPath(to);
        if (from === to)
            return "";
        from = resolve(from);
        to = resolve(to);
        if (from === to)
            return "";
        // Trim any leading backslashes
        let fromStart = 1;
        const fromEnd = from.length;
        for (; fromStart < fromEnd; ++fromStart) {
            if (from.charCodeAt(fromStart) !== _constants_ts_9.CHAR_FORWARD_SLASH)
                break;
        }
        const fromLen = fromEnd - fromStart;
        // Trim any leading backslashes
        let toStart = 1;
        const toEnd = to.length;
        for (; toStart < toEnd; ++toStart) {
            if (to.charCodeAt(toStart) !== _constants_ts_9.CHAR_FORWARD_SLASH)
                break;
        }
        const toLen = toEnd - toStart;
        // Compare paths to find the longest common path from root
        const length = fromLen < toLen ? fromLen : toLen;
        let lastCommonSep = -1;
        let i = 0;
        for (; i <= length; ++i) {
            if (i === length) {
                if (toLen > length) {
                    if (to.charCodeAt(toStart + i) === _constants_ts_9.CHAR_FORWARD_SLASH) {
                        // We get here if `from` is the exact base path for `to`.
                        // For example: from='/foo/bar'; to='/foo/bar/baz'
                        return to.slice(toStart + i + 1);
                    }
                    else if (i === 0) {
                        // We get here if `from` is the root
                        // For example: from='/'; to='/foo'
                        return to.slice(toStart + i);
                    }
                }
                else if (fromLen > length) {
                    if (from.charCodeAt(fromStart + i) === _constants_ts_9.CHAR_FORWARD_SLASH) {
                        // We get here if `to` is the exact base path for `from`.
                        // For example: from='/foo/bar/baz'; to='/foo/bar'
                        lastCommonSep = i;
                    }
                    else if (i === 0) {
                        // We get here if `to` is the root.
                        // For example: from='/foo'; to='/'
                        lastCommonSep = 0;
                    }
                }
                break;
            }
            const fromCode = from.charCodeAt(fromStart + i);
            const toCode = to.charCodeAt(toStart + i);
            if (fromCode !== toCode)
                break;
            else if (fromCode === _constants_ts_9.CHAR_FORWARD_SLASH)
                lastCommonSep = i;
        }
        let out = "";
        // Generate the relative path based on the path difference between `to`
        // and `from`
        for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
            if (i === fromEnd || from.charCodeAt(i) === _constants_ts_9.CHAR_FORWARD_SLASH) {
                if (out.length === 0)
                    out += "..";
                else
                    out += "/..";
            }
        }
        // Lastly, append the rest of the destination (`to`) path that comes after
        // the common path parts
        if (out.length > 0)
            return out + to.slice(toStart + lastCommonSep);
        else {
            toStart += lastCommonSep;
            if (to.charCodeAt(toStart) === _constants_ts_9.CHAR_FORWARD_SLASH)
                ++toStart;
            return to.slice(toStart);
        }
    }
    exports_34("relative", relative);
    function toNamespacedPath(path) {
        // Non-op on posix systems
        return path;
    }
    exports_34("toNamespacedPath", toNamespacedPath);
    function dirname(path) {
        _util_ts_10.assertPath(path);
        if (path.length === 0)
            return ".";
        const hasRoot = path.charCodeAt(0) === _constants_ts_9.CHAR_FORWARD_SLASH;
        let end = -1;
        let matchedSlash = true;
        for (let i = path.length - 1; i >= 1; --i) {
            if (path.charCodeAt(i) === _constants_ts_9.CHAR_FORWARD_SLASH) {
                if (!matchedSlash) {
                    end = i;
                    break;
                }
            }
            else {
                // We saw the first non-path separator
                matchedSlash = false;
            }
        }
        if (end === -1)
            return hasRoot ? "/" : ".";
        if (hasRoot && end === 1)
            return "//";
        return path.slice(0, end);
    }
    exports_34("dirname", dirname);
    function basename(path, ext = "") {
        if (ext !== undefined && typeof ext !== "string") {
            throw new TypeError('"ext" argument must be a string');
        }
        _util_ts_10.assertPath(path);
        let start = 0;
        let end = -1;
        let matchedSlash = true;
        let i;
        if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
            if (ext.length === path.length && ext === path)
                return "";
            let extIdx = ext.length - 1;
            let firstNonSlashEnd = -1;
            for (i = path.length - 1; i >= 0; --i) {
                const code = path.charCodeAt(i);
                if (code === _constants_ts_9.CHAR_FORWARD_SLASH) {
                    // If we reached a path separator that was not part of a set of path
                    // separators at the end of the string, stop now
                    if (!matchedSlash) {
                        start = i + 1;
                        break;
                    }
                }
                else {
                    if (firstNonSlashEnd === -1) {
                        // We saw the first non-path separator, remember this index in case
                        // we need it if the extension ends up not matching
                        matchedSlash = false;
                        firstNonSlashEnd = i + 1;
                    }
                    if (extIdx >= 0) {
                        // Try to match the explicit extension
                        if (code === ext.charCodeAt(extIdx)) {
                            if (--extIdx === -1) {
                                // We matched the extension, so mark this as the end of our path
                                // component
                                end = i;
                            }
                        }
                        else {
                            // Extension does not match, so our result is the entire path
                            // component
                            extIdx = -1;
                            end = firstNonSlashEnd;
                        }
                    }
                }
            }
            if (start === end)
                end = firstNonSlashEnd;
            else if (end === -1)
                end = path.length;
            return path.slice(start, end);
        }
        else {
            for (i = path.length - 1; i >= 0; --i) {
                if (path.charCodeAt(i) === _constants_ts_9.CHAR_FORWARD_SLASH) {
                    // If we reached a path separator that was not part of a set of path
                    // separators at the end of the string, stop now
                    if (!matchedSlash) {
                        start = i + 1;
                        break;
                    }
                }
                else if (end === -1) {
                    // We saw the first non-path separator, mark this as the end of our
                    // path component
                    matchedSlash = false;
                    end = i + 1;
                }
            }
            if (end === -1)
                return "";
            return path.slice(start, end);
        }
    }
    exports_34("basename", basename);
    function extname(path) {
        _util_ts_10.assertPath(path);
        let startDot = -1;
        let startPart = 0;
        let end = -1;
        let matchedSlash = true;
        // Track the state of characters (if any) we see before our first dot and
        // after any path separator we find
        let preDotState = 0;
        for (let i = path.length - 1; i >= 0; --i) {
            const code = path.charCodeAt(i);
            if (code === _constants_ts_9.CHAR_FORWARD_SLASH) {
                // If we reached a path separator that was not part of a set of path
                // separators at the end of the string, stop now
                if (!matchedSlash) {
                    startPart = i + 1;
                    break;
                }
                continue;
            }
            if (end === -1) {
                // We saw the first non-path separator, mark this as the end of our
                // extension
                matchedSlash = false;
                end = i + 1;
            }
            if (code === _constants_ts_9.CHAR_DOT) {
                // If this is our first dot, mark it as the start of our extension
                if (startDot === -1)
                    startDot = i;
                else if (preDotState !== 1)
                    preDotState = 1;
            }
            else if (startDot !== -1) {
                // We saw a non-dot and non-path separator before our dot, so we should
                // have a good chance at having a non-empty extension
                preDotState = -1;
            }
        }
        if (startDot === -1 ||
            end === -1 ||
            // We saw a non-dot character immediately before the dot
            preDotState === 0 ||
            // The (right-most) trimmed path component is exactly '..'
            (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)) {
            return "";
        }
        return path.slice(startDot, end);
    }
    exports_34("extname", extname);
    function format(pathObject) {
        /* eslint-disable max-len */
        if (pathObject === null || typeof pathObject !== "object") {
            throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
        }
        return _util_ts_10._format("/", pathObject);
    }
    exports_34("format", format);
    function parse(path) {
        _util_ts_10.assertPath(path);
        const ret = { root: "", dir: "", base: "", ext: "", name: "" };
        if (path.length === 0)
            return ret;
        const isAbsolute = path.charCodeAt(0) === _constants_ts_9.CHAR_FORWARD_SLASH;
        let start;
        if (isAbsolute) {
            ret.root = "/";
            start = 1;
        }
        else {
            start = 0;
        }
        let startDot = -1;
        let startPart = 0;
        let end = -1;
        let matchedSlash = true;
        let i = path.length - 1;
        // Track the state of characters (if any) we see before our first dot and
        // after any path separator we find
        let preDotState = 0;
        // Get non-dir info
        for (; i >= start; --i) {
            const code = path.charCodeAt(i);
            if (code === _constants_ts_9.CHAR_FORWARD_SLASH) {
                // If we reached a path separator that was not part of a set of path
                // separators at the end of the string, stop now
                if (!matchedSlash) {
                    startPart = i + 1;
                    break;
                }
                continue;
            }
            if (end === -1) {
                // We saw the first non-path separator, mark this as the end of our
                // extension
                matchedSlash = false;
                end = i + 1;
            }
            if (code === _constants_ts_9.CHAR_DOT) {
                // If this is our first dot, mark it as the start of our extension
                if (startDot === -1)
                    startDot = i;
                else if (preDotState !== 1)
                    preDotState = 1;
            }
            else if (startDot !== -1) {
                // We saw a non-dot and non-path separator before our dot, so we should
                // have a good chance at having a non-empty extension
                preDotState = -1;
            }
        }
        if (startDot === -1 ||
            end === -1 ||
            // We saw a non-dot character immediately before the dot
            preDotState === 0 ||
            // The (right-most) trimmed path component is exactly '..'
            (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)) {
            if (end !== -1) {
                if (startPart === 0 && isAbsolute) {
                    ret.base = ret.name = path.slice(1, end);
                }
                else {
                    ret.base = ret.name = path.slice(startPart, end);
                }
            }
        }
        else {
            if (startPart === 0 && isAbsolute) {
                ret.name = path.slice(1, startDot);
                ret.base = path.slice(1, end);
            }
            else {
                ret.name = path.slice(startPart, startDot);
                ret.base = path.slice(startPart, end);
            }
            ret.ext = path.slice(startDot, end);
        }
        if (startPart > 0)
            ret.dir = path.slice(0, startPart - 1);
        else if (isAbsolute)
            ret.dir = "/";
        return ret;
    }
    exports_34("parse", parse);
    /** Converts a file URL to a path string.
     *
     *      fromFileUrl("file:///home/foo"); // "/home/foo"
     *
     * Note that non-file URLs are treated as file URLs and irrelevant components
     * are ignored.
     */
    function fromFileUrl(url) {
        return new URL(url).pathname;
    }
    exports_34("fromFileUrl", fromFileUrl);
    return {
        setters: [
            function (_constants_ts_9_1) {
                _constants_ts_9 = _constants_ts_9_1;
            },
            function (_util_ts_10_1) {
                _util_ts_10 = _util_ts_10_1;
            }
        ],
        execute: function () {
            exports_34("sep", sep = "/");
            exports_34("delimiter", delimiter = ":");
        }
    };
});
// Copyright 2018-2020 the Deno authors. All rights reserved. MIT license.
/** This module is browser compatible. */
System.register("https://deno.land/std@0.57.0/path/separator", ["https://deno.land/std@0.57.0/path/_constants"], function (exports_35, context_35) {
    "use strict";
    var _constants_ts_10, SEP, SEP_PATTERN;
    var __moduleName = context_35 && context_35.id;
    return {
        setters: [
            function (_constants_ts_10_1) {
                _constants_ts_10 = _constants_ts_10_1;
            }
        ],
        execute: function () {
            exports_35("SEP", SEP = _constants_ts_10.isWindows ? "\\" : "/");
            exports_35("SEP_PATTERN", SEP_PATTERN = _constants_ts_10.isWindows ? /[\\/]+/ : /\/+/);
        }
    };
});
// Copyright 2018-2020 the Deno authors. All rights reserved. MIT license.
/** This module is browser compatible. */
System.register("https://deno.land/std@0.57.0/path/common", ["https://deno.land/std@0.57.0/path/separator"], function (exports_36, context_36) {
    "use strict";
    var separator_ts_4;
    var __moduleName = context_36 && context_36.id;
    /** Determines the common path from a set of paths, using an optional separator,
     * which defaults to the OS default separator.
     *
     *       import { common } from "https://deno.land/std/path/mod.ts";
     *       const p = common([
     *         "./deno/std/path/mod.ts",
     *         "./deno/std/fs/mod.ts",
     *       ]);
     *       console.log(p); // "./deno/std/"
     *
     */
    function common(paths, sep = separator_ts_4.SEP) {
        const [first = "", ...remaining] = paths;
        if (first === "" || remaining.length === 0) {
            return first.substring(0, first.lastIndexOf(sep) + 1);
        }
        const parts = first.split(sep);
        let endOfPrefix = parts.length;
        for (const path of remaining) {
            const compare = path.split(sep);
            for (let i = 0; i < endOfPrefix; i++) {
                if (compare[i] !== parts[i]) {
                    endOfPrefix = i;
                }
            }
            if (endOfPrefix === 0) {
                return "";
            }
        }
        const prefix = parts.slice(0, endOfPrefix).join(sep);
        return prefix.endsWith(sep) ? prefix : `${prefix}${sep}`;
    }
    exports_36("common", common);
    return {
        setters: [
            function (separator_ts_4_1) {
                separator_ts_4 = separator_ts_4_1;
            }
        ],
        execute: function () {
        }
    };
});
// This file is ported from globrex@0.1.2
// MIT License
// Copyright (c) 2018 Terkel Gjervig Nielsen
/** This module is browser compatible. */
System.register("https://deno.land/std@0.57.0/path/_globrex", ["https://deno.land/std@0.57.0/path/_constants"], function (exports_37, context_37) {
    "use strict";
    var _constants_ts_11, SEP, SEP_ESC, SEP_RAW, GLOBSTAR, WILDCARD, GLOBSTAR_SEGMENT, WILDCARD_SEGMENT;
    var __moduleName = context_37 && context_37.id;
    /**
     * Convert any glob pattern to a JavaScript Regexp object
     * @param glob Glob pattern to convert
     * @param opts Configuration object
     * @returns Converted object with string, segments and RegExp object
     */
    function globrex(glob, { extended = false, globstar = false, strict = false, filepath = false, flags = "", } = {}) {
        const sepPattern = new RegExp(`^${SEP}${strict ? "" : "+"}$`);
        let regex = "";
        let segment = "";
        let pathRegexStr = "";
        const pathSegments = [];
        // If we are doing extended matching, this boolean is true when we are inside
        // a group (eg {*.html,*.js}), and false otherwise.
        let inGroup = false;
        let inRange = false;
        // extglob stack. Keep track of scope
        const ext = [];
        // Helper function to build string and segments
        function add(str, options = { split: false, last: false, only: "" }) {
            const { split, last, only } = options;
            if (only !== "path")
                regex += str;
            if (filepath && only !== "regex") {
                pathRegexStr += str.match(sepPattern) ? SEP : str;
                if (split) {
                    if (last)
                        segment += str;
                    if (segment !== "") {
                        // change it 'includes'
                        if (!flags.includes("g"))
                            segment = `^${segment}$`;
                        pathSegments.push(new RegExp(segment, flags));
                    }
                    segment = "";
                }
                else {
                    segment += str;
                }
            }
        }
        let c, n;
        for (let i = 0; i < glob.length; i++) {
            c = glob[i];
            n = glob[i + 1];
            if (["\\", "$", "^", ".", "="].includes(c)) {
                add(`\\${c}`);
                continue;
            }
            if (c.match(sepPattern)) {
                add(SEP, { split: true });
                if (n != null && n.match(sepPattern) && !strict)
                    regex += "?";
                continue;
            }
            if (c === "(") {
                if (ext.length) {
                    add(`${c}?:`);
                    continue;
                }
                add(`\\${c}`);
                continue;
            }
            if (c === ")") {
                if (ext.length) {
                    add(c);
                    const type = ext.pop();
                    if (type === "@") {
                        add("{1}");
                    }
                    else if (type === "!") {
                        add(WILDCARD);
                    }
                    else {
                        add(type);
                    }
                    continue;
                }
                add(`\\${c}`);
                continue;
            }
            if (c === "|") {
                if (ext.length) {
                    add(c);
                    continue;
                }
                add(`\\${c}`);
                continue;
            }
            if (c === "+") {
                if (n === "(" && extended) {
                    ext.push(c);
                    continue;
                }
                add(`\\${c}`);
                continue;
            }
            if (c === "@" && extended) {
                if (n === "(") {
                    ext.push(c);
                    continue;
                }
            }
            if (c === "!") {
                if (extended) {
                    if (inRange) {
                        add("^");
                        continue;
                    }
                    if (n === "(") {
                        ext.push(c);
                        add("(?!");
                        i++;
                        continue;
                    }
                    add(`\\${c}`);
                    continue;
                }
                add(`\\${c}`);
                continue;
            }
            if (c === "?") {
                if (extended) {
                    if (n === "(") {
                        ext.push(c);
                    }
                    else {
                        add(".");
                    }
                    continue;
                }
                add(`\\${c}`);
                continue;
            }
            if (c === "[") {
                if (inRange && n === ":") {
                    i++; // skip [
                    let value = "";
                    while (glob[++i] !== ":")
                        value += glob[i];
                    if (value === "alnum")
                        add("(?:\\w|\\d)");
                    else if (value === "space")
                        add("\\s");
                    else if (value === "digit")
                        add("\\d");
                    i++; // skip last ]
                    continue;
                }
                if (extended) {
                    inRange = true;
                    add(c);
                    continue;
                }
                add(`\\${c}`);
                continue;
            }
            if (c === "]") {
                if (extended) {
                    inRange = false;
                    add(c);
                    continue;
                }
                add(`\\${c}`);
                continue;
            }
            if (c === "{") {
                if (extended) {
                    inGroup = true;
                    add("(?:");
                    continue;
                }
                add(`\\${c}`);
                continue;
            }
            if (c === "}") {
                if (extended) {
                    inGroup = false;
                    add(")");
                    continue;
                }
                add(`\\${c}`);
                continue;
            }
            if (c === ",") {
                if (inGroup) {
                    add("|");
                    continue;
                }
                add(`\\${c}`);
                continue;
            }
            if (c === "*") {
                if (n === "(" && extended) {
                    ext.push(c);
                    continue;
                }
                // Move over all consecutive "*"'s.
                // Also store the previous and next characters
                const prevChar = glob[i - 1];
                let starCount = 1;
                while (glob[i + 1] === "*") {
                    starCount++;
                    i++;
                }
                const nextChar = glob[i + 1];
                if (!globstar) {
                    // globstar is disabled, so treat any number of "*" as one
                    add(".*");
                }
                else {
                    // globstar is enabled, so determine if this is a globstar segment
                    const isGlobstar = starCount > 1 && // multiple "*"'s
                        // from the start of the segment
                        [SEP_RAW, "/", undefined].includes(prevChar) &&
                        // to the end of the segment
                        [SEP_RAW, "/", undefined].includes(nextChar);
                    if (isGlobstar) {
                        // it's a globstar, so match zero or more path segments
                        add(GLOBSTAR, { only: "regex" });
                        add(GLOBSTAR_SEGMENT, { only: "path", last: true, split: true });
                        i++; // move over the "/"
                    }
                    else {
                        // it's not a globstar, so only match one path segment
                        add(WILDCARD, { only: "regex" });
                        add(WILDCARD_SEGMENT, { only: "path" });
                    }
                }
                continue;
            }
            add(c);
        }
        // When regexp 'g' flag is specified don't
        // constrain the regular expression with ^ & $
        if (!flags.includes("g")) {
            regex = `^${regex}$`;
            segment = `^${segment}$`;
            if (filepath)
                pathRegexStr = `^${pathRegexStr}$`;
        }
        const result = { regex: new RegExp(regex, flags) };
        // Push the last segment
        if (filepath) {
            pathSegments.push(new RegExp(segment, flags));
            result.path = {
                regex: new RegExp(pathRegexStr, flags),
                segments: pathSegments,
                globstar: new RegExp(!flags.includes("g") ? `^${GLOBSTAR_SEGMENT}$` : GLOBSTAR_SEGMENT, flags),
            };
        }
        return result;
    }
    exports_37("globrex", globrex);
    return {
        setters: [
            function (_constants_ts_11_1) {
                _constants_ts_11 = _constants_ts_11_1;
            }
        ],
        execute: function () {
            SEP = _constants_ts_11.isWindows ? `(?:\\\\|\\/)` : `\\/`;
            SEP_ESC = _constants_ts_11.isWindows ? `\\\\` : `/`;
            SEP_RAW = _constants_ts_11.isWindows ? `\\` : `/`;
            GLOBSTAR = `(?:(?:[^${SEP_ESC}/]*(?:${SEP_ESC}|\/|$))*)`;
            WILDCARD = `(?:[^${SEP_ESC}/]*)`;
            GLOBSTAR_SEGMENT = `((?:[^${SEP_ESC}/]*(?:${SEP_ESC}|\/|$))*)`;
            WILDCARD_SEGMENT = `(?:[^${SEP_ESC}/]*)`;
        }
    };
});
// Copyright 2018-2020 the Deno authors. All rights reserved. MIT license.
/** This module is browser compatible. */
System.register("https://deno.land/std@0.57.0/path/glob", ["https://deno.land/std@0.57.0/path/separator", "https://deno.land/std@0.57.0/path/_globrex", "https://deno.land/std@0.57.0/path/mod", "https://deno.land/std@0.57.0/_util/assert"], function (exports_38, context_38) {
    "use strict";
    var separator_ts_5, _globrex_ts_2, mod_ts_5, assert_ts_7;
    var __moduleName = context_38 && context_38.id;
    /**
     * Generate a regex based on glob pattern and options
     * This was meant to be using the the `fs.walk` function
     * but can be used anywhere else.
     * Examples:
     *
     *     Looking for all the `ts` files:
     *     walkSync(".", {
     *       match: [globToRegExp("*.ts")]
     *     })
     *
     *     Looking for all the `.json` files in any subfolder:
     *     walkSync(".", {
     *       match: [globToRegExp(join("a", "**", "*.json"),{
     *         flags: "g",
     *         extended: true,
     *         globstar: true
     *       })]
     *     })
     *
     * @param glob - Glob pattern to be used
     * @param options - Specific options for the glob pattern
     * @returns A RegExp for the glob pattern
     */
    function globToRegExp(glob, { extended = false, globstar = true } = {}) {
        const result = _globrex_ts_2.globrex(glob, {
            extended,
            globstar,
            strict: false,
            filepath: true,
        });
        assert_ts_7.assert(result.path != null);
        return result.path.regex;
    }
    exports_38("globToRegExp", globToRegExp);
    /** Test whether the given string is a glob */
    function isGlob(str) {
        const chars = { "{": "}", "(": ")", "[": "]" };
        /* eslint-disable-next-line max-len */
        const regex = /\\(.)|(^!|\*|[\].+)]\?|\[[^\\\]]+\]|\{[^\\}]+\}|\(\?[:!=][^\\)]+\)|\([^|]+\|[^\\)]+\))/;
        if (str === "") {
            return false;
        }
        let match;
        while ((match = regex.exec(str))) {
            if (match[2])
                return true;
            let idx = match.index + match[0].length;
            // if an open bracket/brace/paren is escaped,
            // set the index to the next closing character
            const open = match[1];
            const close = open ? chars[open] : null;
            if (open && close) {
                const n = str.indexOf(close, idx);
                if (n !== -1) {
                    idx = n + 1;
                }
            }
            str = str.slice(idx);
        }
        return false;
    }
    exports_38("isGlob", isGlob);
    /** Like normalize(), but doesn't collapse "**\/.." when `globstar` is true. */
    function normalizeGlob(glob, { globstar = false } = {}) {
        if (!!glob.match(/\0/g)) {
            throw new Error(`Glob contains invalid characters: "${glob}"`);
        }
        if (!globstar) {
            return mod_ts_5.normalize(glob);
        }
        const s = separator_ts_5.SEP_PATTERN.source;
        const badParentPattern = new RegExp(`(?<=(${s}|^)\\*\\*${s})\\.\\.(?=${s}|$)`, "g");
        return mod_ts_5.normalize(glob.replace(badParentPattern, "\0")).replace(/\0/g, "..");
    }
    exports_38("normalizeGlob", normalizeGlob);
    /** Like join(), but doesn't collapse "**\/.." when `globstar` is true. */
    function joinGlobs(globs, { extended = false, globstar = false } = {}) {
        if (!globstar || globs.length == 0) {
            return mod_ts_5.join(...globs);
        }
        if (globs.length === 0)
            return ".";
        let joined;
        for (const glob of globs) {
            const path = glob;
            if (path.length > 0) {
                if (!joined)
                    joined = path;
                else
                    joined += `${separator_ts_5.SEP}${path}`;
            }
        }
        if (!joined)
            return ".";
        return normalizeGlob(joined, { extended, globstar });
    }
    exports_38("joinGlobs", joinGlobs);
    return {
        setters: [
            function (separator_ts_5_1) {
                separator_ts_5 = separator_ts_5_1;
            },
            function (_globrex_ts_2_1) {
                _globrex_ts_2 = _globrex_ts_2_1;
            },
            function (mod_ts_5_1) {
                mod_ts_5 = mod_ts_5_1;
            },
            function (assert_ts_7_1) {
                assert_ts_7 = assert_ts_7_1;
            }
        ],
        execute: function () {
        }
    };
});
// Copyright the Browserify authors. MIT License.
// Ported mostly from https://github.com/browserify/path-browserify/
/** This module is browser compatible. */
System.register("https://deno.land/std@0.57.0/path/mod", ["https://deno.land/std@0.57.0/path/_constants", "https://deno.land/std@0.57.0/path/win32", "https://deno.land/std@0.57.0/path/posix", "https://deno.land/std@0.57.0/path/common", "https://deno.land/std@0.57.0/path/separator", "https://deno.land/std@0.57.0/path/_interface", "https://deno.land/std@0.57.0/path/glob"], function (exports_39, context_39) {
    "use strict";
    var _constants_ts_12, _win32, _posix, path, win32, posix, basename, delimiter, dirname, extname, format, fromFileUrl, isAbsolute, join, normalize, parse, relative, resolve, sep, toNamespacedPath;
    var __moduleName = context_39 && context_39.id;
    var exportedNames_2 = {
        "win32": true,
        "posix": true,
        "basename": true,
        "delimiter": true,
        "dirname": true,
        "extname": true,
        "format": true,
        "fromFileUrl": true,
        "isAbsolute": true,
        "join": true,
        "normalize": true,
        "parse": true,
        "relative": true,
        "resolve": true,
        "sep": true,
        "toNamespacedPath": true,
        "SEP": true,
        "SEP_PATTERN": true
    };
    function exportStar_3(m) {
        var exports = {};
        for (var n in m) {
            if (n !== "default" && !exportedNames_2.hasOwnProperty(n)) exports[n] = m[n];
        }
        exports_39(exports);
    }
    return {
        setters: [
            function (_constants_ts_12_1) {
                _constants_ts_12 = _constants_ts_12_1;
            },
            function (_win32_2) {
                _win32 = _win32_2;
            },
            function (_posix_2) {
                _posix = _posix_2;
            },
            function (common_ts_2_1) {
                exportStar_3(common_ts_2_1);
            },
            function (separator_ts_6_1) {
                exports_39({
                    "SEP": separator_ts_6_1["SEP"],
                    "SEP_PATTERN": separator_ts_6_1["SEP_PATTERN"]
                });
            },
            function (_interface_ts_2_1) {
                exportStar_3(_interface_ts_2_1);
            },
            function (glob_ts_2_1) {
                exportStar_3(glob_ts_2_1);
            }
        ],
        execute: function () {
            path = _constants_ts_12.isWindows ? _win32 : _posix;
            exports_39("win32", win32 = _win32);
            exports_39("posix", posix = _posix);
            exports_39("basename", basename = path.basename), exports_39("delimiter", delimiter = path.delimiter), exports_39("dirname", dirname = path.dirname), exports_39("extname", extname = path.extname), exports_39("format", format = path.format), exports_39("fromFileUrl", fromFileUrl = path.fromFileUrl), exports_39("isAbsolute", isAbsolute = path.isAbsolute), exports_39("join", join = path.join), exports_39("normalize", normalize = path.normalize), exports_39("parse", parse = path.parse), exports_39("relative", relative = path.relative), exports_39("resolve", resolve = path.resolve), exports_39("sep", sep = path.sep), exports_39("toNamespacedPath", toNamespacedPath = path.toNamespacedPath);
        }
    };
});
System.register("https://deno.land/std@0.57.0/io/util", ["https://deno.land/std@0.57.0/path/mod"], function (exports_40, context_40) {
    "use strict";
    var mkdir, open, path;
    var __moduleName = context_40 && context_40.id;
    /**
     * Copy bytes from one Uint8Array to another.  Bytes from `src` which don't fit
     * into `dst` will not be copied.
     *
     * @param src Source byte array
     * @param dst Destination byte array
     * @param off Offset into `dst` at which to begin writing values from `src`.
     * @return number of bytes copied
     */
    function copyBytes(src, dst, off = 0) {
        off = Math.max(0, Math.min(off, dst.byteLength));
        const dstBytesAvailable = dst.byteLength - off;
        if (src.byteLength > dstBytesAvailable) {
            src = src.subarray(0, dstBytesAvailable);
        }
        dst.set(src, off);
        return src.byteLength;
    }
    exports_40("copyBytes", copyBytes);
    function charCode(s) {
        return s.charCodeAt(0);
    }
    exports_40("charCode", charCode);
    /** Create or open a temporal file at specified directory with prefix and
     *  postfix
     * */
    async function tempFile(dir, opts = { prefix: "", postfix: "" }) {
        const r = Math.floor(Math.random() * 1000000);
        const filepath = path.resolve(`${dir}/${opts.prefix || ""}${r}${opts.postfix || ""}`);
        await mkdir(path.dirname(filepath), { recursive: true });
        const file = await open(filepath, {
            create: true,
            read: true,
            write: true,
            append: true,
        });
        return { file, filepath };
    }
    exports_40("tempFile", tempFile);
    return {
        setters: [
            function (path_6) {
                path = path_6;
            }
        ],
        execute: function () {
            // Copyright 2018-2020 the Deno authors. All rights reserved. MIT license.
            mkdir = Deno.mkdir, open = Deno.open;
        }
    };
});
System.register("https://deno.land/std@0.57.0/bytes/mod", ["https://deno.land/std@0.57.0/io/util"], function (exports_41, context_41) {
    "use strict";
    var util_ts_1;
    var __moduleName = context_41 && context_41.id;
    /** Find first index of binary pattern from a. If not found, then return -1
     * @param source soruce array
     * @param pat pattern to find in source array
     */
    function findIndex(source, pat) {
        const s = pat[0];
        for (let i = 0; i < source.length; i++) {
            if (source[i] !== s)
                continue;
            const pin = i;
            let matched = 1;
            let j = i;
            while (matched < pat.length) {
                j++;
                if (source[j] !== pat[j - pin]) {
                    break;
                }
                matched++;
            }
            if (matched === pat.length) {
                return pin;
            }
        }
        return -1;
    }
    exports_41("findIndex", findIndex);
    /** Find last index of binary pattern from a. If not found, then return -1.
     * @param source soruce array
     * @param pat pattern to find in source array
     */
    function findLastIndex(source, pat) {
        const e = pat[pat.length - 1];
        for (let i = source.length - 1; i >= 0; i--) {
            if (source[i] !== e)
                continue;
            const pin = i;
            let matched = 1;
            let j = i;
            while (matched < pat.length) {
                j--;
                if (source[j] !== pat[pat.length - 1 - (pin - j)]) {
                    break;
                }
                matched++;
            }
            if (matched === pat.length) {
                return pin - pat.length + 1;
            }
        }
        return -1;
    }
    exports_41("findLastIndex", findLastIndex);
    /** Check whether binary arrays are equal to each other.
     * @param source first array to check equality
     * @param match second array to check equality
     */
    function equal(source, match) {
        if (source.length !== match.length)
            return false;
        for (let i = 0; i < match.length; i++) {
            if (source[i] !== match[i])
                return false;
        }
        return true;
    }
    exports_41("equal", equal);
    /** Check whether binary array starts with prefix.
     * @param source srouce array
     * @param prefix prefix array to check in source
     */
    function hasPrefix(source, prefix) {
        for (let i = 0, max = prefix.length; i < max; i++) {
            if (source[i] !== prefix[i])
                return false;
        }
        return true;
    }
    exports_41("hasPrefix", hasPrefix);
    /** Check whether binary array ends with suffix.
     * @param source srouce array
     * @param suffix suffix array to check in source
     */
    function hasSuffix(source, suffix) {
        for (let srci = source.length - 1, sfxi = suffix.length - 1; sfxi >= 0; srci--, sfxi--) {
            if (source[srci] !== suffix[sfxi])
                return false;
        }
        return true;
    }
    exports_41("hasSuffix", hasSuffix);
    /** Repeat bytes. returns a new byte slice consisting of `count` copies of `b`.
     * @param origin The origin bytes
     * @param count The count you want to repeat.
     */
    function repeat(origin, count) {
        if (count === 0) {
            return new Uint8Array();
        }
        if (count < 0) {
            throw new Error("bytes: negative repeat count");
        }
        else if ((origin.length * count) / count !== origin.length) {
            throw new Error("bytes: repeat count causes overflow");
        }
        const int = Math.floor(count);
        if (int !== count) {
            throw new Error("bytes: repeat count must be an integer");
        }
        const nb = new Uint8Array(origin.length * count);
        let bp = util_ts_1.copyBytes(origin, nb);
        for (; bp < nb.length; bp *= 2) {
            util_ts_1.copyBytes(nb.slice(0, bp), nb, bp);
        }
        return nb;
    }
    exports_41("repeat", repeat);
    /** Concatenate two binary arrays and return new one.
     * @param origin origin array to concatenate
     * @param b array to concatenate with origin
     */
    function concat(origin, b) {
        const output = new Uint8Array(origin.length + b.length);
        output.set(origin, 0);
        output.set(b, origin.length);
        return output;
    }
    exports_41("concat", concat);
    /** Check srouce array contains pattern array.
     * @param source srouce array
     * @param pat patter array
     */
    function contains(source, pat) {
        return findIndex(source, pat) != -1;
    }
    exports_41("contains", contains);
    return {
        setters: [
            function (util_ts_1_1) {
                util_ts_1 = util_ts_1_1;
            }
        ],
        execute: function () {
        }
    };
});
/*
 * [js-sha1]{@link https://github.com/emn178/js-sha1}
 *
 * @version 0.6.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2014-2017
 * @license MIT
 */
System.register("https://deno.land/std@0.57.0/hash/sha1", [], function (exports_42, context_42) {
    "use strict";
    var HEX_CHARS, EXTRA, SHIFT, blocks, Sha1;
    var __moduleName = context_42 && context_42.id;
    return {
        setters: [],
        execute: function () {
            HEX_CHARS = "0123456789abcdef".split("");
            EXTRA = [-2147483648, 8388608, 32768, 128];
            SHIFT = [24, 16, 8, 0];
            blocks = [];
            Sha1 = class Sha1 {
                constructor(sharedMemory = false) {
                    this.#h0 = 0x67452301;
                    this.#h1 = 0xefcdab89;
                    this.#h2 = 0x98badcfe;
                    this.#h3 = 0x10325476;
                    this.#h4 = 0xc3d2e1f0;
                    this.#lastByteIndex = 0;
                    if (sharedMemory) {
                        blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
                        this.#blocks = blocks;
                    }
                    else {
                        this.#blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
                    }
                    this.#h0 = 0x67452301;
                    this.#h1 = 0xefcdab89;
                    this.#h2 = 0x98badcfe;
                    this.#h3 = 0x10325476;
                    this.#h4 = 0xc3d2e1f0;
                    this.#block = this.#start = this.#bytes = this.#hBytes = 0;
                    this.#finalized = this.#hashed = false;
                }
                #blocks;
                #block;
                #start;
                #bytes;
                #hBytes;
                #finalized;
                #hashed;
                #h0;
                #h1;
                #h2;
                #h3;
                #h4;
                #lastByteIndex;
                update(message) {
                    if (this.#finalized) {
                        return this;
                    }
                    let msg;
                    if (message instanceof ArrayBuffer) {
                        msg = new Uint8Array(message);
                    }
                    else {
                        msg = message;
                    }
                    let index = 0;
                    const length = msg.length;
                    const blocks = this.#blocks;
                    while (index < length) {
                        let i;
                        if (this.#hashed) {
                            this.#hashed = false;
                            blocks[0] = this.#block;
                            blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
                        }
                        if (typeof msg !== "string") {
                            for (i = this.#start; index < length && i < 64; ++index) {
                                blocks[i >> 2] |= msg[index] << SHIFT[i++ & 3];
                            }
                        }
                        else {
                            for (i = this.#start; index < length && i < 64; ++index) {
                                let code = msg.charCodeAt(index);
                                if (code < 0x80) {
                                    blocks[i >> 2] |= code << SHIFT[i++ & 3];
                                }
                                else if (code < 0x800) {
                                    blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
                                }
                                else if (code < 0xd800 || code >= 0xe000) {
                                    blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
                                }
                                else {
                                    code =
                                        0x10000 +
                                            (((code & 0x3ff) << 10) | (msg.charCodeAt(++index) & 0x3ff));
                                    blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
                                }
                            }
                        }
                        this.#lastByteIndex = i;
                        this.#bytes += i - this.#start;
                        if (i >= 64) {
                            this.#block = blocks[16];
                            this.#start = i - 64;
                            this.hash();
                            this.#hashed = true;
                        }
                        else {
                            this.#start = i;
                        }
                    }
                    if (this.#bytes > 4294967295) {
                        this.#hBytes += (this.#bytes / 4294967296) >>> 0;
                        this.#bytes = this.#bytes >>> 0;
                    }
                    return this;
                }
                finalize() {
                    if (this.#finalized) {
                        return;
                    }
                    this.#finalized = true;
                    const blocks = this.#blocks;
                    const i = this.#lastByteIndex;
                    blocks[16] = this.#block;
                    blocks[i >> 2] |= EXTRA[i & 3];
                    this.#block = blocks[16];
                    if (i >= 56) {
                        if (!this.#hashed) {
                            this.hash();
                        }
                        blocks[0] = this.#block;
                        blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
                    }
                    blocks[14] = (this.#hBytes << 3) | (this.#bytes >>> 29);
                    blocks[15] = this.#bytes << 3;
                    this.hash();
                }
                hash() {
                    let a = this.#h0;
                    let b = this.#h1;
                    let c = this.#h2;
                    let d = this.#h3;
                    let e = this.#h4;
                    let f;
                    let j;
                    let t;
                    const blocks = this.#blocks;
                    for (j = 16; j < 80; ++j) {
                        t = blocks[j - 3] ^ blocks[j - 8] ^ blocks[j - 14] ^ blocks[j - 16];
                        blocks[j] = (t << 1) | (t >>> 31);
                    }
                    for (j = 0; j < 20; j += 5) {
                        f = (b & c) | (~b & d);
                        t = (a << 5) | (a >>> 27);
                        e = (t + f + e + 1518500249 + blocks[j]) >>> 0;
                        b = (b << 30) | (b >>> 2);
                        f = (a & b) | (~a & c);
                        t = (e << 5) | (e >>> 27);
                        d = (t + f + d + 1518500249 + blocks[j + 1]) >>> 0;
                        a = (a << 30) | (a >>> 2);
                        f = (e & a) | (~e & b);
                        t = (d << 5) | (d >>> 27);
                        c = (t + f + c + 1518500249 + blocks[j + 2]) >>> 0;
                        e = (e << 30) | (e >>> 2);
                        f = (d & e) | (~d & a);
                        t = (c << 5) | (c >>> 27);
                        b = (t + f + b + 1518500249 + blocks[j + 3]) >>> 0;
                        d = (d << 30) | (d >>> 2);
                        f = (c & d) | (~c & e);
                        t = (b << 5) | (b >>> 27);
                        a = (t + f + a + 1518500249 + blocks[j + 4]) >>> 0;
                        c = (c << 30) | (c >>> 2);
                    }
                    for (; j < 40; j += 5) {
                        f = b ^ c ^ d;
                        t = (a << 5) | (a >>> 27);
                        e = (t + f + e + 1859775393 + blocks[j]) >>> 0;
                        b = (b << 30) | (b >>> 2);
                        f = a ^ b ^ c;
                        t = (e << 5) | (e >>> 27);
                        d = (t + f + d + 1859775393 + blocks[j + 1]) >>> 0;
                        a = (a << 30) | (a >>> 2);
                        f = e ^ a ^ b;
                        t = (d << 5) | (d >>> 27);
                        c = (t + f + c + 1859775393 + blocks[j + 2]) >>> 0;
                        e = (e << 30) | (e >>> 2);
                        f = d ^ e ^ a;
                        t = (c << 5) | (c >>> 27);
                        b = (t + f + b + 1859775393 + blocks[j + 3]) >>> 0;
                        d = (d << 30) | (d >>> 2);
                        f = c ^ d ^ e;
                        t = (b << 5) | (b >>> 27);
                        a = (t + f + a + 1859775393 + blocks[j + 4]) >>> 0;
                        c = (c << 30) | (c >>> 2);
                    }
                    for (; j < 60; j += 5) {
                        f = (b & c) | (b & d) | (c & d);
                        t = (a << 5) | (a >>> 27);
                        e = (t + f + e - 1894007588 + blocks[j]) >>> 0;
                        b = (b << 30) | (b >>> 2);
                        f = (a & b) | (a & c) | (b & c);
                        t = (e << 5) | (e >>> 27);
                        d = (t + f + d - 1894007588 + blocks[j + 1]) >>> 0;
                        a = (a << 30) | (a >>> 2);
                        f = (e & a) | (e & b) | (a & b);
                        t = (d << 5) | (d >>> 27);
                        c = (t + f + c - 1894007588 + blocks[j + 2]) >>> 0;
                        e = (e << 30) | (e >>> 2);
                        f = (d & e) | (d & a) | (e & a);
                        t = (c << 5) | (c >>> 27);
                        b = (t + f + b - 1894007588 + blocks[j + 3]) >>> 0;
                        d = (d << 30) | (d >>> 2);
                        f = (c & d) | (c & e) | (d & e);
                        t = (b << 5) | (b >>> 27);
                        a = (t + f + a - 1894007588 + blocks[j + 4]) >>> 0;
                        c = (c << 30) | (c >>> 2);
                    }
                    for (; j < 80; j += 5) {
                        f = b ^ c ^ d;
                        t = (a << 5) | (a >>> 27);
                        e = (t + f + e - 899497514 + blocks[j]) >>> 0;
                        b = (b << 30) | (b >>> 2);
                        f = a ^ b ^ c;
                        t = (e << 5) | (e >>> 27);
                        d = (t + f + d - 899497514 + blocks[j + 1]) >>> 0;
                        a = (a << 30) | (a >>> 2);
                        f = e ^ a ^ b;
                        t = (d << 5) | (d >>> 27);
                        c = (t + f + c - 899497514 + blocks[j + 2]) >>> 0;
                        e = (e << 30) | (e >>> 2);
                        f = d ^ e ^ a;
                        t = (c << 5) | (c >>> 27);
                        b = (t + f + b - 899497514 + blocks[j + 3]) >>> 0;
                        d = (d << 30) | (d >>> 2);
                        f = c ^ d ^ e;
                        t = (b << 5) | (b >>> 27);
                        a = (t + f + a - 899497514 + blocks[j + 4]) >>> 0;
                        c = (c << 30) | (c >>> 2);
                    }
                    this.#h0 = (this.#h0 + a) >>> 0;
                    this.#h1 = (this.#h1 + b) >>> 0;
                    this.#h2 = (this.#h2 + c) >>> 0;
                    this.#h3 = (this.#h3 + d) >>> 0;
                    this.#h4 = (this.#h4 + e) >>> 0;
                }
                hex() {
                    this.finalize();
                    const h0 = this.#h0;
                    const h1 = this.#h1;
                    const h2 = this.#h2;
                    const h3 = this.#h3;
                    const h4 = this.#h4;
                    return (HEX_CHARS[(h0 >> 28) & 0x0f] +
                        HEX_CHARS[(h0 >> 24) & 0x0f] +
                        HEX_CHARS[(h0 >> 20) & 0x0f] +
                        HEX_CHARS[(h0 >> 16) & 0x0f] +
                        HEX_CHARS[(h0 >> 12) & 0x0f] +
                        HEX_CHARS[(h0 >> 8) & 0x0f] +
                        HEX_CHARS[(h0 >> 4) & 0x0f] +
                        HEX_CHARS[h0 & 0x0f] +
                        HEX_CHARS[(h1 >> 28) & 0x0f] +
                        HEX_CHARS[(h1 >> 24) & 0x0f] +
                        HEX_CHARS[(h1 >> 20) & 0x0f] +
                        HEX_CHARS[(h1 >> 16) & 0x0f] +
                        HEX_CHARS[(h1 >> 12) & 0x0f] +
                        HEX_CHARS[(h1 >> 8) & 0x0f] +
                        HEX_CHARS[(h1 >> 4) & 0x0f] +
                        HEX_CHARS[h1 & 0x0f] +
                        HEX_CHARS[(h2 >> 28) & 0x0f] +
                        HEX_CHARS[(h2 >> 24) & 0x0f] +
                        HEX_CHARS[(h2 >> 20) & 0x0f] +
                        HEX_CHARS[(h2 >> 16) & 0x0f] +
                        HEX_CHARS[(h2 >> 12) & 0x0f] +
                        HEX_CHARS[(h2 >> 8) & 0x0f] +
                        HEX_CHARS[(h2 >> 4) & 0x0f] +
                        HEX_CHARS[h2 & 0x0f] +
                        HEX_CHARS[(h3 >> 28) & 0x0f] +
                        HEX_CHARS[(h3 >> 24) & 0x0f] +
                        HEX_CHARS[(h3 >> 20) & 0x0f] +
                        HEX_CHARS[(h3 >> 16) & 0x0f] +
                        HEX_CHARS[(h3 >> 12) & 0x0f] +
                        HEX_CHARS[(h3 >> 8) & 0x0f] +
                        HEX_CHARS[(h3 >> 4) & 0x0f] +
                        HEX_CHARS[h3 & 0x0f] +
                        HEX_CHARS[(h4 >> 28) & 0x0f] +
                        HEX_CHARS[(h4 >> 24) & 0x0f] +
                        HEX_CHARS[(h4 >> 20) & 0x0f] +
                        HEX_CHARS[(h4 >> 16) & 0x0f] +
                        HEX_CHARS[(h4 >> 12) & 0x0f] +
                        HEX_CHARS[(h4 >> 8) & 0x0f] +
                        HEX_CHARS[(h4 >> 4) & 0x0f] +
                        HEX_CHARS[h4 & 0x0f]);
                }
                toString() {
                    return this.hex();
                }
                digest() {
                    this.finalize();
                    const h0 = this.#h0;
                    const h1 = this.#h1;
                    const h2 = this.#h2;
                    const h3 = this.#h3;
                    const h4 = this.#h4;
                    return [
                        (h0 >> 24) & 0xff,
                        (h0 >> 16) & 0xff,
                        (h0 >> 8) & 0xff,
                        h0 & 0xff,
                        (h1 >> 24) & 0xff,
                        (h1 >> 16) & 0xff,
                        (h1 >> 8) & 0xff,
                        h1 & 0xff,
                        (h2 >> 24) & 0xff,
                        (h2 >> 16) & 0xff,
                        (h2 >> 8) & 0xff,
                        h2 & 0xff,
                        (h3 >> 24) & 0xff,
                        (h3 >> 16) & 0xff,
                        (h3 >> 8) & 0xff,
                        h3 & 0xff,
                        (h4 >> 24) & 0xff,
                        (h4 >> 16) & 0xff,
                        (h4 >> 8) & 0xff,
                        h4 & 0xff,
                    ];
                }
                array() {
                    return this.digest();
                }
                arrayBuffer() {
                    this.finalize();
                    const buffer = new ArrayBuffer(20);
                    const dataView = new DataView(buffer);
                    dataView.setUint32(0, this.#h0);
                    dataView.setUint32(4, this.#h1);
                    dataView.setUint32(8, this.#h2);
                    dataView.setUint32(12, this.#h3);
                    dataView.setUint32(16, this.#h4);
                    return buffer;
                }
            };
            exports_42("Sha1", Sha1);
        }
    };
});
/*
 * Adapted to deno from:
 *
 * [js-sha256]{@link https://github.com/emn178/js-sha256}
 *
 * @version 0.9.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2014-2017
 * @license MIT
 */
System.register("https://deno.land/std@0.57.0/hash/sha256", [], function (exports_43, context_43) {
    "use strict";
    var HEX_CHARS, EXTRA, SHIFT, K, blocks, Sha256, HmacSha256;
    var __moduleName = context_43 && context_43.id;
    return {
        setters: [],
        execute: function () {
            HEX_CHARS = "0123456789abcdef".split("");
            EXTRA = [-2147483648, 8388608, 32768, 128];
            SHIFT = [24, 16, 8, 0];
            // prettier-ignore
            // deno-fmt-ignore
            K = [
                0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1,
                0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
                0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786,
                0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
                0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147,
                0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
                0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b,
                0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
                0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a,
                0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
                0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2,
            ];
            blocks = [];
            Sha256 = class Sha256 {
                constructor(is224 = false, sharedMemory = false) {
                    this.#lastByteIndex = 0;
                    this.init(is224, sharedMemory);
                }
                #block;
                #blocks;
                #bytes;
                #finalized;
                #first;
                #h0;
                #h1;
                #h2;
                #h3;
                #h4;
                #h5;
                #h6;
                #h7;
                #hashed;
                #hBytes;
                #is224;
                #lastByteIndex;
                #start;
                init(is224, sharedMemory) {
                    if (sharedMemory) {
                        blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
                        this.#blocks = blocks;
                    }
                    else {
                        this.#blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
                    }
                    if (is224) {
                        this.#h0 = 0xc1059ed8;
                        this.#h1 = 0x367cd507;
                        this.#h2 = 0x3070dd17;
                        this.#h3 = 0xf70e5939;
                        this.#h4 = 0xffc00b31;
                        this.#h5 = 0x68581511;
                        this.#h6 = 0x64f98fa7;
                        this.#h7 = 0xbefa4fa4;
                    }
                    else {
                        // 256
                        this.#h0 = 0x6a09e667;
                        this.#h1 = 0xbb67ae85;
                        this.#h2 = 0x3c6ef372;
                        this.#h3 = 0xa54ff53a;
                        this.#h4 = 0x510e527f;
                        this.#h5 = 0x9b05688c;
                        this.#h6 = 0x1f83d9ab;
                        this.#h7 = 0x5be0cd19;
                    }
                    this.#block = this.#start = this.#bytes = this.#hBytes = 0;
                    this.#finalized = this.#hashed = false;
                    this.#first = true;
                    this.#is224 = is224;
                }
                /** Update hash
                 *
                 * @param message The message you want to hash.
                 */
                update(message) {
                    if (this.#finalized) {
                        return this;
                    }
                    let msg;
                    if (message instanceof ArrayBuffer) {
                        msg = new Uint8Array(message);
                    }
                    else {
                        msg = message;
                    }
                    let index = 0;
                    const length = msg.length;
                    const blocks = this.#blocks;
                    while (index < length) {
                        let i;
                        if (this.#hashed) {
                            this.#hashed = false;
                            blocks[0] = this.#block;
                            blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
                        }
                        if (typeof msg !== "string") {
                            for (i = this.#start; index < length && i < 64; ++index) {
                                blocks[i >> 2] |= msg[index] << SHIFT[i++ & 3];
                            }
                        }
                        else {
                            for (i = this.#start; index < length && i < 64; ++index) {
                                let code = msg.charCodeAt(index);
                                if (code < 0x80) {
                                    blocks[i >> 2] |= code << SHIFT[i++ & 3];
                                }
                                else if (code < 0x800) {
                                    blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
                                }
                                else if (code < 0xd800 || code >= 0xe000) {
                                    blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
                                }
                                else {
                                    code =
                                        0x10000 +
                                            (((code & 0x3ff) << 10) | (msg.charCodeAt(++index) & 0x3ff));
                                    blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
                                }
                            }
                        }
                        this.#lastByteIndex = i;
                        this.#bytes += i - this.#start;
                        if (i >= 64) {
                            this.#block = blocks[16];
                            this.#start = i - 64;
                            this.hash();
                            this.#hashed = true;
                        }
                        else {
                            this.#start = i;
                        }
                    }
                    if (this.#bytes > 4294967295) {
                        this.#hBytes += (this.#bytes / 4294967296) << 0;
                        this.#bytes = this.#bytes % 4294967296;
                    }
                    return this;
                }
                finalize() {
                    if (this.#finalized) {
                        return;
                    }
                    this.#finalized = true;
                    const blocks = this.#blocks;
                    const i = this.#lastByteIndex;
                    blocks[16] = this.#block;
                    blocks[i >> 2] |= EXTRA[i & 3];
                    this.#block = blocks[16];
                    if (i >= 56) {
                        if (!this.#hashed) {
                            this.hash();
                        }
                        blocks[0] = this.#block;
                        blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
                    }
                    blocks[14] = (this.#hBytes << 3) | (this.#bytes >>> 29);
                    blocks[15] = this.#bytes << 3;
                    this.hash();
                }
                hash() {
                    let a = this.#h0;
                    let b = this.#h1;
                    let c = this.#h2;
                    let d = this.#h3;
                    let e = this.#h4;
                    let f = this.#h5;
                    let g = this.#h6;
                    let h = this.#h7;
                    const blocks = this.#blocks;
                    let s0;
                    let s1;
                    let maj;
                    let t1;
                    let t2;
                    let ch;
                    let ab;
                    let da;
                    let cd;
                    let bc;
                    for (let j = 16; j < 64; ++j) {
                        // rightrotate
                        t1 = blocks[j - 15];
                        s0 = ((t1 >>> 7) | (t1 << 25)) ^ ((t1 >>> 18) | (t1 << 14)) ^ (t1 >>> 3);
                        t1 = blocks[j - 2];
                        s1 =
                            ((t1 >>> 17) | (t1 << 15)) ^ ((t1 >>> 19) | (t1 << 13)) ^ (t1 >>> 10);
                        blocks[j] = (blocks[j - 16] + s0 + blocks[j - 7] + s1) << 0;
                    }
                    bc = b & c;
                    for (let j = 0; j < 64; j += 4) {
                        if (this.#first) {
                            if (this.#is224) {
                                ab = 300032;
                                t1 = blocks[0] - 1413257819;
                                h = (t1 - 150054599) << 0;
                                d = (t1 + 24177077) << 0;
                            }
                            else {
                                ab = 704751109;
                                t1 = blocks[0] - 210244248;
                                h = (t1 - 1521486534) << 0;
                                d = (t1 + 143694565) << 0;
                            }
                            this.#first = false;
                        }
                        else {
                            s0 =
                                ((a >>> 2) | (a << 30)) ^
                                    ((a >>> 13) | (a << 19)) ^
                                    ((a >>> 22) | (a << 10));
                            s1 =
                                ((e >>> 6) | (e << 26)) ^
                                    ((e >>> 11) | (e << 21)) ^
                                    ((e >>> 25) | (e << 7));
                            ab = a & b;
                            maj = ab ^ (a & c) ^ bc;
                            ch = (e & f) ^ (~e & g);
                            t1 = h + s1 + ch + K[j] + blocks[j];
                            t2 = s0 + maj;
                            h = (d + t1) << 0;
                            d = (t1 + t2) << 0;
                        }
                        s0 =
                            ((d >>> 2) | (d << 30)) ^
                                ((d >>> 13) | (d << 19)) ^
                                ((d >>> 22) | (d << 10));
                        s1 =
                            ((h >>> 6) | (h << 26)) ^
                                ((h >>> 11) | (h << 21)) ^
                                ((h >>> 25) | (h << 7));
                        da = d & a;
                        maj = da ^ (d & b) ^ ab;
                        ch = (h & e) ^ (~h & f);
                        t1 = g + s1 + ch + K[j + 1] + blocks[j + 1];
                        t2 = s0 + maj;
                        g = (c + t1) << 0;
                        c = (t1 + t2) << 0;
                        s0 =
                            ((c >>> 2) | (c << 30)) ^
                                ((c >>> 13) | (c << 19)) ^
                                ((c >>> 22) | (c << 10));
                        s1 =
                            ((g >>> 6) | (g << 26)) ^
                                ((g >>> 11) | (g << 21)) ^
                                ((g >>> 25) | (g << 7));
                        cd = c & d;
                        maj = cd ^ (c & a) ^ da;
                        ch = (g & h) ^ (~g & e);
                        t1 = f + s1 + ch + K[j + 2] + blocks[j + 2];
                        t2 = s0 + maj;
                        f = (b + t1) << 0;
                        b = (t1 + t2) << 0;
                        s0 =
                            ((b >>> 2) | (b << 30)) ^
                                ((b >>> 13) | (b << 19)) ^
                                ((b >>> 22) | (b << 10));
                        s1 =
                            ((f >>> 6) | (f << 26)) ^
                                ((f >>> 11) | (f << 21)) ^
                                ((f >>> 25) | (f << 7));
                        bc = b & c;
                        maj = bc ^ (b & d) ^ cd;
                        ch = (f & g) ^ (~f & h);
                        t1 = e + s1 + ch + K[j + 3] + blocks[j + 3];
                        t2 = s0 + maj;
                        e = (a + t1) << 0;
                        a = (t1 + t2) << 0;
                    }
                    this.#h0 = (this.#h0 + a) << 0;
                    this.#h1 = (this.#h1 + b) << 0;
                    this.#h2 = (this.#h2 + c) << 0;
                    this.#h3 = (this.#h3 + d) << 0;
                    this.#h4 = (this.#h4 + e) << 0;
                    this.#h5 = (this.#h5 + f) << 0;
                    this.#h6 = (this.#h6 + g) << 0;
                    this.#h7 = (this.#h7 + h) << 0;
                }
                /** Return hash in hex string. */
                hex() {
                    this.finalize();
                    const h0 = this.#h0;
                    const h1 = this.#h1;
                    const h2 = this.#h2;
                    const h3 = this.#h3;
                    const h4 = this.#h4;
                    const h5 = this.#h5;
                    const h6 = this.#h6;
                    const h7 = this.#h7;
                    let hex = HEX_CHARS[(h0 >> 28) & 0x0f] +
                        HEX_CHARS[(h0 >> 24) & 0x0f] +
                        HEX_CHARS[(h0 >> 20) & 0x0f] +
                        HEX_CHARS[(h0 >> 16) & 0x0f] +
                        HEX_CHARS[(h0 >> 12) & 0x0f] +
                        HEX_CHARS[(h0 >> 8) & 0x0f] +
                        HEX_CHARS[(h0 >> 4) & 0x0f] +
                        HEX_CHARS[h0 & 0x0f] +
                        HEX_CHARS[(h1 >> 28) & 0x0f] +
                        HEX_CHARS[(h1 >> 24) & 0x0f] +
                        HEX_CHARS[(h1 >> 20) & 0x0f] +
                        HEX_CHARS[(h1 >> 16) & 0x0f] +
                        HEX_CHARS[(h1 >> 12) & 0x0f] +
                        HEX_CHARS[(h1 >> 8) & 0x0f] +
                        HEX_CHARS[(h1 >> 4) & 0x0f] +
                        HEX_CHARS[h1 & 0x0f] +
                        HEX_CHARS[(h2 >> 28) & 0x0f] +
                        HEX_CHARS[(h2 >> 24) & 0x0f] +
                        HEX_CHARS[(h2 >> 20) & 0x0f] +
                        HEX_CHARS[(h2 >> 16) & 0x0f] +
                        HEX_CHARS[(h2 >> 12) & 0x0f] +
                        HEX_CHARS[(h2 >> 8) & 0x0f] +
                        HEX_CHARS[(h2 >> 4) & 0x0f] +
                        HEX_CHARS[h2 & 0x0f] +
                        HEX_CHARS[(h3 >> 28) & 0x0f] +
                        HEX_CHARS[(h3 >> 24) & 0x0f] +
                        HEX_CHARS[(h3 >> 20) & 0x0f] +
                        HEX_CHARS[(h3 >> 16) & 0x0f] +
                        HEX_CHARS[(h3 >> 12) & 0x0f] +
                        HEX_CHARS[(h3 >> 8) & 0x0f] +
                        HEX_CHARS[(h3 >> 4) & 0x0f] +
                        HEX_CHARS[h3 & 0x0f] +
                        HEX_CHARS[(h4 >> 28) & 0x0f] +
                        HEX_CHARS[(h4 >> 24) & 0x0f] +
                        HEX_CHARS[(h4 >> 20) & 0x0f] +
                        HEX_CHARS[(h4 >> 16) & 0x0f] +
                        HEX_CHARS[(h4 >> 12) & 0x0f] +
                        HEX_CHARS[(h4 >> 8) & 0x0f] +
                        HEX_CHARS[(h4 >> 4) & 0x0f] +
                        HEX_CHARS[h4 & 0x0f] +
                        HEX_CHARS[(h5 >> 28) & 0x0f] +
                        HEX_CHARS[(h5 >> 24) & 0x0f] +
                        HEX_CHARS[(h5 >> 20) & 0x0f] +
                        HEX_CHARS[(h5 >> 16) & 0x0f] +
                        HEX_CHARS[(h5 >> 12) & 0x0f] +
                        HEX_CHARS[(h5 >> 8) & 0x0f] +
                        HEX_CHARS[(h5 >> 4) & 0x0f] +
                        HEX_CHARS[h5 & 0x0f] +
                        HEX_CHARS[(h6 >> 28) & 0x0f] +
                        HEX_CHARS[(h6 >> 24) & 0x0f] +
                        HEX_CHARS[(h6 >> 20) & 0x0f] +
                        HEX_CHARS[(h6 >> 16) & 0x0f] +
                        HEX_CHARS[(h6 >> 12) & 0x0f] +
                        HEX_CHARS[(h6 >> 8) & 0x0f] +
                        HEX_CHARS[(h6 >> 4) & 0x0f] +
                        HEX_CHARS[h6 & 0x0f];
                    if (!this.#is224) {
                        hex +=
                            HEX_CHARS[(h7 >> 28) & 0x0f] +
                                HEX_CHARS[(h7 >> 24) & 0x0f] +
                                HEX_CHARS[(h7 >> 20) & 0x0f] +
                                HEX_CHARS[(h7 >> 16) & 0x0f] +
                                HEX_CHARS[(h7 >> 12) & 0x0f] +
                                HEX_CHARS[(h7 >> 8) & 0x0f] +
                                HEX_CHARS[(h7 >> 4) & 0x0f] +
                                HEX_CHARS[h7 & 0x0f];
                    }
                    return hex;
                }
                /** Return hash in hex string. */
                toString() {
                    return this.hex();
                }
                /** Return hash in integer array. */
                digest() {
                    this.finalize();
                    const h0 = this.#h0;
                    const h1 = this.#h1;
                    const h2 = this.#h2;
                    const h3 = this.#h3;
                    const h4 = this.#h4;
                    const h5 = this.#h5;
                    const h6 = this.#h6;
                    const h7 = this.#h7;
                    const arr = [
                        (h0 >> 24) & 0xff,
                        (h0 >> 16) & 0xff,
                        (h0 >> 8) & 0xff,
                        h0 & 0xff,
                        (h1 >> 24) & 0xff,
                        (h1 >> 16) & 0xff,
                        (h1 >> 8) & 0xff,
                        h1 & 0xff,
                        (h2 >> 24) & 0xff,
                        (h2 >> 16) & 0xff,
                        (h2 >> 8) & 0xff,
                        h2 & 0xff,
                        (h3 >> 24) & 0xff,
                        (h3 >> 16) & 0xff,
                        (h3 >> 8) & 0xff,
                        h3 & 0xff,
                        (h4 >> 24) & 0xff,
                        (h4 >> 16) & 0xff,
                        (h4 >> 8) & 0xff,
                        h4 & 0xff,
                        (h5 >> 24) & 0xff,
                        (h5 >> 16) & 0xff,
                        (h5 >> 8) & 0xff,
                        h5 & 0xff,
                        (h6 >> 24) & 0xff,
                        (h6 >> 16) & 0xff,
                        (h6 >> 8) & 0xff,
                        h6 & 0xff,
                    ];
                    if (!this.#is224) {
                        arr.push((h7 >> 24) & 0xff, (h7 >> 16) & 0xff, (h7 >> 8) & 0xff, h7 & 0xff);
                    }
                    return arr;
                }
                /** Return hash in integer array. */
                array() {
                    return this.digest();
                }
                /** Return hash in ArrayBuffer. */
                arrayBuffer() {
                    this.finalize();
                    const buffer = new ArrayBuffer(this.#is224 ? 28 : 32);
                    const dataView = new DataView(buffer);
                    dataView.setUint32(0, this.#h0);
                    dataView.setUint32(4, this.#h1);
                    dataView.setUint32(8, this.#h2);
                    dataView.setUint32(12, this.#h3);
                    dataView.setUint32(16, this.#h4);
                    dataView.setUint32(20, this.#h5);
                    dataView.setUint32(24, this.#h6);
                    if (!this.#is224) {
                        dataView.setUint32(28, this.#h7);
                    }
                    return buffer;
                }
            };
            exports_43("Sha256", Sha256);
            HmacSha256 = class HmacSha256 extends Sha256 {
                constructor(secretKey, is224 = false, sharedMemory = false) {
                    super(is224, sharedMemory);
                    let key;
                    if (typeof secretKey === "string") {
                        const bytes = [];
                        const length = secretKey.length;
                        let index = 0;
                        for (let i = 0; i < length; ++i) {
                            let code = secretKey.charCodeAt(i);
                            if (code < 0x80) {
                                bytes[index++] = code;
                            }
                            else if (code < 0x800) {
                                bytes[index++] = 0xc0 | (code >> 6);
                                bytes[index++] = 0x80 | (code & 0x3f);
                            }
                            else if (code < 0xd800 || code >= 0xe000) {
                                bytes[index++] = 0xe0 | (code >> 12);
                                bytes[index++] = 0x80 | ((code >> 6) & 0x3f);
                                bytes[index++] = 0x80 | (code & 0x3f);
                            }
                            else {
                                code =
                                    0x10000 +
                                        (((code & 0x3ff) << 10) | (secretKey.charCodeAt(++i) & 0x3ff));
                                bytes[index++] = 0xf0 | (code >> 18);
                                bytes[index++] = 0x80 | ((code >> 12) & 0x3f);
                                bytes[index++] = 0x80 | ((code >> 6) & 0x3f);
                                bytes[index++] = 0x80 | (code & 0x3f);
                            }
                        }
                        key = bytes;
                    }
                    else {
                        if (secretKey instanceof ArrayBuffer) {
                            key = new Uint8Array(secretKey);
                        }
                        else {
                            key = secretKey;
                        }
                    }
                    if (key.length > 64) {
                        key = new Sha256(is224, true).update(key).array();
                    }
                    const oKeyPad = [];
                    const iKeyPad = [];
                    for (let i = 0; i < 64; ++i) {
                        const b = key[i] || 0;
                        oKeyPad[i] = 0x5c ^ b;
                        iKeyPad[i] = 0x36 ^ b;
                    }
                    this.update(iKeyPad);
                    this.#oKeyPad = oKeyPad;
                    this.#inner = true;
                    this.#is224 = is224;
                    this.#sharedMemory = sharedMemory;
                }
                #inner;
                #is224;
                #oKeyPad;
                #sharedMemory;
                finalize() {
                    super.finalize();
                    if (this.#inner) {
                        this.#inner = false;
                        const innerHash = this.array();
                        super.init(this.#is224, this.#sharedMemory);
                        this.update(this.#oKeyPad);
                        this.update(innerHash);
                        super.finalize();
                    }
                }
            };
            exports_43("HmacSha256", HmacSha256);
        }
    };
});
System.register("https://deno.land/std@0.57.0/encoding/utf8", [], function (exports_44, context_44) {
    "use strict";
    var encoder, decoder;
    var __moduleName = context_44 && context_44.id;
    /** Shorthand for new TextEncoder().encode() */
    function encode(input) {
        return encoder.encode(input);
    }
    exports_44("encode", encode);
    /** Shorthand for new TextDecoder().decode() */
    function decode(input) {
        return decoder.decode(input);
    }
    exports_44("decode", decode);
    return {
        setters: [],
        execute: function () {
            /** A default TextEncoder instance */
            exports_44("encoder", encoder = new TextEncoder());
            /** A default TextDecoder instance */
            exports_44("decoder", decoder = new TextDecoder());
        }
    };
});
// Based on https://github.com/golang/go/blob/891682/src/bufio/bufio.go
// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
System.register("https://deno.land/std@0.57.0/io/bufio", ["https://deno.land/std@0.57.0/io/util", "https://deno.land/std@0.57.0/_util/assert"], function (exports_45, context_45) {
    "use strict";
    var util_ts_2, assert_ts_8, DEFAULT_BUF_SIZE, MIN_BUF_SIZE, MAX_CONSECUTIVE_EMPTY_READS, CR, LF, BufferFullError, PartialReadError, BufReader, AbstractBufBase, BufWriter, BufWriterSync;
    var __moduleName = context_45 && context_45.id;
    /** Generate longest proper prefix which is also suffix array. */
    function createLPS(pat) {
        const lps = new Uint8Array(pat.length);
        lps[0] = 0;
        let prefixEnd = 0;
        let i = 1;
        while (i < lps.length) {
            if (pat[i] == pat[prefixEnd]) {
                prefixEnd++;
                lps[i] = prefixEnd;
                i++;
            }
            else if (prefixEnd === 0) {
                lps[i] = 0;
                i++;
            }
            else {
                prefixEnd = pat[prefixEnd - 1];
            }
        }
        return lps;
    }
    /** Read delimited bytes from a Reader. */
    async function* readDelim(reader, delim) {
        // Avoid unicode problems
        const delimLen = delim.length;
        const delimLPS = createLPS(delim);
        let inputBuffer = new Deno.Buffer();
        const inspectArr = new Uint8Array(Math.max(1024, delimLen + 1));
        // Modified KMP
        let inspectIndex = 0;
        let matchIndex = 0;
        while (true) {
            const result = await reader.read(inspectArr);
            if (result === null) {
                // Yield last chunk.
                yield inputBuffer.bytes();
                return;
            }
            if (result < 0) {
                // Discard all remaining and silently fail.
                return;
            }
            const sliceRead = inspectArr.subarray(0, result);
            await Deno.writeAll(inputBuffer, sliceRead);
            let sliceToProcess = inputBuffer.bytes();
            while (inspectIndex < sliceToProcess.length) {
                if (sliceToProcess[inspectIndex] === delim[matchIndex]) {
                    inspectIndex++;
                    matchIndex++;
                    if (matchIndex === delimLen) {
                        // Full match
                        const matchEnd = inspectIndex - delimLen;
                        const readyBytes = sliceToProcess.subarray(0, matchEnd);
                        // Copy
                        const pendingBytes = sliceToProcess.slice(inspectIndex);
                        yield readyBytes;
                        // Reset match, different from KMP.
                        sliceToProcess = pendingBytes;
                        inspectIndex = 0;
                        matchIndex = 0;
                    }
                }
                else {
                    if (matchIndex === 0) {
                        inspectIndex++;
                    }
                    else {
                        matchIndex = delimLPS[matchIndex - 1];
                    }
                }
            }
            // Keep inspectIndex and matchIndex.
            inputBuffer = new Deno.Buffer(sliceToProcess);
        }
    }
    exports_45("readDelim", readDelim);
    /** Read delimited strings from a Reader. */
    async function* readStringDelim(reader, delim) {
        const encoder = new TextEncoder();
        const decoder = new TextDecoder();
        for await (const chunk of readDelim(reader, encoder.encode(delim))) {
            yield decoder.decode(chunk);
        }
    }
    exports_45("readStringDelim", readStringDelim);
    /** Read strings line-by-line from a Reader. */
    // eslint-disable-next-line require-await
    async function* readLines(reader) {
        yield* readStringDelim(reader, "\n");
    }
    exports_45("readLines", readLines);
    return {
        setters: [
            function (util_ts_2_1) {
                util_ts_2 = util_ts_2_1;
            },
            function (assert_ts_8_1) {
                assert_ts_8 = assert_ts_8_1;
            }
        ],
        execute: function () {
            DEFAULT_BUF_SIZE = 4096;
            MIN_BUF_SIZE = 16;
            MAX_CONSECUTIVE_EMPTY_READS = 100;
            CR = util_ts_2.charCode("\r");
            LF = util_ts_2.charCode("\n");
            BufferFullError = class BufferFullError extends Error {
                constructor(partial) {
                    super("Buffer full");
                    this.partial = partial;
                    this.name = "BufferFullError";
                }
            };
            exports_45("BufferFullError", BufferFullError);
            PartialReadError = class PartialReadError extends Deno.errors.UnexpectedEof {
                constructor() {
                    super("Encountered UnexpectedEof, data only partially read");
                    this.name = "PartialReadError";
                }
            };
            exports_45("PartialReadError", PartialReadError);
            /** BufReader implements buffering for a Reader object. */
            BufReader = class BufReader {
                constructor(rd, size = DEFAULT_BUF_SIZE) {
                    this.r = 0; // buf read position.
                    this.w = 0; // buf write position.
                    this.eof = false;
                    if (size < MIN_BUF_SIZE) {
                        size = MIN_BUF_SIZE;
                    }
                    this._reset(new Uint8Array(size), rd);
                }
                // private lastByte: number;
                // private lastCharSize: number;
                /** return new BufReader unless r is BufReader */
                static create(r, size = DEFAULT_BUF_SIZE) {
                    return r instanceof BufReader ? r : new BufReader(r, size);
                }
                /** Returns the size of the underlying buffer in bytes. */
                size() {
                    return this.buf.byteLength;
                }
                buffered() {
                    return this.w - this.r;
                }
                // Reads a new chunk into the buffer.
                async _fill() {
                    // Slide existing data to beginning.
                    if (this.r > 0) {
                        this.buf.copyWithin(0, this.r, this.w);
                        this.w -= this.r;
                        this.r = 0;
                    }
                    if (this.w >= this.buf.byteLength) {
                        throw Error("bufio: tried to fill full buffer");
                    }
                    // Read new data: try a limited number of times.
                    for (let i = MAX_CONSECUTIVE_EMPTY_READS; i > 0; i--) {
                        const rr = await this.rd.read(this.buf.subarray(this.w));
                        if (rr === null) {
                            this.eof = true;
                            return;
                        }
                        assert_ts_8.assert(rr >= 0, "negative read");
                        this.w += rr;
                        if (rr > 0) {
                            return;
                        }
                    }
                    throw new Error(`No progress after ${MAX_CONSECUTIVE_EMPTY_READS} read() calls`);
                }
                /** Discards any buffered data, resets all state, and switches
                 * the buffered reader to read from r.
                 */
                reset(r) {
                    this._reset(this.buf, r);
                }
                _reset(buf, rd) {
                    this.buf = buf;
                    this.rd = rd;
                    this.eof = false;
                    // this.lastByte = -1;
                    // this.lastCharSize = -1;
                }
                /** reads data into p.
                 * It returns the number of bytes read into p.
                 * The bytes are taken from at most one Read on the underlying Reader,
                 * hence n may be less than len(p).
                 * To read exactly len(p) bytes, use io.ReadFull(b, p).
                 */
                async read(p) {
                    let rr = p.byteLength;
                    if (p.byteLength === 0)
                        return rr;
                    if (this.r === this.w) {
                        if (p.byteLength >= this.buf.byteLength) {
                            // Large read, empty buffer.
                            // Read directly into p to avoid copy.
                            const rr = await this.rd.read(p);
                            const nread = rr ?? 0;
                            assert_ts_8.assert(nread >= 0, "negative read");
                            // if (rr.nread > 0) {
                            //   this.lastByte = p[rr.nread - 1];
                            //   this.lastCharSize = -1;
                            // }
                            return rr;
                        }
                        // One read.
                        // Do not use this.fill, which will loop.
                        this.r = 0;
                        this.w = 0;
                        rr = await this.rd.read(this.buf);
                        if (rr === 0 || rr === null)
                            return rr;
                        assert_ts_8.assert(rr >= 0, "negative read");
                        this.w += rr;
                    }
                    // copy as much as we can
                    const copied = util_ts_2.copyBytes(this.buf.subarray(this.r, this.w), p, 0);
                    this.r += copied;
                    // this.lastByte = this.buf[this.r - 1];
                    // this.lastCharSize = -1;
                    return copied;
                }
                /** reads exactly `p.length` bytes into `p`.
                 *
                 * If successful, `p` is returned.
                 *
                 * If the end of the underlying stream has been reached, and there are no more
                 * bytes available in the buffer, `readFull()` returns `null` instead.
                 *
                 * An error is thrown if some bytes could be read, but not enough to fill `p`
                 * entirely before the underlying stream reported an error or EOF. Any error
                 * thrown will have a `partial` property that indicates the slice of the
                 * buffer that has been successfully filled with data.
                 *
                 * Ported from https://golang.org/pkg/io/#ReadFull
                 */
                async readFull(p) {
                    let bytesRead = 0;
                    while (bytesRead < p.length) {
                        try {
                            const rr = await this.read(p.subarray(bytesRead));
                            if (rr === null) {
                                if (bytesRead === 0) {
                                    return null;
                                }
                                else {
                                    throw new PartialReadError();
                                }
                            }
                            bytesRead += rr;
                        }
                        catch (err) {
                            err.partial = p.subarray(0, bytesRead);
                            throw err;
                        }
                    }
                    return p;
                }
                /** Returns the next byte [0, 255] or `null`. */
                async readByte() {
                    while (this.r === this.w) {
                        if (this.eof)
                            return null;
                        await this._fill(); // buffer is empty.
                    }
                    const c = this.buf[this.r];
                    this.r++;
                    // this.lastByte = c;
                    return c;
                }
                /** readString() reads until the first occurrence of delim in the input,
                 * returning a string containing the data up to and including the delimiter.
                 * If ReadString encounters an error before finding a delimiter,
                 * it returns the data read before the error and the error itself
                 * (often `null`).
                 * ReadString returns err != nil if and only if the returned data does not end
                 * in delim.
                 * For simple uses, a Scanner may be more convenient.
                 */
                async readString(delim) {
                    if (delim.length !== 1) {
                        throw new Error("Delimiter should be a single character");
                    }
                    const buffer = await this.readSlice(delim.charCodeAt(0));
                    if (buffer === null)
                        return null;
                    return new TextDecoder().decode(buffer);
                }
                /** `readLine()` is a low-level line-reading primitive. Most callers should
                 * use `readString('\n')` instead or use a Scanner.
                 *
                 * `readLine()` tries to return a single line, not including the end-of-line
                 * bytes. If the line was too long for the buffer then `more` is set and the
                 * beginning of the line is returned. The rest of the line will be returned
                 * from future calls. `more` will be false when returning the last fragment
                 * of the line. The returned buffer is only valid until the next call to
                 * `readLine()`.
                 *
                 * The text returned from ReadLine does not include the line end ("\r\n" or
                 * "\n").
                 *
                 * When the end of the underlying stream is reached, the final bytes in the
                 * stream are returned. No indication or error is given if the input ends
                 * without a final line end. When there are no more trailing bytes to read,
                 * `readLine()` returns `null`.
                 *
                 * Calling `unreadByte()` after `readLine()` will always unread the last byte
                 * read (possibly a character belonging to the line end) even if that byte is
                 * not part of the line returned by `readLine()`.
                 */
                async readLine() {
                    let line;
                    try {
                        line = await this.readSlice(LF);
                    }
                    catch (err) {
                        let { partial } = err;
                        assert_ts_8.assert(partial instanceof Uint8Array, "bufio: caught error from `readSlice()` without `partial` property");
                        // Don't throw if `readSlice()` failed with `BufferFullError`, instead we
                        // just return whatever is available and set the `more` flag.
                        if (!(err instanceof BufferFullError)) {
                            throw err;
                        }
                        // Handle the case where "\r\n" straddles the buffer.
                        if (!this.eof &&
                            partial.byteLength > 0 &&
                            partial[partial.byteLength - 1] === CR) {
                            // Put the '\r' back on buf and drop it from line.
                            // Let the next call to ReadLine check for "\r\n".
                            assert_ts_8.assert(this.r > 0, "bufio: tried to rewind past start of buffer");
                            this.r--;
                            partial = partial.subarray(0, partial.byteLength - 1);
                        }
                        return { line: partial, more: !this.eof };
                    }
                    if (line === null) {
                        return null;
                    }
                    if (line.byteLength === 0) {
                        return { line, more: false };
                    }
                    if (line[line.byteLength - 1] == LF) {
                        let drop = 1;
                        if (line.byteLength > 1 && line[line.byteLength - 2] === CR) {
                            drop = 2;
                        }
                        line = line.subarray(0, line.byteLength - drop);
                    }
                    return { line, more: false };
                }
                /** `readSlice()` reads until the first occurrence of `delim` in the input,
                 * returning a slice pointing at the bytes in the buffer. The bytes stop
                 * being valid at the next read.
                 *
                 * If `readSlice()` encounters an error before finding a delimiter, or the
                 * buffer fills without finding a delimiter, it throws an error with a
                 * `partial` property that contains the entire buffer.
                 *
                 * If `readSlice()` encounters the end of the underlying stream and there are
                 * any bytes left in the buffer, the rest of the buffer is returned. In other
                 * words, EOF is always treated as a delimiter. Once the buffer is empty,
                 * it returns `null`.
                 *
                 * Because the data returned from `readSlice()` will be overwritten by the
                 * next I/O operation, most clients should use `readString()` instead.
                 */
                async readSlice(delim) {
                    let s = 0; // search start index
                    let slice;
                    while (true) {
                        // Search buffer.
                        let i = this.buf.subarray(this.r + s, this.w).indexOf(delim);
                        if (i >= 0) {
                            i += s;
                            slice = this.buf.subarray(this.r, this.r + i + 1);
                            this.r += i + 1;
                            break;
                        }
                        // EOF?
                        if (this.eof) {
                            if (this.r === this.w) {
                                return null;
                            }
                            slice = this.buf.subarray(this.r, this.w);
                            this.r = this.w;
                            break;
                        }
                        // Buffer full?
                        if (this.buffered() >= this.buf.byteLength) {
                            this.r = this.w;
                            // #4521 The internal buffer should not be reused across reads because it causes corruption of data.
                            const oldbuf = this.buf;
                            const newbuf = this.buf.slice(0);
                            this.buf = newbuf;
                            throw new BufferFullError(oldbuf);
                        }
                        s = this.w - this.r; // do not rescan area we scanned before
                        // Buffer is not full.
                        try {
                            await this._fill();
                        }
                        catch (err) {
                            err.partial = slice;
                            throw err;
                        }
                    }
                    // Handle last byte, if any.
                    // const i = slice.byteLength - 1;
                    // if (i >= 0) {
                    //   this.lastByte = slice[i];
                    //   this.lastCharSize = -1
                    // }
                    return slice;
                }
                /** `peek()` returns the next `n` bytes without advancing the reader. The
                 * bytes stop being valid at the next read call.
                 *
                 * When the end of the underlying stream is reached, but there are unread
                 * bytes left in the buffer, those bytes are returned. If there are no bytes
                 * left in the buffer, it returns `null`.
                 *
                 * If an error is encountered before `n` bytes are available, `peek()` throws
                 * an error with the `partial` property set to a slice of the buffer that
                 * contains the bytes that were available before the error occurred.
                 */
                async peek(n) {
                    if (n < 0) {
                        throw Error("negative count");
                    }
                    let avail = this.w - this.r;
                    while (avail < n && avail < this.buf.byteLength && !this.eof) {
                        try {
                            await this._fill();
                        }
                        catch (err) {
                            err.partial = this.buf.subarray(this.r, this.w);
                            throw err;
                        }
                        avail = this.w - this.r;
                    }
                    if (avail === 0 && this.eof) {
                        return null;
                    }
                    else if (avail < n && this.eof) {
                        return this.buf.subarray(this.r, this.r + avail);
                    }
                    else if (avail < n) {
                        throw new BufferFullError(this.buf.subarray(this.r, this.w));
                    }
                    return this.buf.subarray(this.r, this.r + n);
                }
            };
            exports_45("BufReader", BufReader);
            AbstractBufBase = class AbstractBufBase {
                constructor() {
                    this.usedBufferBytes = 0;
                    this.err = null;
                }
                /** Size returns the size of the underlying buffer in bytes. */
                size() {
                    return this.buf.byteLength;
                }
                /** Returns how many bytes are unused in the buffer. */
                available() {
                    return this.buf.byteLength - this.usedBufferBytes;
                }
                /** buffered returns the number of bytes that have been written into the
                 * current buffer.
                 */
                buffered() {
                    return this.usedBufferBytes;
                }
                checkBytesWritten(numBytesWritten) {
                    if (numBytesWritten < this.usedBufferBytes) {
                        if (numBytesWritten > 0) {
                            this.buf.copyWithin(0, numBytesWritten, this.usedBufferBytes);
                            this.usedBufferBytes -= numBytesWritten;
                        }
                        this.err = new Error("Short write");
                        throw this.err;
                    }
                }
            };
            /** BufWriter implements buffering for an deno.Writer object.
             * If an error occurs writing to a Writer, no more data will be
             * accepted and all subsequent writes, and flush(), will return the error.
             * After all data has been written, the client should call the
             * flush() method to guarantee all data has been forwarded to
             * the underlying deno.Writer.
             */
            BufWriter = class BufWriter extends AbstractBufBase {
                constructor(writer, size = DEFAULT_BUF_SIZE) {
                    super();
                    this.writer = writer;
                    if (size <= 0) {
                        size = DEFAULT_BUF_SIZE;
                    }
                    this.buf = new Uint8Array(size);
                }
                /** return new BufWriter unless writer is BufWriter */
                static create(writer, size = DEFAULT_BUF_SIZE) {
                    return writer instanceof BufWriter ? writer : new BufWriter(writer, size);
                }
                /** Discards any unflushed buffered data, clears any error, and
                 * resets buffer to write its output to w.
                 */
                reset(w) {
                    this.err = null;
                    this.usedBufferBytes = 0;
                    this.writer = w;
                }
                /** Flush writes any buffered data to the underlying io.Writer. */
                async flush() {
                    if (this.err !== null)
                        throw this.err;
                    if (this.usedBufferBytes === 0)
                        return;
                    let numBytesWritten = 0;
                    try {
                        numBytesWritten = await this.writer.write(this.buf.subarray(0, this.usedBufferBytes));
                    }
                    catch (e) {
                        this.err = e;
                        throw e;
                    }
                    this.checkBytesWritten(numBytesWritten);
                    this.usedBufferBytes = 0;
                }
                /** Writes the contents of `data` into the buffer.  If the contents won't fully
                 * fit into the buffer, those bytes that can are copied into the buffer, the
                 * buffer is the flushed to the writer and the remaining bytes are copied into
                 * the now empty buffer.
                 *
                 * @return the number of bytes written to the buffer.
                 */
                async write(data) {
                    if (this.err !== null)
                        throw this.err;
                    if (data.length === 0)
                        return 0;
                    let totalBytesWritten = 0;
                    let numBytesWritten = 0;
                    while (data.byteLength > this.available()) {
                        if (this.buffered() === 0) {
                            // Large write, empty buffer.
                            // Write directly from data to avoid copy.
                            try {
                                numBytesWritten = await this.writer.write(data);
                            }
                            catch (e) {
                                this.err = e;
                                throw e;
                            }
                        }
                        else {
                            numBytesWritten = util_ts_2.copyBytes(data, this.buf, this.usedBufferBytes);
                            this.usedBufferBytes += numBytesWritten;
                            await this.flush();
                        }
                        totalBytesWritten += numBytesWritten;
                        data = data.subarray(numBytesWritten);
                    }
                    numBytesWritten = util_ts_2.copyBytes(data, this.buf, this.usedBufferBytes);
                    this.usedBufferBytes += numBytesWritten;
                    totalBytesWritten += numBytesWritten;
                    return totalBytesWritten;
                }
            };
            exports_45("BufWriter", BufWriter);
            /** BufWriterSync implements buffering for a deno.WriterSync object.
             * If an error occurs writing to a WriterSync, no more data will be
             * accepted and all subsequent writes, and flush(), will return the error.
             * After all data has been written, the client should call the
             * flush() method to guarantee all data has been forwarded to
             * the underlying deno.WriterSync.
             */
            BufWriterSync = class BufWriterSync extends AbstractBufBase {
                constructor(writer, size = DEFAULT_BUF_SIZE) {
                    super();
                    this.writer = writer;
                    if (size <= 0) {
                        size = DEFAULT_BUF_SIZE;
                    }
                    this.buf = new Uint8Array(size);
                }
                /** return new BufWriterSync unless writer is BufWriterSync */
                static create(writer, size = DEFAULT_BUF_SIZE) {
                    return writer instanceof BufWriterSync
                        ? writer
                        : new BufWriterSync(writer, size);
                }
                /** Discards any unflushed buffered data, clears any error, and
                 * resets buffer to write its output to w.
                 */
                reset(w) {
                    this.err = null;
                    this.usedBufferBytes = 0;
                    this.writer = w;
                }
                /** Flush writes any buffered data to the underlying io.WriterSync. */
                flush() {
                    if (this.err !== null)
                        throw this.err;
                    if (this.usedBufferBytes === 0)
                        return;
                    let numBytesWritten = 0;
                    try {
                        numBytesWritten = this.writer.writeSync(this.buf.subarray(0, this.usedBufferBytes));
                    }
                    catch (e) {
                        this.err = e;
                        throw e;
                    }
                    this.checkBytesWritten(numBytesWritten);
                    this.usedBufferBytes = 0;
                }
                /** Writes the contents of `data` into the buffer.  If the contents won't fully
                 * fit into the buffer, those bytes that can are copied into the buffer, the
                 * buffer is the flushed to the writer and the remaining bytes are copied into
                 * the now empty buffer.
                 *
                 * @return the number of bytes written to the buffer.
                 */
                writeSync(data) {
                    if (this.err !== null)
                        throw this.err;
                    if (data.length === 0)
                        return 0;
                    let totalBytesWritten = 0;
                    let numBytesWritten = 0;
                    while (data.byteLength > this.available()) {
                        if (this.buffered() === 0) {
                            // Large write, empty buffer.
                            // Write directly from data to avoid copy.
                            try {
                                numBytesWritten = this.writer.writeSync(data);
                            }
                            catch (e) {
                                this.err = e;
                                throw e;
                            }
                        }
                        else {
                            numBytesWritten = util_ts_2.copyBytes(data, this.buf, this.usedBufferBytes);
                            this.usedBufferBytes += numBytesWritten;
                            this.flush();
                        }
                        totalBytesWritten += numBytesWritten;
                        data = data.subarray(numBytesWritten);
                    }
                    numBytesWritten = util_ts_2.copyBytes(data, this.buf, this.usedBufferBytes);
                    this.usedBufferBytes += numBytesWritten;
                    totalBytesWritten += numBytesWritten;
                    return totalBytesWritten;
                }
            };
            exports_45("BufWriterSync", BufWriterSync);
        }
    };
});
System.register("https://deno.land/std@0.57.0/async/deferred", [], function (exports_46, context_46) {
    "use strict";
    var __moduleName = context_46 && context_46.id;
    /** Creates a Promise with the `reject` and `resolve` functions
     * placed as methods on the promise object itself. It allows you to do:
     *
     *     const p = deferred<number>();
     *     // ...
     *     p.resolve(42);
     */
    function deferred() {
        let methods;
        const promise = new Promise((resolve, reject) => {
            methods = { resolve, reject };
        });
        return Object.assign(promise, methods);
    }
    exports_46("deferred", deferred);
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@0.57.0/async/delay", [], function (exports_47, context_47) {
    "use strict";
    var __moduleName = context_47 && context_47.id;
    // Copyright 2018-2020 the Deno authors. All rights reserved. MIT license.
    /* Resolves after the given number of milliseconds. */
    function delay(ms) {
        return new Promise((res) => setTimeout(() => {
            res();
        }, ms));
    }
    exports_47("delay", delay);
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@0.57.0/async/mux_async_iterator", ["https://deno.land/std@0.57.0/async/deferred"], function (exports_48, context_48) {
    "use strict";
    var deferred_ts_1, MuxAsyncIterator;
    var __moduleName = context_48 && context_48.id;
    return {
        setters: [
            function (deferred_ts_1_1) {
                deferred_ts_1 = deferred_ts_1_1;
            }
        ],
        execute: function () {
            /** The MuxAsyncIterator class multiplexes multiple async iterators into a
             * single stream. It currently makes a few assumptions:
             * - The iterators do not throw.
             * - The final result (the value returned and not yielded from the iterator)
             *   does not matter; if there is any, it is discarded.
             */
            MuxAsyncIterator = class MuxAsyncIterator {
                constructor() {
                    this.iteratorCount = 0;
                    this.yields = [];
                    this.signal = deferred_ts_1.deferred();
                }
                add(iterator) {
                    ++this.iteratorCount;
                    this.callIteratorNext(iterator);
                }
                async callIteratorNext(iterator) {
                    const { value, done } = await iterator.next();
                    if (done) {
                        --this.iteratorCount;
                    }
                    else {
                        this.yields.push({ iterator, value });
                    }
                    this.signal.resolve();
                }
                async *iterate() {
                    while (this.iteratorCount > 0) {
                        // Sleep until any of the wrapped iterators yields.
                        await this.signal;
                        // Note that while we're looping over `yields`, new items may be added.
                        for (let i = 0; i < this.yields.length; i++) {
                            const { iterator, value } = this.yields[i];
                            yield value;
                            this.callIteratorNext(iterator);
                        }
                        // Clear the `yields` list and reset the `signal` promise.
                        this.yields.length = 0;
                        this.signal = deferred_ts_1.deferred();
                    }
                }
                [Symbol.asyncIterator]() {
                    return this.iterate();
                }
            };
            exports_48("MuxAsyncIterator", MuxAsyncIterator);
        }
    };
});
System.register("https://deno.land/std@0.57.0/async/mod", ["https://deno.land/std@0.57.0/async/deferred", "https://deno.land/std@0.57.0/async/delay", "https://deno.land/std@0.57.0/async/mux_async_iterator"], function (exports_49, context_49) {
    "use strict";
    var __moduleName = context_49 && context_49.id;
    function exportStar_4(m) {
        var exports = {};
        for (var n in m) {
            if (n !== "default") exports[n] = m[n];
        }
        exports_49(exports);
    }
    return {
        setters: [
            function (deferred_ts_2_1) {
                exportStar_4(deferred_ts_2_1);
            },
            function (delay_ts_1_1) {
                exportStar_4(delay_ts_1_1);
            },
            function (mux_async_iterator_ts_1_1) {
                exportStar_4(mux_async_iterator_ts_1_1);
            }
        ],
        execute: function () {
        }
    };
});
// Based on https://github.com/golang/go/tree/master/src/net/textproto
// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
System.register("https://deno.land/std@0.57.0/textproto/mod", ["https://deno.land/std@0.57.0/io/util", "https://deno.land/std@0.57.0/bytes/mod", "https://deno.land/std@0.57.0/encoding/utf8"], function (exports_50, context_50) {
    "use strict";
    var util_ts_3, mod_ts_6, utf8_ts_1, invalidHeaderCharRegex, TextProtoReader;
    var __moduleName = context_50 && context_50.id;
    function str(buf) {
        if (buf == null) {
            return "";
        }
        else {
            return utf8_ts_1.decode(buf);
        }
    }
    return {
        setters: [
            function (util_ts_3_1) {
                util_ts_3 = util_ts_3_1;
            },
            function (mod_ts_6_1) {
                mod_ts_6 = mod_ts_6_1;
            },
            function (utf8_ts_1_1) {
                utf8_ts_1 = utf8_ts_1_1;
            }
        ],
        execute: function () {
            // FROM https://github.com/denoland/deno/blob/b34628a26ab0187a827aa4ebe256e23178e25d39/cli/js/web/headers.ts#L9
            invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/g;
            TextProtoReader = class TextProtoReader {
                constructor(r) {
                    this.r = r;
                }
                /** readLine() reads a single line from the TextProtoReader,
                 * eliding the final \n or \r\n from the returned string.
                 */
                async readLine() {
                    const s = await this.readLineSlice();
                    if (s === null)
                        return null;
                    return str(s);
                }
                /** ReadMIMEHeader reads a MIME-style header from r.
                 * The header is a sequence of possibly continued Key: Value lines
                 * ending in a blank line.
                 * The returned map m maps CanonicalMIMEHeaderKey(key) to a
                 * sequence of values in the same order encountered in the input.
                 *
                 * For example, consider this input:
                 *
                 *	My-Key: Value 1
                 *	Long-Key: Even
                 *	       Longer Value
                 *	My-Key: Value 2
                 *
                 * Given that input, ReadMIMEHeader returns the map:
                 *
                 *	map[string][]string{
                 *		"My-Key": {"Value 1", "Value 2"},
                 *		"Long-Key": {"Even Longer Value"},
                 *	}
                 */
                async readMIMEHeader() {
                    const m = new Headers();
                    let line;
                    // The first line cannot start with a leading space.
                    let buf = await this.r.peek(1);
                    if (buf === null) {
                        return null;
                    }
                    else if (buf[0] == util_ts_3.charCode(" ") || buf[0] == util_ts_3.charCode("\t")) {
                        line = (await this.readLineSlice());
                    }
                    buf = await this.r.peek(1);
                    if (buf === null) {
                        throw new Deno.errors.UnexpectedEof();
                    }
                    else if (buf[0] == util_ts_3.charCode(" ") || buf[0] == util_ts_3.charCode("\t")) {
                        throw new Deno.errors.InvalidData(`malformed MIME header initial line: ${str(line)}`);
                    }
                    while (true) {
                        const kv = await this.readLineSlice(); // readContinuedLineSlice
                        if (kv === null)
                            throw new Deno.errors.UnexpectedEof();
                        if (kv.byteLength === 0)
                            return m;
                        // Key ends at first colon
                        let i = kv.indexOf(util_ts_3.charCode(":"));
                        if (i < 0) {
                            throw new Deno.errors.InvalidData(`malformed MIME header line: ${str(kv)}`);
                        }
                        //let key = canonicalMIMEHeaderKey(kv.subarray(0, endKey));
                        const key = str(kv.subarray(0, i));
                        // As per RFC 7230 field-name is a token,
                        // tokens consist of one or more chars.
                        // We could throw `Deno.errors.InvalidData` here,
                        // but better to be liberal in what we
                        // accept, so if we get an empty key, skip it.
                        if (key == "") {
                            continue;
                        }
                        // Skip initial spaces in value.
                        i++; // skip colon
                        while (i < kv.byteLength &&
                            (kv[i] == util_ts_3.charCode(" ") || kv[i] == util_ts_3.charCode("\t"))) {
                            i++;
                        }
                        const value = str(kv.subarray(i)).replace(invalidHeaderCharRegex, encodeURI);
                        // In case of invalid header we swallow the error
                        // example: "Audio Mode" => invalid due to space in the key
                        try {
                            m.append(key, value);
                        }
                        catch {
                            // Pass
                        }
                    }
                }
                async readLineSlice() {
                    // this.closeDot();
                    let line;
                    while (true) {
                        const r = await this.r.readLine();
                        if (r === null)
                            return null;
                        const { line: l, more } = r;
                        // Avoid the copy if the first call produced a full line.
                        if (!line && !more) {
                            // TODO(ry):
                            // This skipSpace() is definitely misplaced, but I don't know where it
                            // comes from nor how to fix it.
                            if (this.skipSpace(l) === 0) {
                                return new Uint8Array(0);
                            }
                            return l;
                        }
                        line = line ? mod_ts_6.concat(line, l) : l;
                        if (!more) {
                            break;
                        }
                    }
                    return line;
                }
                skipSpace(l) {
                    let n = 0;
                    for (let i = 0; i < l.length; i++) {
                        if (l[i] === util_ts_3.charCode(" ") || l[i] === util_ts_3.charCode("\t")) {
                            continue;
                        }
                        n++;
                    }
                    return n;
                }
            };
            exports_50("TextProtoReader", TextProtoReader);
        }
    };
});
// Copyright 2018-2020 the Deno authors. All rights reserved. MIT license.
System.register("https://deno.land/std@0.57.0/http/http_status", [], function (exports_51, context_51) {
    "use strict";
    var Status, STATUS_TEXT;
    var __moduleName = context_51 && context_51.id;
    return {
        setters: [],
        execute: function () {
            /** HTTP status codes */
            (function (Status) {
                /** RFC 7231, 6.2.1 */
                Status[Status["Continue"] = 100] = "Continue";
                /** RFC 7231, 6.2.2 */
                Status[Status["SwitchingProtocols"] = 101] = "SwitchingProtocols";
                /** RFC 2518, 10.1 */
                Status[Status["Processing"] = 102] = "Processing";
                /** RFC 8297 **/
                Status[Status["EarlyHints"] = 103] = "EarlyHints";
                /** RFC 7231, 6.3.1 */
                Status[Status["OK"] = 200] = "OK";
                /** RFC 7231, 6.3.2 */
                Status[Status["Created"] = 201] = "Created";
                /** RFC 7231, 6.3.3 */
                Status[Status["Accepted"] = 202] = "Accepted";
                /** RFC 7231, 6.3.4 */
                Status[Status["NonAuthoritativeInfo"] = 203] = "NonAuthoritativeInfo";
                /** RFC 7231, 6.3.5 */
                Status[Status["NoContent"] = 204] = "NoContent";
                /** RFC 7231, 6.3.6 */
                Status[Status["ResetContent"] = 205] = "ResetContent";
                /** RFC 7233, 4.1 */
                Status[Status["PartialContent"] = 206] = "PartialContent";
                /** RFC 4918, 11.1 */
                Status[Status["MultiStatus"] = 207] = "MultiStatus";
                /** RFC 5842, 7.1 */
                Status[Status["AlreadyReported"] = 208] = "AlreadyReported";
                /** RFC 3229, 10.4.1 */
                Status[Status["IMUsed"] = 226] = "IMUsed";
                /** RFC 7231, 6.4.1 */
                Status[Status["MultipleChoices"] = 300] = "MultipleChoices";
                /** RFC 7231, 6.4.2 */
                Status[Status["MovedPermanently"] = 301] = "MovedPermanently";
                /** RFC 7231, 6.4.3 */
                Status[Status["Found"] = 302] = "Found";
                /** RFC 7231, 6.4.4 */
                Status[Status["SeeOther"] = 303] = "SeeOther";
                /** RFC 7232, 4.1 */
                Status[Status["NotModified"] = 304] = "NotModified";
                /** RFC 7231, 6.4.5 */
                Status[Status["UseProxy"] = 305] = "UseProxy";
                /** RFC 7231, 6.4.7 */
                Status[Status["TemporaryRedirect"] = 307] = "TemporaryRedirect";
                /** RFC 7538, 3 */
                Status[Status["PermanentRedirect"] = 308] = "PermanentRedirect";
                /** RFC 7231, 6.5.1 */
                Status[Status["BadRequest"] = 400] = "BadRequest";
                /** RFC 7235, 3.1 */
                Status[Status["Unauthorized"] = 401] = "Unauthorized";
                /** RFC 7231, 6.5.2 */
                Status[Status["PaymentRequired"] = 402] = "PaymentRequired";
                /** RFC 7231, 6.5.3 */
                Status[Status["Forbidden"] = 403] = "Forbidden";
                /** RFC 7231, 6.5.4 */
                Status[Status["NotFound"] = 404] = "NotFound";
                /** RFC 7231, 6.5.5 */
                Status[Status["MethodNotAllowed"] = 405] = "MethodNotAllowed";
                /** RFC 7231, 6.5.6 */
                Status[Status["NotAcceptable"] = 406] = "NotAcceptable";
                /** RFC 7235, 3.2 */
                Status[Status["ProxyAuthRequired"] = 407] = "ProxyAuthRequired";
                /** RFC 7231, 6.5.7 */
                Status[Status["RequestTimeout"] = 408] = "RequestTimeout";
                /** RFC 7231, 6.5.8 */
                Status[Status["Conflict"] = 409] = "Conflict";
                /** RFC 7231, 6.5.9 */
                Status[Status["Gone"] = 410] = "Gone";
                /** RFC 7231, 6.5.10 */
                Status[Status["LengthRequired"] = 411] = "LengthRequired";
                /** RFC 7232, 4.2 */
                Status[Status["PreconditionFailed"] = 412] = "PreconditionFailed";
                /** RFC 7231, 6.5.11 */
                Status[Status["RequestEntityTooLarge"] = 413] = "RequestEntityTooLarge";
                /** RFC 7231, 6.5.12 */
                Status[Status["RequestURITooLong"] = 414] = "RequestURITooLong";
                /** RFC 7231, 6.5.13 */
                Status[Status["UnsupportedMediaType"] = 415] = "UnsupportedMediaType";
                /** RFC 7233, 4.4 */
                Status[Status["RequestedRangeNotSatisfiable"] = 416] = "RequestedRangeNotSatisfiable";
                /** RFC 7231, 6.5.14 */
                Status[Status["ExpectationFailed"] = 417] = "ExpectationFailed";
                /** RFC 7168, 2.3.3 */
                Status[Status["Teapot"] = 418] = "Teapot";
                /** RFC 7540, 9.1.2 */
                Status[Status["MisdirectedRequest"] = 421] = "MisdirectedRequest";
                /** RFC 4918, 11.2 */
                Status[Status["UnprocessableEntity"] = 422] = "UnprocessableEntity";
                /** RFC 4918, 11.3 */
                Status[Status["Locked"] = 423] = "Locked";
                /** RFC 4918, 11.4 */
                Status[Status["FailedDependency"] = 424] = "FailedDependency";
                /** RFC 8470, 5.2 */
                Status[Status["TooEarly"] = 425] = "TooEarly";
                /** RFC 7231, 6.5.15 */
                Status[Status["UpgradeRequired"] = 426] = "UpgradeRequired";
                /** RFC 6585, 3 */
                Status[Status["PreconditionRequired"] = 428] = "PreconditionRequired";
                /** RFC 6585, 4 */
                Status[Status["TooManyRequests"] = 429] = "TooManyRequests";
                /** RFC 6585, 5 */
                Status[Status["RequestHeaderFieldsTooLarge"] = 431] = "RequestHeaderFieldsTooLarge";
                /** RFC 7725, 3 */
                Status[Status["UnavailableForLegalReasons"] = 451] = "UnavailableForLegalReasons";
                /** RFC 7231, 6.6.1 */
                Status[Status["InternalServerError"] = 500] = "InternalServerError";
                /** RFC 7231, 6.6.2 */
                Status[Status["NotImplemented"] = 501] = "NotImplemented";
                /** RFC 7231, 6.6.3 */
                Status[Status["BadGateway"] = 502] = "BadGateway";
                /** RFC 7231, 6.6.4 */
                Status[Status["ServiceUnavailable"] = 503] = "ServiceUnavailable";
                /** RFC 7231, 6.6.5 */
                Status[Status["GatewayTimeout"] = 504] = "GatewayTimeout";
                /** RFC 7231, 6.6.6 */
                Status[Status["HTTPVersionNotSupported"] = 505] = "HTTPVersionNotSupported";
                /** RFC 2295, 8.1 */
                Status[Status["VariantAlsoNegotiates"] = 506] = "VariantAlsoNegotiates";
                /** RFC 4918, 11.5 */
                Status[Status["InsufficientStorage"] = 507] = "InsufficientStorage";
                /** RFC 5842, 7.2 */
                Status[Status["LoopDetected"] = 508] = "LoopDetected";
                /** RFC 2774, 7 */
                Status[Status["NotExtended"] = 510] = "NotExtended";
                /** RFC 6585, 6 */
                Status[Status["NetworkAuthenticationRequired"] = 511] = "NetworkAuthenticationRequired";
            })(Status || (Status = {}));
            exports_51("Status", Status);
            exports_51("STATUS_TEXT", STATUS_TEXT = new Map([
                [Status.Continue, "Continue"],
                [Status.SwitchingProtocols, "Switching Protocols"],
                [Status.Processing, "Processing"],
                [Status.EarlyHints, "Early Hints"],
                [Status.OK, "OK"],
                [Status.Created, "Created"],
                [Status.Accepted, "Accepted"],
                [Status.NonAuthoritativeInfo, "Non-Authoritative Information"],
                [Status.NoContent, "No Content"],
                [Status.ResetContent, "Reset Content"],
                [Status.PartialContent, "Partial Content"],
                [Status.MultiStatus, "Multi-Status"],
                [Status.AlreadyReported, "Already Reported"],
                [Status.IMUsed, "IM Used"],
                [Status.MultipleChoices, "Multiple Choices"],
                [Status.MovedPermanently, "Moved Permanently"],
                [Status.Found, "Found"],
                [Status.SeeOther, "See Other"],
                [Status.NotModified, "Not Modified"],
                [Status.UseProxy, "Use Proxy"],
                [Status.TemporaryRedirect, "Temporary Redirect"],
                [Status.PermanentRedirect, "Permanent Redirect"],
                [Status.BadRequest, "Bad Request"],
                [Status.Unauthorized, "Unauthorized"],
                [Status.PaymentRequired, "Payment Required"],
                [Status.Forbidden, "Forbidden"],
                [Status.NotFound, "Not Found"],
                [Status.MethodNotAllowed, "Method Not Allowed"],
                [Status.NotAcceptable, "Not Acceptable"],
                [Status.ProxyAuthRequired, "Proxy Authentication Required"],
                [Status.RequestTimeout, "Request Timeout"],
                [Status.Conflict, "Conflict"],
                [Status.Gone, "Gone"],
                [Status.LengthRequired, "Length Required"],
                [Status.PreconditionFailed, "Precondition Failed"],
                [Status.RequestEntityTooLarge, "Request Entity Too Large"],
                [Status.RequestURITooLong, "Request URI Too Long"],
                [Status.UnsupportedMediaType, "Unsupported Media Type"],
                [Status.RequestedRangeNotSatisfiable, "Requested Range Not Satisfiable"],
                [Status.ExpectationFailed, "Expectation Failed"],
                [Status.Teapot, "I'm a teapot"],
                [Status.MisdirectedRequest, "Misdirected Request"],
                [Status.UnprocessableEntity, "Unprocessable Entity"],
                [Status.Locked, "Locked"],
                [Status.FailedDependency, "Failed Dependency"],
                [Status.TooEarly, "Too Early"],
                [Status.UpgradeRequired, "Upgrade Required"],
                [Status.PreconditionRequired, "Precondition Required"],
                [Status.TooManyRequests, "Too Many Requests"],
                [Status.RequestHeaderFieldsTooLarge, "Request Header Fields Too Large"],
                [Status.UnavailableForLegalReasons, "Unavailable For Legal Reasons"],
                [Status.InternalServerError, "Internal Server Error"],
                [Status.NotImplemented, "Not Implemented"],
                [Status.BadGateway, "Bad Gateway"],
                [Status.ServiceUnavailable, "Service Unavailable"],
                [Status.GatewayTimeout, "Gateway Timeout"],
                [Status.HTTPVersionNotSupported, "HTTP Version Not Supported"],
                [Status.VariantAlsoNegotiates, "Variant Also Negotiates"],
                [Status.InsufficientStorage, "Insufficient Storage"],
                [Status.LoopDetected, "Loop Detected"],
                [Status.NotExtended, "Not Extended"],
                [Status.NetworkAuthenticationRequired, "Network Authentication Required"],
            ]));
        }
    };
});
System.register("https://deno.land/std@0.57.0/http/_io", ["https://deno.land/std@0.57.0/io/bufio", "https://deno.land/std@0.57.0/textproto/mod", "https://deno.land/std@0.57.0/_util/assert", "https://deno.land/std@0.57.0/encoding/utf8", "https://deno.land/std@0.57.0/http/server", "https://deno.land/std@0.57.0/http/http_status"], function (exports_52, context_52) {
    "use strict";
    var bufio_ts_1, mod_ts_7, assert_ts_9, utf8_ts_2, server_ts_1, http_status_ts_1;
    var __moduleName = context_52 && context_52.id;
    function emptyReader() {
        return {
            read(_) {
                return Promise.resolve(null);
            },
        };
    }
    exports_52("emptyReader", emptyReader);
    function bodyReader(contentLength, r) {
        let totalRead = 0;
        let finished = false;
        async function read(buf) {
            if (finished)
                return null;
            let result;
            const remaining = contentLength - totalRead;
            if (remaining >= buf.byteLength) {
                result = await r.read(buf);
            }
            else {
                const readBuf = buf.subarray(0, remaining);
                result = await r.read(readBuf);
            }
            if (result !== null) {
                totalRead += result;
            }
            finished = totalRead === contentLength;
            return result;
        }
        return { read };
    }
    exports_52("bodyReader", bodyReader);
    function chunkedBodyReader(h, r) {
        // Based on https://tools.ietf.org/html/rfc2616#section-19.4.6
        const tp = new mod_ts_7.TextProtoReader(r);
        let finished = false;
        const chunks = [];
        async function read(buf) {
            if (finished)
                return null;
            const [chunk] = chunks;
            if (chunk) {
                const chunkRemaining = chunk.data.byteLength - chunk.offset;
                const readLength = Math.min(chunkRemaining, buf.byteLength);
                for (let i = 0; i < readLength; i++) {
                    buf[i] = chunk.data[chunk.offset + i];
                }
                chunk.offset += readLength;
                if (chunk.offset === chunk.data.byteLength) {
                    chunks.shift();
                    // Consume \r\n;
                    if ((await tp.readLine()) === null) {
                        throw new Deno.errors.UnexpectedEof();
                    }
                }
                return readLength;
            }
            const line = await tp.readLine();
            if (line === null)
                throw new Deno.errors.UnexpectedEof();
            // TODO: handle chunk extension
            const [chunkSizeString] = line.split(";");
            const chunkSize = parseInt(chunkSizeString, 16);
            if (Number.isNaN(chunkSize) || chunkSize < 0) {
                throw new Error("Invalid chunk size");
            }
            if (chunkSize > 0) {
                if (chunkSize > buf.byteLength) {
                    let eof = await r.readFull(buf);
                    if (eof === null) {
                        throw new Deno.errors.UnexpectedEof();
                    }
                    const restChunk = new Uint8Array(chunkSize - buf.byteLength);
                    eof = await r.readFull(restChunk);
                    if (eof === null) {
                        throw new Deno.errors.UnexpectedEof();
                    }
                    else {
                        chunks.push({
                            offset: 0,
                            data: restChunk,
                        });
                    }
                    return buf.byteLength;
                }
                else {
                    const bufToFill = buf.subarray(0, chunkSize);
                    const eof = await r.readFull(bufToFill);
                    if (eof === null) {
                        throw new Deno.errors.UnexpectedEof();
                    }
                    // Consume \r\n
                    if ((await tp.readLine()) === null) {
                        throw new Deno.errors.UnexpectedEof();
                    }
                    return chunkSize;
                }
            }
            else {
                assert_ts_9.assert(chunkSize === 0);
                // Consume \r\n
                if ((await r.readLine()) === null) {
                    throw new Deno.errors.UnexpectedEof();
                }
                await readTrailers(h, r);
                finished = true;
                return null;
            }
        }
        return { read };
    }
    exports_52("chunkedBodyReader", chunkedBodyReader);
    function isProhibidedForTrailer(key) {
        const s = new Set(["transfer-encoding", "content-length", "trailer"]);
        return s.has(key.toLowerCase());
    }
    /** Read trailer headers from reader and append values to headers. "trailer"
     * field will be deleted. */
    async function readTrailers(headers, r) {
        const trailers = parseTrailer(headers.get("trailer"));
        if (trailers == null)
            return;
        const trailerNames = [...trailers.keys()];
        const tp = new mod_ts_7.TextProtoReader(r);
        const result = await tp.readMIMEHeader();
        if (result == null) {
            throw new Deno.errors.InvalidData("Missing trailer header.");
        }
        const undeclared = [...result.keys()].filter((k) => !trailerNames.includes(k));
        if (undeclared.length > 0) {
            throw new Deno.errors.InvalidData(`Undeclared trailers: ${Deno.inspect(undeclared)}.`);
        }
        for (const [k, v] of result) {
            headers.append(k, v);
        }
        const missingTrailers = trailerNames.filter((k) => !result.has(k));
        if (missingTrailers.length > 0) {
            throw new Deno.errors.InvalidData(`Missing trailers: ${Deno.inspect(missingTrailers)}.`);
        }
        headers.delete("trailer");
    }
    exports_52("readTrailers", readTrailers);
    function parseTrailer(field) {
        if (field == null) {
            return undefined;
        }
        const trailerNames = field.split(",").map((v) => v.trim().toLowerCase());
        if (trailerNames.length === 0) {
            throw new Deno.errors.InvalidData("Empty trailer header.");
        }
        const prohibited = trailerNames.filter((k) => isProhibidedForTrailer(k));
        if (prohibited.length > 0) {
            throw new Deno.errors.InvalidData(`Prohibited trailer names: ${Deno.inspect(prohibited)}.`);
        }
        return new Headers(trailerNames.map((key) => [key, ""]));
    }
    async function writeChunkedBody(w, r) {
        const writer = bufio_ts_1.BufWriter.create(w);
        for await (const chunk of Deno.iter(r)) {
            if (chunk.byteLength <= 0)
                continue;
            const start = utf8_ts_2.encoder.encode(`${chunk.byteLength.toString(16)}\r\n`);
            const end = utf8_ts_2.encoder.encode("\r\n");
            await writer.write(start);
            await writer.write(chunk);
            await writer.write(end);
        }
        const endChunk = utf8_ts_2.encoder.encode("0\r\n\r\n");
        await writer.write(endChunk);
    }
    exports_52("writeChunkedBody", writeChunkedBody);
    /** Write trailer headers to writer. It should mostly should be called after
     * `writeResponse()`. */
    async function writeTrailers(w, headers, trailers) {
        const trailer = headers.get("trailer");
        if (trailer === null) {
            throw new TypeError("Missing trailer header.");
        }
        const transferEncoding = headers.get("transfer-encoding");
        if (transferEncoding === null || !transferEncoding.match(/^chunked/)) {
            throw new TypeError(`Trailers are only allowed for "transfer-encoding: chunked", got "transfer-encoding: ${transferEncoding}".`);
        }
        const writer = bufio_ts_1.BufWriter.create(w);
        const trailerNames = trailer.split(",").map((s) => s.trim().toLowerCase());
        const prohibitedTrailers = trailerNames.filter((k) => isProhibidedForTrailer(k));
        if (prohibitedTrailers.length > 0) {
            throw new TypeError(`Prohibited trailer names: ${Deno.inspect(prohibitedTrailers)}.`);
        }
        const undeclared = [...trailers.keys()].filter((k) => !trailerNames.includes(k));
        if (undeclared.length > 0) {
            throw new TypeError(`Undeclared trailers: ${Deno.inspect(undeclared)}.`);
        }
        for (const [key, value] of trailers) {
            await writer.write(utf8_ts_2.encoder.encode(`${key}: ${value}\r\n`));
        }
        await writer.write(utf8_ts_2.encoder.encode("\r\n"));
        await writer.flush();
    }
    exports_52("writeTrailers", writeTrailers);
    async function writeResponse(w, r) {
        const protoMajor = 1;
        const protoMinor = 1;
        const statusCode = r.status || 200;
        const statusText = http_status_ts_1.STATUS_TEXT.get(statusCode);
        const writer = bufio_ts_1.BufWriter.create(w);
        if (!statusText) {
            throw new Deno.errors.InvalidData("Bad status code");
        }
        if (!r.body) {
            r.body = new Uint8Array();
        }
        if (typeof r.body === "string") {
            r.body = utf8_ts_2.encoder.encode(r.body);
        }
        let out = `HTTP/${protoMajor}.${protoMinor} ${statusCode} ${statusText}\r\n`;
        const headers = r.headers ?? new Headers();
        if (r.body && !headers.get("content-length")) {
            if (r.body instanceof Uint8Array) {
                out += `content-length: ${r.body.byteLength}\r\n`;
            }
            else if (!headers.get("transfer-encoding")) {
                out += "transfer-encoding: chunked\r\n";
            }
        }
        for (const [key, value] of headers) {
            out += `${key}: ${value}\r\n`;
        }
        out += `\r\n`;
        const header = utf8_ts_2.encoder.encode(out);
        const n = await writer.write(header);
        assert_ts_9.assert(n === header.byteLength);
        if (r.body instanceof Uint8Array) {
            const n = await writer.write(r.body);
            assert_ts_9.assert(n === r.body.byteLength);
        }
        else if (headers.has("content-length")) {
            const contentLength = headers.get("content-length");
            assert_ts_9.assert(contentLength != null);
            const bodyLength = parseInt(contentLength);
            const n = await Deno.copy(r.body, writer);
            assert_ts_9.assert(n === bodyLength);
        }
        else {
            await writeChunkedBody(writer, r.body);
        }
        if (r.trailers) {
            const t = await r.trailers();
            await writeTrailers(writer, headers, t);
        }
        await writer.flush();
    }
    exports_52("writeResponse", writeResponse);
    /**
     * ParseHTTPVersion parses a HTTP version string.
     * "HTTP/1.0" returns (1, 0).
     * Ported from https://github.com/golang/go/blob/f5c43b9/src/net/http/request.go#L766-L792
     */
    function parseHTTPVersion(vers) {
        switch (vers) {
            case "HTTP/1.1":
                return [1, 1];
            case "HTTP/1.0":
                return [1, 0];
            default: {
                const Big = 1000000; // arbitrary upper bound
                if (!vers.startsWith("HTTP/")) {
                    break;
                }
                const dot = vers.indexOf(".");
                if (dot < 0) {
                    break;
                }
                const majorStr = vers.substring(vers.indexOf("/") + 1, dot);
                const major = Number(majorStr);
                if (!Number.isInteger(major) || major < 0 || major > Big) {
                    break;
                }
                const minorStr = vers.substring(dot + 1);
                const minor = Number(minorStr);
                if (!Number.isInteger(minor) || minor < 0 || minor > Big) {
                    break;
                }
                return [major, minor];
            }
        }
        throw new Error(`malformed HTTP version ${vers}`);
    }
    exports_52("parseHTTPVersion", parseHTTPVersion);
    async function readRequest(conn, bufr) {
        const tp = new mod_ts_7.TextProtoReader(bufr);
        const firstLine = await tp.readLine(); // e.g. GET /index.html HTTP/1.0
        if (firstLine === null)
            return null;
        const headers = await tp.readMIMEHeader();
        if (headers === null)
            throw new Deno.errors.UnexpectedEof();
        const req = new server_ts_1.ServerRequest();
        req.conn = conn;
        req.r = bufr;
        [req.method, req.url, req.proto] = firstLine.split(" ", 3);
        [req.protoMinor, req.protoMajor] = parseHTTPVersion(req.proto);
        req.headers = headers;
        fixLength(req);
        return req;
    }
    exports_52("readRequest", readRequest);
    function fixLength(req) {
        const contentLength = req.headers.get("Content-Length");
        if (contentLength) {
            const arrClen = contentLength.split(",");
            if (arrClen.length > 1) {
                const distinct = [...new Set(arrClen.map((e) => e.trim()))];
                if (distinct.length > 1) {
                    throw Error("cannot contain multiple Content-Length headers");
                }
                else {
                    req.headers.set("Content-Length", distinct[0]);
                }
            }
            const c = req.headers.get("Content-Length");
            if (req.method === "HEAD" && c && c !== "0") {
                throw Error("http: method cannot contain a Content-Length");
            }
            if (c && req.headers.has("transfer-encoding")) {
                // A sender MUST NOT send a Content-Length header field in any message
                // that contains a Transfer-Encoding header field.
                // rfc: https://tools.ietf.org/html/rfc7230#section-3.3.2
                throw new Error("http: Transfer-Encoding and Content-Length cannot be send together");
            }
        }
    }
    return {
        setters: [
            function (bufio_ts_1_1) {
                bufio_ts_1 = bufio_ts_1_1;
            },
            function (mod_ts_7_1) {
                mod_ts_7 = mod_ts_7_1;
            },
            function (assert_ts_9_1) {
                assert_ts_9 = assert_ts_9_1;
            },
            function (utf8_ts_2_1) {
                utf8_ts_2 = utf8_ts_2_1;
            },
            function (server_ts_1_1) {
                server_ts_1 = server_ts_1_1;
            },
            function (http_status_ts_1_1) {
                http_status_ts_1 = http_status_ts_1_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@0.57.0/http/server", ["https://deno.land/std@0.57.0/encoding/utf8", "https://deno.land/std@0.57.0/io/bufio", "https://deno.land/std@0.57.0/_util/assert", "https://deno.land/std@0.57.0/async/mod", "https://deno.land/std@0.57.0/http/_io"], function (exports_53, context_53) {
    "use strict";
    var utf8_ts_3, bufio_ts_2, assert_ts_10, mod_ts_8, _io_ts_1, listen, listenTls, ServerRequest, Server;
    var __moduleName = context_53 && context_53.id;
    /**
     * Create a HTTP server
     *
     *     import { serve } from "https://deno.land/std/http/server.ts";
     *     const body = "Hello World\n";
     *     const server = serve({ port: 8000 });
     *     for await (const req of server) {
     *       req.respond({ body });
     *     }
     */
    function serve(addr) {
        if (typeof addr === "string") {
            const [hostname, port] = addr.split(":");
            addr = { hostname, port: Number(port) };
        }
        const listener = listen(addr);
        return new Server(listener);
    }
    exports_53("serve", serve);
    /**
     * Start an HTTP server with given options and request handler
     *
     *     const body = "Hello World\n";
     *     const options = { port: 8000 };
     *     listenAndServe(options, (req) => {
     *       req.respond({ body });
     *     });
     *
     * @param options Server configuration
     * @param handler Request handler
     */
    async function listenAndServe(addr, handler) {
        const server = serve(addr);
        for await (const request of server) {
            handler(request);
        }
    }
    exports_53("listenAndServe", listenAndServe);
    /**
     * Create an HTTPS server with given options
     *
     *     const body = "Hello HTTPS";
     *     const options = {
     *       hostname: "localhost",
     *       port: 443,
     *       certFile: "./path/to/localhost.crt",
     *       keyFile: "./path/to/localhost.key",
     *     };
     *     for await (const req of serveTLS(options)) {
     *       req.respond({ body });
     *     }
     *
     * @param options Server configuration
     * @return Async iterable server instance for incoming requests
     */
    function serveTLS(options) {
        const tlsOptions = {
            ...options,
            transport: "tcp",
        };
        const listener = listenTls(tlsOptions);
        return new Server(listener);
    }
    exports_53("serveTLS", serveTLS);
    /**
     * Start an HTTPS server with given options and request handler
     *
     *     const body = "Hello HTTPS";
     *     const options = {
     *       hostname: "localhost",
     *       port: 443,
     *       certFile: "./path/to/localhost.crt",
     *       keyFile: "./path/to/localhost.key",
     *     };
     *     listenAndServeTLS(options, (req) => {
     *       req.respond({ body });
     *     });
     *
     * @param options Server configuration
     * @param handler Request handler
     */
    async function listenAndServeTLS(options, handler) {
        const server = serveTLS(options);
        for await (const request of server) {
            handler(request);
        }
    }
    exports_53("listenAndServeTLS", listenAndServeTLS);
    return {
        setters: [
            function (utf8_ts_3_1) {
                utf8_ts_3 = utf8_ts_3_1;
            },
            function (bufio_ts_2_1) {
                bufio_ts_2 = bufio_ts_2_1;
            },
            function (assert_ts_10_1) {
                assert_ts_10 = assert_ts_10_1;
            },
            function (mod_ts_8_1) {
                mod_ts_8 = mod_ts_8_1;
            },
            function (_io_ts_1_1) {
                _io_ts_1 = _io_ts_1_1;
            }
        ],
        execute: function () {
            listen = Deno.listen, listenTls = Deno.listenTls;
            ServerRequest = class ServerRequest {
                constructor() {
                    this.done = mod_ts_8.deferred();
                    this._contentLength = undefined;
                    this._body = null;
                    this.finalized = false;
                }
                /**
                 * Value of Content-Length header.
                 * If null, then content length is invalid or not given (e.g. chunked encoding).
                 */
                get contentLength() {
                    // undefined means not cached.
                    // null means invalid or not provided.
                    if (this._contentLength === undefined) {
                        const cl = this.headers.get("content-length");
                        if (cl) {
                            this._contentLength = parseInt(cl);
                            // Convert NaN to null (as NaN harder to test)
                            if (Number.isNaN(this._contentLength)) {
                                this._contentLength = null;
                            }
                        }
                        else {
                            this._contentLength = null;
                        }
                    }
                    return this._contentLength;
                }
                /**
                 * Body of the request.  The easiest way to consume the body is:
                 *
                 *     const buf: Uint8Array = await Deno.readAll(req.body);
                 */
                get body() {
                    if (!this._body) {
                        if (this.contentLength != null) {
                            this._body = _io_ts_1.bodyReader(this.contentLength, this.r);
                        }
                        else {
                            const transferEncoding = this.headers.get("transfer-encoding");
                            if (transferEncoding != null) {
                                const parts = transferEncoding
                                    .split(",")
                                    .map((e) => e.trim().toLowerCase());
                                assert_ts_10.assert(parts.includes("chunked"), 'transfer-encoding must include "chunked" if content-length is not set');
                                this._body = _io_ts_1.chunkedBodyReader(this.headers, this.r);
                            }
                            else {
                                // Neither content-length nor transfer-encoding: chunked
                                this._body = _io_ts_1.emptyReader();
                            }
                        }
                    }
                    return this._body;
                }
                async respond(r) {
                    let err;
                    try {
                        // Write our response!
                        await _io_ts_1.writeResponse(this.w, r);
                    }
                    catch (e) {
                        try {
                            // Eagerly close on error.
                            this.conn.close();
                        }
                        catch {
                            // Pass
                        }
                        err = e;
                    }
                    // Signal that this request has been processed and the next pipelined
                    // request on the same connection can be accepted.
                    this.done.resolve(err);
                    if (err) {
                        // Error during responding, rethrow.
                        throw err;
                    }
                }
                async finalize() {
                    if (this.finalized)
                        return;
                    // Consume unread body
                    const body = this.body;
                    const buf = new Uint8Array(1024);
                    while ((await body.read(buf)) !== null) {
                        // Pass
                    }
                    this.finalized = true;
                }
            };
            exports_53("ServerRequest", ServerRequest);
            Server = class Server {
                constructor(listener) {
                    this.listener = listener;
                    this.closing = false;
                    this.connections = [];
                }
                close() {
                    this.closing = true;
                    this.listener.close();
                    for (const conn of this.connections) {
                        try {
                            conn.close();
                        }
                        catch (e) {
                            // Connection might have been already closed
                            if (!(e instanceof Deno.errors.BadResource)) {
                                throw e;
                            }
                        }
                    }
                }
                // Yields all HTTP requests on a single TCP connection.
                async *iterateHttpRequests(conn) {
                    const reader = new bufio_ts_2.BufReader(conn);
                    const writer = new bufio_ts_2.BufWriter(conn);
                    while (!this.closing) {
                        let request;
                        try {
                            request = await _io_ts_1.readRequest(conn, reader);
                        }
                        catch (error) {
                            if (error instanceof Deno.errors.InvalidData ||
                                error instanceof Deno.errors.UnexpectedEof) {
                                // An error was thrown while parsing request headers.
                                await _io_ts_1.writeResponse(writer, {
                                    status: 400,
                                    body: utf8_ts_3.encode(`${error.message}\r\n\r\n`),
                                });
                            }
                            break;
                        }
                        if (request === null) {
                            break;
                        }
                        request.w = writer;
                        yield request;
                        // Wait for the request to be processed before we accept a new request on
                        // this connection.
                        const responseError = await request.done;
                        if (responseError) {
                            // Something bad happened during response.
                            // (likely other side closed during pipelined req)
                            // req.done implies this connection already closed, so we can just return.
                            this.untrackConnection(request.conn);
                            return;
                        }
                        // Consume unread body and trailers if receiver didn't consume those data
                        await request.finalize();
                    }
                    this.untrackConnection(conn);
                    try {
                        conn.close();
                    }
                    catch (e) {
                        // might have been already closed
                    }
                }
                trackConnection(conn) {
                    this.connections.push(conn);
                }
                untrackConnection(conn) {
                    const index = this.connections.indexOf(conn);
                    if (index !== -1) {
                        this.connections.splice(index, 1);
                    }
                }
                // Accepts a new TCP connection and yields all HTTP requests that arrive on
                // it. When a connection is accepted, it also creates a new iterator of the
                // same kind and adds it to the request multiplexer so that another TCP
                // connection can be accepted.
                async *acceptConnAndIterateHttpRequests(mux) {
                    if (this.closing)
                        return;
                    // Wait for a new connection.
                    let conn;
                    try {
                        conn = await this.listener.accept();
                    }
                    catch (error) {
                        if (error instanceof Deno.errors.BadResource ||
                            error instanceof Deno.errors.InvalidData ||
                            error instanceof Deno.errors.UnexpectedEof) {
                            return mux.add(this.acceptConnAndIterateHttpRequests(mux));
                        }
                        throw error;
                    }
                    this.trackConnection(conn);
                    // Try to accept another connection and add it to the multiplexer.
                    mux.add(this.acceptConnAndIterateHttpRequests(mux));
                    // Yield the requests that arrive on the just-accepted connection.
                    yield* this.iterateHttpRequests(conn);
                }
                [Symbol.asyncIterator]() {
                    const mux = new mod_ts_8.MuxAsyncIterator();
                    mux.add(this.acceptConnAndIterateHttpRequests(mux));
                    return mux.iterate();
                }
            };
            exports_53("Server", Server);
        }
    };
});
// Copyright 2018-2020 the Deno authors. All rights reserved. MIT license.
/** A module to print ANSI terminal colors. Inspired by chalk, kleur, and colors
 * on npm.
 *
 * ```
 * import { bgBlue, red, bold } from "https://deno.land/std/fmt/colors.ts";
 * console.log(bgBlue(red(bold("Hello world!"))));
 * ```
 *
 * This module supports `NO_COLOR` environmental variable disabling any coloring
 * if `NO_COLOR` is set.
 *
 * This module is browser compatible. */
System.register("https://deno.land/std@0.57.0/fmt/colors", [], function (exports_54, context_54) {
    "use strict";
    var noColor, enabled, ANSI_PATTERN;
    var __moduleName = context_54 && context_54.id;
    function setColorEnabled(value) {
        if (noColor) {
            return;
        }
        enabled = value;
    }
    exports_54("setColorEnabled", setColorEnabled);
    function getColorEnabled() {
        return enabled;
    }
    exports_54("getColorEnabled", getColorEnabled);
    function code(open, close) {
        return {
            open: `\x1b[${open.join(";")}m`,
            close: `\x1b[${close}m`,
            regexp: new RegExp(`\\x1b\\[${close}m`, "g"),
        };
    }
    function run(str, code) {
        return enabled
            ? `${code.open}${str.replace(code.regexp, code.open)}${code.close}`
            : str;
    }
    function reset(str) {
        return run(str, code([0], 0));
    }
    exports_54("reset", reset);
    function bold(str) {
        return run(str, code([1], 22));
    }
    exports_54("bold", bold);
    function dim(str) {
        return run(str, code([2], 22));
    }
    exports_54("dim", dim);
    function italic(str) {
        return run(str, code([3], 23));
    }
    exports_54("italic", italic);
    function underline(str) {
        return run(str, code([4], 24));
    }
    exports_54("underline", underline);
    function inverse(str) {
        return run(str, code([7], 27));
    }
    exports_54("inverse", inverse);
    function hidden(str) {
        return run(str, code([8], 28));
    }
    exports_54("hidden", hidden);
    function strikethrough(str) {
        return run(str, code([9], 29));
    }
    exports_54("strikethrough", strikethrough);
    function black(str) {
        return run(str, code([30], 39));
    }
    exports_54("black", black);
    function red(str) {
        return run(str, code([31], 39));
    }
    exports_54("red", red);
    function green(str) {
        return run(str, code([32], 39));
    }
    exports_54("green", green);
    function yellow(str) {
        return run(str, code([33], 39));
    }
    exports_54("yellow", yellow);
    function blue(str) {
        return run(str, code([34], 39));
    }
    exports_54("blue", blue);
    function magenta(str) {
        return run(str, code([35], 39));
    }
    exports_54("magenta", magenta);
    function cyan(str) {
        return run(str, code([36], 39));
    }
    exports_54("cyan", cyan);
    function white(str) {
        return run(str, code([37], 39));
    }
    exports_54("white", white);
    function gray(str) {
        return run(str, code([90], 39));
    }
    exports_54("gray", gray);
    function bgBlack(str) {
        return run(str, code([40], 49));
    }
    exports_54("bgBlack", bgBlack);
    function bgRed(str) {
        return run(str, code([41], 49));
    }
    exports_54("bgRed", bgRed);
    function bgGreen(str) {
        return run(str, code([42], 49));
    }
    exports_54("bgGreen", bgGreen);
    function bgYellow(str) {
        return run(str, code([43], 49));
    }
    exports_54("bgYellow", bgYellow);
    function bgBlue(str) {
        return run(str, code([44], 49));
    }
    exports_54("bgBlue", bgBlue);
    function bgMagenta(str) {
        return run(str, code([45], 49));
    }
    exports_54("bgMagenta", bgMagenta);
    function bgCyan(str) {
        return run(str, code([46], 49));
    }
    exports_54("bgCyan", bgCyan);
    function bgWhite(str) {
        return run(str, code([47], 49));
    }
    exports_54("bgWhite", bgWhite);
    /* Special Color Sequences */
    function clampAndTruncate(n, max = 255, min = 0) {
        return Math.trunc(Math.max(Math.min(n, max), min));
    }
    /** Set text color using paletted 8bit colors.
     * https://en.wikipedia.org/wiki/ANSI_escape_code#8-bit */
    function rgb8(str, color) {
        return run(str, code([38, 5, clampAndTruncate(color)], 39));
    }
    exports_54("rgb8", rgb8);
    /** Set background color using paletted 8bit colors.
     * https://en.wikipedia.org/wiki/ANSI_escape_code#8-bit */
    function bgRgb8(str, color) {
        return run(str, code([48, 5, clampAndTruncate(color)], 49));
    }
    exports_54("bgRgb8", bgRgb8);
    /** Set text color using 24bit rgb.
     * `color` can be a number in range `0x000000` to `0xffffff` or
     * an `Rgb`.
     *
     * To produce the color magenta:
     *
     *      rgba24("foo", 0xff00ff);
     *      rgba24("foo", {r: 255, g: 0, b: 255});
     */
    function rgb24(str, color) {
        if (typeof color === "number") {
            return run(str, code([38, 2, (color >> 16) & 0xff, (color >> 8) & 0xff, color & 0xff], 39));
        }
        return run(str, code([
            38,
            2,
            clampAndTruncate(color.r),
            clampAndTruncate(color.g),
            clampAndTruncate(color.b),
        ], 39));
    }
    exports_54("rgb24", rgb24);
    /** Set background color using 24bit rgb.
     * `color` can be a number in range `0x000000` to `0xffffff` or
     * an `Rgb`.
     *
     * To produce the color magenta:
     *
     *      bgRgba24("foo", 0xff00ff);
     *      bgRgba24("foo", {r: 255, g: 0, b: 255});
     */
    function bgRgb24(str, color) {
        if (typeof color === "number") {
            return run(str, code([48, 2, (color >> 16) & 0xff, (color >> 8) & 0xff, color & 0xff], 49));
        }
        return run(str, code([
            48,
            2,
            clampAndTruncate(color.r),
            clampAndTruncate(color.g),
            clampAndTruncate(color.b),
        ], 49));
    }
    exports_54("bgRgb24", bgRgb24);
    function stripColor(string) {
        return string.replace(ANSI_PATTERN, "");
    }
    exports_54("stripColor", stripColor);
    return {
        setters: [],
        execute: function () {
            noColor = globalThis.Deno?.noColor ?? true;
            enabled = !noColor;
            // https://github.com/chalk/ansi-regex/blob/2b56fb0c7a07108e5b54241e8faec160d393aedb/index.js
            ANSI_PATTERN = new RegExp([
                "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
                "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))",
            ].join("|"), "g");
        }
    };
});
// Copyright 2018-2020 the Deno authors. All rights reserved. MIT license.
/** This module is browser compatible. */
System.register("https://deno.land/std@0.57.0/testing/diff", [], function (exports_55, context_55) {
    "use strict";
    var DiffType, REMOVED, COMMON, ADDED;
    var __moduleName = context_55 && context_55.id;
    function createCommon(A, B, reverse) {
        const common = [];
        if (A.length === 0 || B.length === 0)
            return [];
        for (let i = 0; i < Math.min(A.length, B.length); i += 1) {
            if (A[reverse ? A.length - i - 1 : i] === B[reverse ? B.length - i - 1 : i]) {
                common.push(A[reverse ? A.length - i - 1 : i]);
            }
            else {
                return common;
            }
        }
        return common;
    }
    function diff(A, B) {
        const prefixCommon = createCommon(A, B);
        const suffixCommon = createCommon(A.slice(prefixCommon.length), B.slice(prefixCommon.length), true).reverse();
        A = suffixCommon.length
            ? A.slice(prefixCommon.length, -suffixCommon.length)
            : A.slice(prefixCommon.length);
        B = suffixCommon.length
            ? B.slice(prefixCommon.length, -suffixCommon.length)
            : B.slice(prefixCommon.length);
        const swapped = B.length > A.length;
        [A, B] = swapped ? [B, A] : [A, B];
        const M = A.length;
        const N = B.length;
        if (!M && !N && !suffixCommon.length && !prefixCommon.length)
            return [];
        if (!N) {
            return [
                ...prefixCommon.map((c) => ({ type: DiffType.common, value: c })),
                ...A.map((a) => ({
                    type: swapped ? DiffType.added : DiffType.removed,
                    value: a,
                })),
                ...suffixCommon.map((c) => ({ type: DiffType.common, value: c })),
            ];
        }
        const offset = N;
        const delta = M - N;
        const size = M + N + 1;
        const fp = new Array(size).fill({ y: -1 });
        /**
         * INFO:
         * This buffer is used to save memory and improve performance.
         * The first half is used to save route and last half is used to save diff
         * type.
         * This is because, when I kept new uint8array area to save type,performance
         * worsened.
         */
        const routes = new Uint32Array((M * N + size + 1) * 2);
        const diffTypesPtrOffset = routes.length / 2;
        let ptr = 0;
        let p = -1;
        function backTrace(A, B, current, swapped) {
            const M = A.length;
            const N = B.length;
            const result = [];
            let a = M - 1;
            let b = N - 1;
            let j = routes[current.id];
            let type = routes[current.id + diffTypesPtrOffset];
            while (true) {
                if (!j && !type)
                    break;
                const prev = j;
                if (type === REMOVED) {
                    result.unshift({
                        type: swapped ? DiffType.removed : DiffType.added,
                        value: B[b],
                    });
                    b -= 1;
                }
                else if (type === ADDED) {
                    result.unshift({
                        type: swapped ? DiffType.added : DiffType.removed,
                        value: A[a],
                    });
                    a -= 1;
                }
                else {
                    result.unshift({ type: DiffType.common, value: A[a] });
                    a -= 1;
                    b -= 1;
                }
                j = routes[prev];
                type = routes[prev + diffTypesPtrOffset];
            }
            return result;
        }
        function createFP(slide, down, k, M) {
            if (slide && slide.y === -1 && down && down.y === -1) {
                return { y: 0, id: 0 };
            }
            if ((down && down.y === -1) ||
                k === M ||
                (slide && slide.y) > (down && down.y) + 1) {
                const prev = slide.id;
                ptr++;
                routes[ptr] = prev;
                routes[ptr + diffTypesPtrOffset] = ADDED;
                return { y: slide.y, id: ptr };
            }
            else {
                const prev = down.id;
                ptr++;
                routes[ptr] = prev;
                routes[ptr + diffTypesPtrOffset] = REMOVED;
                return { y: down.y + 1, id: ptr };
            }
        }
        function snake(k, slide, down, _offset, A, B) {
            const M = A.length;
            const N = B.length;
            if (k < -N || M < k)
                return { y: -1, id: -1 };
            const fp = createFP(slide, down, k, M);
            while (fp.y + k < M && fp.y < N && A[fp.y + k] === B[fp.y]) {
                const prev = fp.id;
                ptr++;
                fp.id = ptr;
                fp.y += 1;
                routes[ptr] = prev;
                routes[ptr + diffTypesPtrOffset] = COMMON;
            }
            return fp;
        }
        while (fp[delta + offset].y < N) {
            p = p + 1;
            for (let k = -p; k < delta; ++k) {
                fp[k + offset] = snake(k, fp[k - 1 + offset], fp[k + 1 + offset], offset, A, B);
            }
            for (let k = delta + p; k > delta; --k) {
                fp[k + offset] = snake(k, fp[k - 1 + offset], fp[k + 1 + offset], offset, A, B);
            }
            fp[delta + offset] = snake(delta, fp[delta - 1 + offset], fp[delta + 1 + offset], offset, A, B);
        }
        return [
            ...prefixCommon.map((c) => ({ type: DiffType.common, value: c })),
            ...backTrace(A, B, fp[delta + offset], swapped),
            ...suffixCommon.map((c) => ({ type: DiffType.common, value: c })),
        ];
    }
    exports_55("default", diff);
    return {
        setters: [],
        execute: function () {
            (function (DiffType) {
                DiffType["removed"] = "removed";
                DiffType["common"] = "common";
                DiffType["added"] = "added";
            })(DiffType || (DiffType = {}));
            exports_55("DiffType", DiffType);
            REMOVED = 1;
            COMMON = 2;
            ADDED = 3;
        }
    };
});
// Copyright 2018-2020 the Deno authors. All rights reserved. MIT license.
/** This module is browser compatible. Do not rely on good formatting of values
 * for AssertionError messages in browsers. */
System.register("https://deno.land/std@0.57.0/testing/asserts", ["https://deno.land/std@0.57.0/fmt/colors", "https://deno.land/std@0.57.0/testing/diff"], function (exports_56, context_56) {
    "use strict";
    var colors_ts_1, diff_ts_1, CAN_NOT_DISPLAY, AssertionError;
    var __moduleName = context_56 && context_56.id;
    function format(v) {
        let string = globalThis.Deno ? Deno.inspect(v) : String(v);
        if (typeof v == "string") {
            string = `"${string.replace(/(?=["\\])/g, "\\")}"`;
        }
        return string;
    }
    function createColor(diffType) {
        switch (diffType) {
            case diff_ts_1.DiffType.added:
                return (s) => colors_ts_1.green(colors_ts_1.bold(s));
            case diff_ts_1.DiffType.removed:
                return (s) => colors_ts_1.red(colors_ts_1.bold(s));
            default:
                return colors_ts_1.white;
        }
    }
    function createSign(diffType) {
        switch (diffType) {
            case diff_ts_1.DiffType.added:
                return "+   ";
            case diff_ts_1.DiffType.removed:
                return "-   ";
            default:
                return "    ";
        }
    }
    function buildMessage(diffResult) {
        const messages = [];
        messages.push("");
        messages.push("");
        messages.push(`    ${colors_ts_1.gray(colors_ts_1.bold("[Diff]"))} ${colors_ts_1.red(colors_ts_1.bold("Actual"))} / ${colors_ts_1.green(colors_ts_1.bold("Expected"))}`);
        messages.push("");
        messages.push("");
        diffResult.forEach((result) => {
            const c = createColor(result.type);
            messages.push(c(`${createSign(result.type)}${result.value}`));
        });
        messages.push("");
        return messages;
    }
    function isKeyedCollection(x) {
        return [Symbol.iterator, "size"].every((k) => k in x);
    }
    function equal(c, d) {
        const seen = new Map();
        return (function compare(a, b) {
            // Have to render RegExp & Date for string comparison
            // unless it's mistreated as object
            if (a &&
                b &&
                ((a instanceof RegExp && b instanceof RegExp) ||
                    (a instanceof Date && b instanceof Date))) {
                return String(a) === String(b);
            }
            if (Object.is(a, b)) {
                return true;
            }
            if (a && typeof a === "object" && b && typeof b === "object") {
                if (seen.get(a) === b) {
                    return true;
                }
                if (Object.keys(a || {}).length !== Object.keys(b || {}).length) {
                    return false;
                }
                if (isKeyedCollection(a) && isKeyedCollection(b)) {
                    if (a.size !== b.size) {
                        return false;
                    }
                    let unmatchedEntries = a.size;
                    for (const [aKey, aValue] of a.entries()) {
                        for (const [bKey, bValue] of b.entries()) {
                            /* Given that Map keys can be references, we need
                             * to ensure that they are also deeply equal */
                            if ((aKey === aValue && bKey === bValue && compare(aKey, bKey)) ||
                                (compare(aKey, bKey) && compare(aValue, bValue))) {
                                unmatchedEntries--;
                            }
                        }
                    }
                    return unmatchedEntries === 0;
                }
                const merged = { ...a, ...b };
                for (const key in merged) {
                    if (!compare(a && a[key], b && b[key])) {
                        return false;
                    }
                }
                seen.set(a, b);
                return true;
            }
            return false;
        })(c, d);
    }
    exports_56("equal", equal);
    /** Make an assertion, if not `true`, then throw. */
    function assert(expr, msg = "") {
        if (!expr) {
            throw new AssertionError(msg);
        }
    }
    exports_56("assert", assert);
    /**
     * Make an assertion that `actual` and `expected` are equal, deeply. If not
     * deeply equal, then throw.
     */
    function assertEquals(actual, expected, msg) {
        if (equal(actual, expected)) {
            return;
        }
        let message = "";
        const actualString = format(actual);
        const expectedString = format(expected);
        try {
            const diffResult = diff_ts_1.default(actualString.split("\n"), expectedString.split("\n"));
            const diffMsg = buildMessage(diffResult).join("\n");
            message = `Values are not equal:\n${diffMsg}`;
        }
        catch (e) {
            message = `\n${colors_ts_1.red(CAN_NOT_DISPLAY)} + \n\n`;
        }
        if (msg) {
            message = msg;
        }
        throw new AssertionError(message);
    }
    exports_56("assertEquals", assertEquals);
    /**
     * Make an assertion that `actual` and `expected` are not equal, deeply.
     * If not then throw.
     */
    function assertNotEquals(actual, expected, msg) {
        if (!equal(actual, expected)) {
            return;
        }
        let actualString;
        let expectedString;
        try {
            actualString = String(actual);
        }
        catch (e) {
            actualString = "[Cannot display]";
        }
        try {
            expectedString = String(expected);
        }
        catch (e) {
            expectedString = "[Cannot display]";
        }
        if (!msg) {
            msg = `actual: ${actualString} expected: ${expectedString}`;
        }
        throw new AssertionError(msg);
    }
    exports_56("assertNotEquals", assertNotEquals);
    /**
     * Make an assertion that `actual` and `expected` are strictly equal.  If
     * not then throw.
     */
    function assertStrictEquals(actual, expected, msg) {
        if (actual === expected) {
            return;
        }
        let message;
        if (msg) {
            message = msg;
        }
        else {
            const actualString = format(actual);
            const expectedString = format(expected);
            if (actualString === expectedString) {
                const withOffset = actualString
                    .split("\n")
                    .map((l) => `     ${l}`)
                    .join("\n");
                message = `Values have the same structure but are not reference-equal:\n\n${colors_ts_1.red(withOffset)}\n`;
            }
            else {
                try {
                    const diffResult = diff_ts_1.default(actualString.split("\n"), expectedString.split("\n"));
                    const diffMsg = buildMessage(diffResult).join("\n");
                    message = `Values are not strictly equal:\n${diffMsg}`;
                }
                catch (e) {
                    message = `\n${colors_ts_1.red(CAN_NOT_DISPLAY)} + \n\n`;
                }
            }
        }
        throw new AssertionError(message);
    }
    exports_56("assertStrictEquals", assertStrictEquals);
    /**
     * Make an assertion that actual contains expected. If not
     * then thrown.
     */
    function assertStringContains(actual, expected, msg) {
        if (!actual.includes(expected)) {
            if (!msg) {
                msg = `actual: "${actual}" expected to contain: "${expected}"`;
            }
            throw new AssertionError(msg);
        }
    }
    exports_56("assertStringContains", assertStringContains);
    /**
     * Make an assertion that `actual` contains the `expected` values
     * If not then thrown.
     */
    function assertArrayContains(actual, expected, msg) {
        const missing = [];
        for (let i = 0; i < expected.length; i++) {
            let found = false;
            for (let j = 0; j < actual.length; j++) {
                if (equal(expected[i], actual[j])) {
                    found = true;
                    break;
                }
            }
            if (!found) {
                missing.push(expected[i]);
            }
        }
        if (missing.length === 0) {
            return;
        }
        if (!msg) {
            msg = `actual: "${format(actual)}" expected to contain: "${format(expected)}"\nmissing: ${format(missing)}`;
        }
        throw new AssertionError(msg);
    }
    exports_56("assertArrayContains", assertArrayContains);
    /**
     * Make an assertion that `actual` match RegExp `expected`. If not
     * then thrown
     */
    function assertMatch(actual, expected, msg) {
        if (!expected.test(actual)) {
            if (!msg) {
                msg = `actual: "${actual}" expected to match: "${expected}"`;
            }
            throw new AssertionError(msg);
        }
    }
    exports_56("assertMatch", assertMatch);
    /**
     * Forcefully throws a failed assertion
     */
    function fail(msg) {
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        assert(false, `Failed assertion${msg ? `: ${msg}` : "."}`);
    }
    exports_56("fail", fail);
    /** Executes a function, expecting it to throw.  If it does not, then it
     * throws.  An error class and a string that should be included in the
     * error message can also be asserted.
     */
    function assertThrows(fn, ErrorClass, msgIncludes = "", msg) {
        let doesThrow = false;
        let error = null;
        try {
            fn();
        }
        catch (e) {
            if (ErrorClass && !(Object.getPrototypeOf(e) === ErrorClass.prototype)) {
                msg = `Expected error to be instance of "${ErrorClass.name}", but was "${e.constructor.name}"${msg ? `: ${msg}` : "."}`;
                throw new AssertionError(msg);
            }
            if (msgIncludes &&
                !colors_ts_1.stripColor(e.message).includes(colors_ts_1.stripColor(msgIncludes))) {
                msg = `Expected error message to include "${msgIncludes}", but got "${e.message}"${msg ? `: ${msg}` : "."}`;
                throw new AssertionError(msg);
            }
            doesThrow = true;
            error = e;
        }
        if (!doesThrow) {
            msg = `Expected function to throw${msg ? `: ${msg}` : "."}`;
            throw new AssertionError(msg);
        }
        return error;
    }
    exports_56("assertThrows", assertThrows);
    async function assertThrowsAsync(fn, ErrorClass, msgIncludes = "", msg) {
        let doesThrow = false;
        let error = null;
        try {
            await fn();
        }
        catch (e) {
            if (ErrorClass && !(Object.getPrototypeOf(e) === ErrorClass.prototype)) {
                msg = `Expected error to be instance of "${ErrorClass.name}", but got "${e.name}"${msg ? `: ${msg}` : "."}`;
                throw new AssertionError(msg);
            }
            if (msgIncludes &&
                !colors_ts_1.stripColor(e.message).includes(colors_ts_1.stripColor(msgIncludes))) {
                msg = `Expected error message to include "${msgIncludes}", but got "${e.message}"${msg ? `: ${msg}` : "."}`;
                throw new AssertionError(msg);
            }
            doesThrow = true;
            error = e;
        }
        if (!doesThrow) {
            msg = `Expected function to throw${msg ? `: ${msg}` : "."}`;
            throw new AssertionError(msg);
        }
        return error;
    }
    exports_56("assertThrowsAsync", assertThrowsAsync);
    /** Use this to stub out methods that will throw when invoked. */
    function unimplemented(msg) {
        throw new AssertionError(msg || "unimplemented");
    }
    exports_56("unimplemented", unimplemented);
    /** Use this to assert unreachable code. */
    function unreachable() {
        throw new AssertionError("unreachable");
    }
    exports_56("unreachable", unreachable);
    return {
        setters: [
            function (colors_ts_1_1) {
                colors_ts_1 = colors_ts_1_1;
            },
            function (diff_ts_1_1) {
                diff_ts_1 = diff_ts_1_1;
            }
        ],
        execute: function () {
            CAN_NOT_DISPLAY = "[Cannot display]";
            AssertionError = class AssertionError extends Error {
                constructor(message) {
                    super(message);
                    this.name = "AssertionError";
                }
            };
            exports_56("AssertionError", AssertionError);
        }
    };
});
// Copyright 2018-2020 the Deno authors. All rights reserved. MIT license.
System.register("https://deno.land/std@0.57.0/_util/has_own_property", [], function (exports_57, context_57) {
    "use strict";
    var __moduleName = context_57 && context_57.id;
    /**
     * Determines whether an object has a property with the specified name.
     * Avoid calling prototype builtin `hasOwnProperty` for two reasons:
     *
     * 1. `hasOwnProperty` is defined on the object as something else:
     *
     *      const options = {
     *        ending: 'utf8',
     *        hasOwnProperty: 'foo'
     *      };
     *      options.hasOwnProperty('ending') // throws a TypeError
     *
     * 2. The object doesn't inherit from `Object.prototype`:
     *
     *       const options = Object.create(null);
     *       options.ending = 'utf8';
     *       options.hasOwnProperty('ending'); // throws a TypeError
     *
     * @param obj A Object.
     * @param v A property name.
     * @see https://eslint.org/docs/rules/no-prototype-builtins
     */
    function hasOwnProperty(obj, v) {
        if (obj == null) {
            return false;
        }
        return Object.prototype.hasOwnProperty.call(obj, v);
    }
    exports_57("hasOwnProperty", hasOwnProperty);
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@0.57.0/io/ioutil", ["https://deno.land/std@0.57.0/_util/assert"], function (exports_58, context_58) {
    "use strict";
    var assert_ts_11, DEFAULT_BUFFER_SIZE, MAX_SAFE_INTEGER;
    var __moduleName = context_58 && context_58.id;
    /** copy N size at the most.
     *  If read size is lesser than N, then returns nread
     * */
    async function copyN(r, dest, size) {
        let bytesRead = 0;
        let buf = new Uint8Array(DEFAULT_BUFFER_SIZE);
        while (bytesRead < size) {
            if (size - bytesRead < DEFAULT_BUFFER_SIZE) {
                buf = new Uint8Array(size - bytesRead);
            }
            const result = await r.read(buf);
            const nread = result ?? 0;
            bytesRead += nread;
            if (nread > 0) {
                let n = 0;
                while (n < nread) {
                    n += await dest.write(buf.slice(n, nread));
                }
                assert_ts_11.assert(n === nread, "could not write");
            }
            if (result === null) {
                break;
            }
        }
        return bytesRead;
    }
    exports_58("copyN", copyN);
    /** Read big endian 16bit short from BufReader */
    async function readShort(buf) {
        const high = await buf.readByte();
        if (high === null)
            return null;
        const low = await buf.readByte();
        if (low === null)
            throw new Deno.errors.UnexpectedEof();
        return (high << 8) | low;
    }
    exports_58("readShort", readShort);
    /** Read big endian 32bit integer from BufReader */
    async function readInt(buf) {
        const high = await readShort(buf);
        if (high === null)
            return null;
        const low = await readShort(buf);
        if (low === null)
            throw new Deno.errors.UnexpectedEof();
        return (high << 16) | low;
    }
    exports_58("readInt", readInt);
    /** Read big endian 64bit long from BufReader */
    async function readLong(buf) {
        const high = await readInt(buf);
        if (high === null)
            return null;
        const low = await readInt(buf);
        if (low === null)
            throw new Deno.errors.UnexpectedEof();
        const big = (BigInt(high) << 32n) | BigInt(low);
        // We probably should provide a similar API that returns BigInt values.
        if (big > MAX_SAFE_INTEGER) {
            throw new RangeError("Long value too big to be represented as a JavaScript number.");
        }
        return Number(big);
    }
    exports_58("readLong", readLong);
    /** Slice number into 64bit big endian byte array */
    function sliceLongToBytes(d, dest = new Array(8)) {
        let big = BigInt(d);
        for (let i = 0; i < 8; i++) {
            dest[7 - i] = Number(big & 0xffn);
            big >>= 8n;
        }
        return dest;
    }
    exports_58("sliceLongToBytes", sliceLongToBytes);
    return {
        setters: [
            function (assert_ts_11_1) {
                assert_ts_11 = assert_ts_11_1;
            }
        ],
        execute: function () {
            DEFAULT_BUFFER_SIZE = 32 * 1024;
            MAX_SAFE_INTEGER = BigInt(Number.MAX_SAFE_INTEGER);
        }
    };
});
// Copyright 2018-2020 the Deno authors. All rights reserved. MIT license.
System.register("https://deno.land/std@0.57.0/ws/mod", ["https://deno.land/std@0.57.0/encoding/utf8", "https://deno.land/std@0.57.0/_util/has_own_property", "https://deno.land/std@0.57.0/io/bufio", "https://deno.land/std@0.57.0/io/ioutil", "https://deno.land/std@0.57.0/hash/sha1", "https://deno.land/std@0.57.0/http/_io", "https://deno.land/std@0.57.0/textproto/mod", "https://deno.land/std@0.57.0/async/deferred", "https://deno.land/std@0.57.0/_util/assert", "https://deno.land/std@0.57.0/bytes/mod"], function (exports_59, context_59) {
    "use strict";
    var utf8_ts_4, has_own_property_ts_1, bufio_ts_3, ioutil_ts_1, sha1_ts_1, _io_ts_2, mod_ts_9, deferred_ts_3, assert_ts_12, mod_ts_10, OpCode, WebSocketImpl, kGUID, kSecChars;
    var __moduleName = context_59 && context_59.id;
    function isWebSocketCloseEvent(a) {
        return has_own_property_ts_1.hasOwnProperty(a, "code");
    }
    exports_59("isWebSocketCloseEvent", isWebSocketCloseEvent);
    function isWebSocketPingEvent(a) {
        return Array.isArray(a) && a[0] === "ping" && a[1] instanceof Uint8Array;
    }
    exports_59("isWebSocketPingEvent", isWebSocketPingEvent);
    function isWebSocketPongEvent(a) {
        return Array.isArray(a) && a[0] === "pong" && a[1] instanceof Uint8Array;
    }
    exports_59("isWebSocketPongEvent", isWebSocketPongEvent);
    /** Unmask masked websocket payload */
    function unmask(payload, mask) {
        if (mask) {
            for (let i = 0, len = payload.length; i < len; i++) {
                payload[i] ^= mask[i & 3];
            }
        }
    }
    exports_59("unmask", unmask);
    /** Write websocket frame to given writer */
    async function writeFrame(frame, writer) {
        const payloadLength = frame.payload.byteLength;
        let header;
        const hasMask = frame.mask ? 0x80 : 0;
        if (frame.mask && frame.mask.byteLength !== 4) {
            throw new Error("invalid mask. mask must be 4 bytes: length=" + frame.mask.byteLength);
        }
        if (payloadLength < 126) {
            header = new Uint8Array([0x80 | frame.opcode, hasMask | payloadLength]);
        }
        else if (payloadLength < 0xffff) {
            header = new Uint8Array([
                0x80 | frame.opcode,
                hasMask | 0b01111110,
                payloadLength >>> 8,
                payloadLength & 0x00ff,
            ]);
        }
        else {
            header = new Uint8Array([
                0x80 | frame.opcode,
                hasMask | 0b01111111,
                ...ioutil_ts_1.sliceLongToBytes(payloadLength),
            ]);
        }
        if (frame.mask) {
            header = mod_ts_10.concat(header, frame.mask);
        }
        unmask(frame.payload, frame.mask);
        header = mod_ts_10.concat(header, frame.payload);
        const w = bufio_ts_3.BufWriter.create(writer);
        await w.write(header);
        await w.flush();
    }
    exports_59("writeFrame", writeFrame);
    /** Read websocket frame from given BufReader
     * @throws `Deno.errors.UnexpectedEof` When peer closed connection without close frame
     * @throws `Error` Frame is invalid
     */
    async function readFrame(buf) {
        let b = await buf.readByte();
        assert_ts_12.assert(b !== null);
        let isLastFrame = false;
        switch (b >>> 4) {
            case 0b1000:
                isLastFrame = true;
                break;
            case 0b0000:
                isLastFrame = false;
                break;
            default:
                throw new Error("invalid signature");
        }
        const opcode = b & 0x0f;
        // has_mask & payload
        b = await buf.readByte();
        assert_ts_12.assert(b !== null);
        const hasMask = b >>> 7;
        let payloadLength = b & 0b01111111;
        if (payloadLength === 126) {
            const l = await ioutil_ts_1.readShort(buf);
            assert_ts_12.assert(l !== null);
            payloadLength = l;
        }
        else if (payloadLength === 127) {
            const l = await ioutil_ts_1.readLong(buf);
            assert_ts_12.assert(l !== null);
            payloadLength = Number(l);
        }
        // mask
        let mask;
        if (hasMask) {
            mask = new Uint8Array(4);
            assert_ts_12.assert((await buf.readFull(mask)) !== null);
        }
        // payload
        const payload = new Uint8Array(payloadLength);
        assert_ts_12.assert((await buf.readFull(payload)) !== null);
        return {
            isLastFrame,
            opcode,
            mask,
            payload,
        };
    }
    exports_59("readFrame", readFrame);
    // Create client-to-server mask, random 32bit number
    function createMask() {
        return crypto.getRandomValues(new Uint8Array(4));
    }
    /** Return whether given headers is acceptable for websocket  */
    function acceptable(req) {
        const upgrade = req.headers.get("upgrade");
        if (!upgrade || upgrade.toLowerCase() !== "websocket") {
            return false;
        }
        const secKey = req.headers.get("sec-websocket-key");
        return (req.headers.has("sec-websocket-key") &&
            typeof secKey === "string" &&
            secKey.length > 0);
    }
    exports_59("acceptable", acceptable);
    /** Create sec-websocket-accept header value with given nonce */
    function createSecAccept(nonce) {
        const sha1 = new sha1_ts_1.Sha1();
        sha1.update(nonce + kGUID);
        const bytes = sha1.digest();
        return btoa(String.fromCharCode(...bytes));
    }
    exports_59("createSecAccept", createSecAccept);
    /** Upgrade given TCP connection into websocket connection */
    async function acceptWebSocket(req) {
        const { conn, headers, bufReader, bufWriter } = req;
        if (acceptable(req)) {
            const sock = new WebSocketImpl({ conn, bufReader, bufWriter });
            const secKey = headers.get("sec-websocket-key");
            if (typeof secKey !== "string") {
                throw new Error("sec-websocket-key is not provided");
            }
            const secAccept = createSecAccept(secKey);
            await _io_ts_2.writeResponse(bufWriter, {
                status: 101,
                headers: new Headers({
                    Upgrade: "websocket",
                    Connection: "Upgrade",
                    "Sec-WebSocket-Accept": secAccept,
                }),
            });
            return sock;
        }
        throw new Error("request is not acceptable");
    }
    exports_59("acceptWebSocket", acceptWebSocket);
    /** Create WebSocket-Sec-Key. Base64 encoded 16 bytes string */
    function createSecKey() {
        let key = "";
        for (let i = 0; i < 16; i++) {
            const j = Math.floor(Math.random() * kSecChars.length);
            key += kSecChars[j];
        }
        return btoa(key);
    }
    exports_59("createSecKey", createSecKey);
    async function handshake(url, headers, bufReader, bufWriter) {
        const { hostname, pathname, search } = url;
        const key = createSecKey();
        if (!headers.has("host")) {
            headers.set("host", hostname);
        }
        headers.set("upgrade", "websocket");
        headers.set("connection", "upgrade");
        headers.set("sec-websocket-key", key);
        headers.set("sec-websocket-version", "13");
        let headerStr = `GET ${pathname}${search} HTTP/1.1\r\n`;
        for (const [key, value] of headers) {
            headerStr += `${key}: ${value}\r\n`;
        }
        headerStr += "\r\n";
        await bufWriter.write(utf8_ts_4.encode(headerStr));
        await bufWriter.flush();
        const tpReader = new mod_ts_9.TextProtoReader(bufReader);
        const statusLine = await tpReader.readLine();
        if (statusLine === null) {
            throw new Deno.errors.UnexpectedEof();
        }
        const m = statusLine.match(/^(?<version>\S+) (?<statusCode>\S+) /);
        if (!m) {
            throw new Error("ws: invalid status line: " + statusLine);
        }
        assert_ts_12.assert(m.groups);
        const { version, statusCode } = m.groups;
        if (version !== "HTTP/1.1" || statusCode !== "101") {
            throw new Error(`ws: server didn't accept handshake: ` +
                `version=${version}, statusCode=${statusCode}`);
        }
        const responseHeaders = await tpReader.readMIMEHeader();
        if (responseHeaders === null) {
            throw new Deno.errors.UnexpectedEof();
        }
        const expectedSecAccept = createSecAccept(key);
        const secAccept = responseHeaders.get("sec-websocket-accept");
        if (secAccept !== expectedSecAccept) {
            throw new Error(`ws: unexpected sec-websocket-accept header: ` +
                `expected=${expectedSecAccept}, actual=${secAccept}`);
        }
    }
    exports_59("handshake", handshake);
    /**
     * Connect to given websocket endpoint url.
     * Endpoint must be acceptable for URL.
     */
    async function connectWebSocket(endpoint, headers = new Headers()) {
        const url = new URL(endpoint);
        const { hostname } = url;
        let conn;
        if (url.protocol === "http:" || url.protocol === "ws:") {
            const port = parseInt(url.port || "80");
            conn = await Deno.connect({ hostname, port });
        }
        else if (url.protocol === "https:" || url.protocol === "wss:") {
            const port = parseInt(url.port || "443");
            conn = await Deno.connectTls({ hostname, port });
        }
        else {
            throw new Error("ws: unsupported protocol: " + url.protocol);
        }
        const bufWriter = new bufio_ts_3.BufWriter(conn);
        const bufReader = new bufio_ts_3.BufReader(conn);
        try {
            await handshake(url, headers, bufReader, bufWriter);
        }
        catch (err) {
            conn.close();
            throw err;
        }
        return new WebSocketImpl({
            conn,
            bufWriter,
            bufReader,
            mask: createMask(),
        });
    }
    exports_59("connectWebSocket", connectWebSocket);
    function createWebSocket(params) {
        return new WebSocketImpl(params);
    }
    exports_59("createWebSocket", createWebSocket);
    return {
        setters: [
            function (utf8_ts_4_1) {
                utf8_ts_4 = utf8_ts_4_1;
            },
            function (has_own_property_ts_1_1) {
                has_own_property_ts_1 = has_own_property_ts_1_1;
            },
            function (bufio_ts_3_1) {
                bufio_ts_3 = bufio_ts_3_1;
            },
            function (ioutil_ts_1_1) {
                ioutil_ts_1 = ioutil_ts_1_1;
            },
            function (sha1_ts_1_1) {
                sha1_ts_1 = sha1_ts_1_1;
            },
            function (_io_ts_2_1) {
                _io_ts_2 = _io_ts_2_1;
            },
            function (mod_ts_9_1) {
                mod_ts_9 = mod_ts_9_1;
            },
            function (deferred_ts_3_1) {
                deferred_ts_3 = deferred_ts_3_1;
            },
            function (assert_ts_12_1) {
                assert_ts_12 = assert_ts_12_1;
            },
            function (mod_ts_10_1) {
                mod_ts_10 = mod_ts_10_1;
            }
        ],
        execute: function () {
            (function (OpCode) {
                OpCode[OpCode["Continue"] = 0] = "Continue";
                OpCode[OpCode["TextFrame"] = 1] = "TextFrame";
                OpCode[OpCode["BinaryFrame"] = 2] = "BinaryFrame";
                OpCode[OpCode["Close"] = 8] = "Close";
                OpCode[OpCode["Ping"] = 9] = "Ping";
                OpCode[OpCode["Pong"] = 10] = "Pong";
            })(OpCode || (OpCode = {}));
            exports_59("OpCode", OpCode);
            WebSocketImpl = class WebSocketImpl {
                constructor({ conn, bufReader, bufWriter, mask, }) {
                    this.sendQueue = [];
                    this._isClosed = false;
                    this.conn = conn;
                    this.mask = mask;
                    this.bufReader = bufReader || new bufio_ts_3.BufReader(conn);
                    this.bufWriter = bufWriter || new bufio_ts_3.BufWriter(conn);
                }
                async *[Symbol.asyncIterator]() {
                    let frames = [];
                    let payloadsLength = 0;
                    while (!this._isClosed) {
                        let frame;
                        try {
                            frame = await readFrame(this.bufReader);
                        }
                        catch (e) {
                            this.ensureSocketClosed();
                            break;
                        }
                        unmask(frame.payload, frame.mask);
                        switch (frame.opcode) {
                            case OpCode.TextFrame:
                            case OpCode.BinaryFrame:
                            case OpCode.Continue:
                                frames.push(frame);
                                payloadsLength += frame.payload.length;
                                if (frame.isLastFrame) {
                                    const concat = new Uint8Array(payloadsLength);
                                    let offs = 0;
                                    for (const frame of frames) {
                                        concat.set(frame.payload, offs);
                                        offs += frame.payload.length;
                                    }
                                    if (frames[0].opcode === OpCode.TextFrame) {
                                        // text
                                        yield utf8_ts_4.decode(concat);
                                    }
                                    else {
                                        // binary
                                        yield concat;
                                    }
                                    frames = [];
                                    payloadsLength = 0;
                                }
                                break;
                            case OpCode.Close: {
                                // [0x12, 0x34] -> 0x1234
                                const code = (frame.payload[0] << 8) | frame.payload[1];
                                const reason = utf8_ts_4.decode(frame.payload.subarray(2, frame.payload.length));
                                await this.close(code, reason);
                                yield { code, reason };
                                return;
                            }
                            case OpCode.Ping:
                                await this.enqueue({
                                    opcode: OpCode.Pong,
                                    payload: frame.payload,
                                    isLastFrame: true,
                                });
                                yield ["ping", frame.payload];
                                break;
                            case OpCode.Pong:
                                yield ["pong", frame.payload];
                                break;
                            default:
                        }
                    }
                }
                dequeue() {
                    const [entry] = this.sendQueue;
                    if (!entry)
                        return;
                    if (this._isClosed)
                        return;
                    const { d, frame } = entry;
                    writeFrame(frame, this.bufWriter)
                        .then(() => d.resolve())
                        .catch((e) => d.reject(e))
                        .finally(() => {
                        this.sendQueue.shift();
                        this.dequeue();
                    });
                }
                enqueue(frame) {
                    if (this._isClosed) {
                        throw new Deno.errors.ConnectionReset("Socket has already been closed");
                    }
                    const d = deferred_ts_3.deferred();
                    this.sendQueue.push({ d, frame });
                    if (this.sendQueue.length === 1) {
                        this.dequeue();
                    }
                    return d;
                }
                send(data) {
                    const opcode = typeof data === "string" ? OpCode.TextFrame : OpCode.BinaryFrame;
                    const payload = typeof data === "string" ? utf8_ts_4.encode(data) : data;
                    const isLastFrame = true;
                    const frame = {
                        isLastFrame,
                        opcode,
                        payload,
                        mask: this.mask,
                    };
                    return this.enqueue(frame);
                }
                ping(data = "") {
                    const payload = typeof data === "string" ? utf8_ts_4.encode(data) : data;
                    const frame = {
                        isLastFrame: true,
                        opcode: OpCode.Ping,
                        mask: this.mask,
                        payload,
                    };
                    return this.enqueue(frame);
                }
                get isClosed() {
                    return this._isClosed;
                }
                async close(code = 1000, reason) {
                    try {
                        const header = [code >>> 8, code & 0x00ff];
                        let payload;
                        if (reason) {
                            const reasonBytes = utf8_ts_4.encode(reason);
                            payload = new Uint8Array(2 + reasonBytes.byteLength);
                            payload.set(header);
                            payload.set(reasonBytes, 2);
                        }
                        else {
                            payload = new Uint8Array(header);
                        }
                        await this.enqueue({
                            isLastFrame: true,
                            opcode: OpCode.Close,
                            mask: this.mask,
                            payload,
                        });
                    }
                    catch (e) {
                        throw e;
                    }
                    finally {
                        this.ensureSocketClosed();
                    }
                }
                closeForce() {
                    this.ensureSocketClosed();
                }
                ensureSocketClosed() {
                    if (this.isClosed)
                        return;
                    try {
                        this.conn.close();
                    }
                    catch (e) {
                        console.error(e);
                    }
                    finally {
                        this._isClosed = true;
                        const rest = this.sendQueue;
                        this.sendQueue = [];
                        rest.forEach((e) => e.d.reject(new Deno.errors.ConnectionReset("Socket has already been closed")));
                    }
                }
            };
            kGUID = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
            kSecChars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-.~_";
        }
    };
});
System.register("https://deno.land/x/media_types@v2.3.6/db", [], function (exports_60, context_60) {
    "use strict";
    var db;
    var __moduleName = context_60 && context_60.id;
    return {
        setters: [],
        execute: function () {
            exports_60("db", db = {
                "application/1d-interleaved-parityfec": {
                    source: "iana",
                },
                "application/3gpdash-qoe-report+xml": {
                    source: "iana",
                    charset: "UTF-8",
                    compressible: true,
                },
                "application/3gpp-ims+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/a2l": {
                    source: "iana",
                },
                "application/activemessage": {
                    source: "iana",
                },
                "application/activity+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/alto-costmap+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/alto-costmapfilter+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/alto-directory+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/alto-endpointcost+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/alto-endpointcostparams+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/alto-endpointprop+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/alto-endpointpropparams+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/alto-error+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/alto-networkmap+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/alto-networkmapfilter+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/alto-updatestreamcontrol+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/alto-updatestreamparams+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/aml": {
                    source: "iana",
                },
                "application/andrew-inset": {
                    source: "iana",
                    extensions: ["ez"],
                },
                "application/applefile": {
                    source: "iana",
                },
                "application/applixware": {
                    source: "apache",
                    extensions: ["aw"],
                },
                "application/atf": {
                    source: "iana",
                },
                "application/atfx": {
                    source: "iana",
                },
                "application/atom+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["atom"],
                },
                "application/atomcat+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["atomcat"],
                },
                "application/atomdeleted+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["atomdeleted"],
                },
                "application/atomicmail": {
                    source: "iana",
                },
                "application/atomsvc+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["atomsvc"],
                },
                "application/atsc-dwd+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["dwd"],
                },
                "application/atsc-dynamic-event-message": {
                    source: "iana",
                },
                "application/atsc-held+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["held"],
                },
                "application/atsc-rdt+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/atsc-rsat+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["rsat"],
                },
                "application/atxml": {
                    source: "iana",
                },
                "application/auth-policy+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/bacnet-xdd+zip": {
                    source: "iana",
                    compressible: false,
                },
                "application/batch-smtp": {
                    source: "iana",
                },
                "application/bdoc": {
                    compressible: false,
                    extensions: ["bdoc"],
                },
                "application/beep+xml": {
                    source: "iana",
                    charset: "UTF-8",
                    compressible: true,
                },
                "application/calendar+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/calendar+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["xcs"],
                },
                "application/call-completion": {
                    source: "iana",
                },
                "application/cals-1840": {
                    source: "iana",
                },
                "application/cap+xml": {
                    source: "iana",
                    charset: "UTF-8",
                    compressible: true,
                },
                "application/cbor": {
                    source: "iana",
                },
                "application/cbor-seq": {
                    source: "iana",
                },
                "application/cccex": {
                    source: "iana",
                },
                "application/ccmp+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/ccxml+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["ccxml"],
                },
                "application/cdfx+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["cdfx"],
                },
                "application/cdmi-capability": {
                    source: "iana",
                    extensions: ["cdmia"],
                },
                "application/cdmi-container": {
                    source: "iana",
                    extensions: ["cdmic"],
                },
                "application/cdmi-domain": {
                    source: "iana",
                    extensions: ["cdmid"],
                },
                "application/cdmi-object": {
                    source: "iana",
                    extensions: ["cdmio"],
                },
                "application/cdmi-queue": {
                    source: "iana",
                    extensions: ["cdmiq"],
                },
                "application/cdni": {
                    source: "iana",
                },
                "application/cea": {
                    source: "iana",
                },
                "application/cea-2018+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/cellml+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/cfw": {
                    source: "iana",
                },
                "application/clue+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/clue_info+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/cms": {
                    source: "iana",
                },
                "application/cnrp+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/coap-group+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/coap-payload": {
                    source: "iana",
                },
                "application/commonground": {
                    source: "iana",
                },
                "application/conference-info+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/cose": {
                    source: "iana",
                },
                "application/cose-key": {
                    source: "iana",
                },
                "application/cose-key-set": {
                    source: "iana",
                },
                "application/cpl+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/csrattrs": {
                    source: "iana",
                },
                "application/csta+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/cstadata+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/csvm+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/cu-seeme": {
                    source: "apache",
                    extensions: ["cu"],
                },
                "application/cwt": {
                    source: "iana",
                },
                "application/cybercash": {
                    source: "iana",
                },
                "application/dart": {
                    compressible: true,
                },
                "application/dash+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["mpd"],
                },
                "application/dashdelta": {
                    source: "iana",
                },
                "application/davmount+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["davmount"],
                },
                "application/dca-rft": {
                    source: "iana",
                },
                "application/dcd": {
                    source: "iana",
                },
                "application/dec-dx": {
                    source: "iana",
                },
                "application/dialog-info+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/dicom": {
                    source: "iana",
                },
                "application/dicom+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/dicom+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/dii": {
                    source: "iana",
                },
                "application/dit": {
                    source: "iana",
                },
                "application/dns": {
                    source: "iana",
                },
                "application/dns+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/dns-message": {
                    source: "iana",
                },
                "application/docbook+xml": {
                    source: "apache",
                    compressible: true,
                    extensions: ["dbk"],
                },
                "application/dots+cbor": {
                    source: "iana",
                },
                "application/dskpp+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/dssc+der": {
                    source: "iana",
                    extensions: ["dssc"],
                },
                "application/dssc+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["xdssc"],
                },
                "application/dvcs": {
                    source: "iana",
                },
                "application/ecmascript": {
                    source: "iana",
                    compressible: true,
                    extensions: ["ecma", "es"],
                },
                "application/edi-consent": {
                    source: "iana",
                },
                "application/edi-x12": {
                    source: "iana",
                    compressible: false,
                },
                "application/edifact": {
                    source: "iana",
                    compressible: false,
                },
                "application/efi": {
                    source: "iana",
                },
                "application/emergencycalldata.comment+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/emergencycalldata.control+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/emergencycalldata.deviceinfo+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/emergencycalldata.ecall.msd": {
                    source: "iana",
                },
                "application/emergencycalldata.providerinfo+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/emergencycalldata.serviceinfo+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/emergencycalldata.subscriberinfo+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/emergencycalldata.veds+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/emma+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["emma"],
                },
                "application/emotionml+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["emotionml"],
                },
                "application/encaprtp": {
                    source: "iana",
                },
                "application/epp+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/epub+zip": {
                    source: "iana",
                    compressible: false,
                    extensions: ["epub"],
                },
                "application/eshop": {
                    source: "iana",
                },
                "application/exi": {
                    source: "iana",
                    extensions: ["exi"],
                },
                "application/expect-ct-report+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/fastinfoset": {
                    source: "iana",
                },
                "application/fastsoap": {
                    source: "iana",
                },
                "application/fdt+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["fdt"],
                },
                "application/fhir+json": {
                    source: "iana",
                    charset: "UTF-8",
                    compressible: true,
                },
                "application/fhir+xml": {
                    source: "iana",
                    charset: "UTF-8",
                    compressible: true,
                },
                "application/fido.trusted-apps+json": {
                    compressible: true,
                },
                "application/fits": {
                    source: "iana",
                },
                "application/flexfec": {
                    source: "iana",
                },
                "application/font-sfnt": {
                    source: "iana",
                },
                "application/font-tdpfr": {
                    source: "iana",
                    extensions: ["pfr"],
                },
                "application/font-woff": {
                    source: "iana",
                    compressible: false,
                },
                "application/framework-attributes+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/geo+json": {
                    source: "iana",
                    compressible: true,
                    extensions: ["geojson"],
                },
                "application/geo+json-seq": {
                    source: "iana",
                },
                "application/geopackage+sqlite3": {
                    source: "iana",
                },
                "application/geoxacml+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/gltf-buffer": {
                    source: "iana",
                },
                "application/gml+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["gml"],
                },
                "application/gpx+xml": {
                    source: "apache",
                    compressible: true,
                    extensions: ["gpx"],
                },
                "application/gxf": {
                    source: "apache",
                    extensions: ["gxf"],
                },
                "application/gzip": {
                    source: "iana",
                    compressible: false,
                    extensions: ["gz"],
                },
                "application/h224": {
                    source: "iana",
                },
                "application/held+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/hjson": {
                    extensions: ["hjson"],
                },
                "application/http": {
                    source: "iana",
                },
                "application/hyperstudio": {
                    source: "iana",
                    extensions: ["stk"],
                },
                "application/ibe-key-request+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/ibe-pkg-reply+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/ibe-pp-data": {
                    source: "iana",
                },
                "application/iges": {
                    source: "iana",
                },
                "application/im-iscomposing+xml": {
                    source: "iana",
                    charset: "UTF-8",
                    compressible: true,
                },
                "application/index": {
                    source: "iana",
                },
                "application/index.cmd": {
                    source: "iana",
                },
                "application/index.obj": {
                    source: "iana",
                },
                "application/index.response": {
                    source: "iana",
                },
                "application/index.vnd": {
                    source: "iana",
                },
                "application/inkml+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["ink", "inkml"],
                },
                "application/iotp": {
                    source: "iana",
                },
                "application/ipfix": {
                    source: "iana",
                    extensions: ["ipfix"],
                },
                "application/ipp": {
                    source: "iana",
                },
                "application/isup": {
                    source: "iana",
                },
                "application/its+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["its"],
                },
                "application/java-archive": {
                    source: "apache",
                    compressible: false,
                    extensions: ["jar", "war", "ear"],
                },
                "application/java-serialized-object": {
                    source: "apache",
                    compressible: false,
                    extensions: ["ser"],
                },
                "application/java-vm": {
                    source: "apache",
                    compressible: false,
                    extensions: ["class"],
                },
                "application/javascript": {
                    source: "iana",
                    charset: "UTF-8",
                    compressible: true,
                    extensions: ["js", "mjs"],
                },
                "application/jf2feed+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/jose": {
                    source: "iana",
                },
                "application/jose+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/jrd+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/json": {
                    source: "iana",
                    charset: "UTF-8",
                    compressible: true,
                    extensions: ["json", "map"],
                },
                "application/json-patch+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/json-seq": {
                    source: "iana",
                },
                "application/json5": {
                    extensions: ["json5"],
                },
                "application/jsonml+json": {
                    source: "apache",
                    compressible: true,
                    extensions: ["jsonml"],
                },
                "application/jwk+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/jwk-set+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/jwt": {
                    source: "iana",
                },
                "application/kpml-request+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/kpml-response+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/ld+json": {
                    source: "iana",
                    compressible: true,
                    extensions: ["jsonld"],
                },
                "application/lgr+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["lgr"],
                },
                "application/link-format": {
                    source: "iana",
                },
                "application/load-control+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/lost+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["lostxml"],
                },
                "application/lostsync+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/lpf+zip": {
                    source: "iana",
                    compressible: false,
                },
                "application/lxf": {
                    source: "iana",
                },
                "application/mac-binhex40": {
                    source: "iana",
                    extensions: ["hqx"],
                },
                "application/mac-compactpro": {
                    source: "apache",
                    extensions: ["cpt"],
                },
                "application/macwriteii": {
                    source: "iana",
                },
                "application/mads+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["mads"],
                },
                "application/manifest+json": {
                    charset: "UTF-8",
                    compressible: true,
                    extensions: ["webmanifest"],
                },
                "application/marc": {
                    source: "iana",
                    extensions: ["mrc"],
                },
                "application/marcxml+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["mrcx"],
                },
                "application/mathematica": {
                    source: "iana",
                    extensions: ["ma", "nb", "mb"],
                },
                "application/mathml+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["mathml"],
                },
                "application/mathml-content+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/mathml-presentation+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/mbms-associated-procedure-description+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/mbms-deregister+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/mbms-envelope+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/mbms-msk+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/mbms-msk-response+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/mbms-protection-description+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/mbms-reception-report+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/mbms-register+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/mbms-register-response+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/mbms-schedule+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/mbms-user-service-description+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/mbox": {
                    source: "iana",
                    extensions: ["mbox"],
                },
                "application/media-policy-dataset+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/media_control+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/mediaservercontrol+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["mscml"],
                },
                "application/merge-patch+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/metalink+xml": {
                    source: "apache",
                    compressible: true,
                    extensions: ["metalink"],
                },
                "application/metalink4+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["meta4"],
                },
                "application/mets+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["mets"],
                },
                "application/mf4": {
                    source: "iana",
                },
                "application/mikey": {
                    source: "iana",
                },
                "application/mipc": {
                    source: "iana",
                },
                "application/mmt-aei+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["maei"],
                },
                "application/mmt-usd+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["musd"],
                },
                "application/mods+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["mods"],
                },
                "application/moss-keys": {
                    source: "iana",
                },
                "application/moss-signature": {
                    source: "iana",
                },
                "application/mosskey-data": {
                    source: "iana",
                },
                "application/mosskey-request": {
                    source: "iana",
                },
                "application/mp21": {
                    source: "iana",
                    extensions: ["m21", "mp21"],
                },
                "application/mp4": {
                    source: "iana",
                    extensions: ["mp4s", "m4p"],
                },
                "application/mpeg4-generic": {
                    source: "iana",
                },
                "application/mpeg4-iod": {
                    source: "iana",
                },
                "application/mpeg4-iod-xmt": {
                    source: "iana",
                },
                "application/mrb-consumer+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["xdf"],
                },
                "application/mrb-publish+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["xdf"],
                },
                "application/msc-ivr+xml": {
                    source: "iana",
                    charset: "UTF-8",
                    compressible: true,
                },
                "application/msc-mixer+xml": {
                    source: "iana",
                    charset: "UTF-8",
                    compressible: true,
                },
                "application/msword": {
                    source: "iana",
                    compressible: false,
                    extensions: ["doc", "dot"],
                },
                "application/mud+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/multipart-core": {
                    source: "iana",
                },
                "application/mxf": {
                    source: "iana",
                    extensions: ["mxf"],
                },
                "application/n-quads": {
                    source: "iana",
                    extensions: ["nq"],
                },
                "application/n-triples": {
                    source: "iana",
                    extensions: ["nt"],
                },
                "application/nasdata": {
                    source: "iana",
                },
                "application/news-checkgroups": {
                    source: "iana",
                    charset: "US-ASCII",
                },
                "application/news-groupinfo": {
                    source: "iana",
                    charset: "US-ASCII",
                },
                "application/news-transmission": {
                    source: "iana",
                },
                "application/nlsml+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/node": {
                    source: "iana",
                    extensions: ["cjs"],
                },
                "application/nss": {
                    source: "iana",
                },
                "application/ocsp-request": {
                    source: "iana",
                },
                "application/ocsp-response": {
                    source: "iana",
                },
                "application/octet-stream": {
                    source: "iana",
                    compressible: false,
                    extensions: [
                        "bin",
                        "dms",
                        "lrf",
                        "mar",
                        "so",
                        "dist",
                        "distz",
                        "pkg",
                        "bpk",
                        "dump",
                        "elc",
                        "deploy",
                        "exe",
                        "dll",
                        "deb",
                        "dmg",
                        "iso",
                        "img",
                        "msi",
                        "msp",
                        "msm",
                        "buffer",
                    ],
                },
                "application/oda": {
                    source: "iana",
                    extensions: ["oda"],
                },
                "application/odm+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/odx": {
                    source: "iana",
                },
                "application/oebps-package+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["opf"],
                },
                "application/ogg": {
                    source: "iana",
                    compressible: false,
                    extensions: ["ogx"],
                },
                "application/omdoc+xml": {
                    source: "apache",
                    compressible: true,
                    extensions: ["omdoc"],
                },
                "application/onenote": {
                    source: "apache",
                    extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"],
                },
                "application/oscore": {
                    source: "iana",
                },
                "application/oxps": {
                    source: "iana",
                    extensions: ["oxps"],
                },
                "application/p2p-overlay+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["relo"],
                },
                "application/parityfec": {
                    source: "iana",
                },
                "application/passport": {
                    source: "iana",
                },
                "application/patch-ops-error+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["xer"],
                },
                "application/pdf": {
                    source: "iana",
                    compressible: false,
                    extensions: ["pdf"],
                },
                "application/pdx": {
                    source: "iana",
                },
                "application/pem-certificate-chain": {
                    source: "iana",
                },
                "application/pgp-encrypted": {
                    source: "iana",
                    compressible: false,
                    extensions: ["pgp"],
                },
                "application/pgp-keys": {
                    source: "iana",
                },
                "application/pgp-signature": {
                    source: "iana",
                    extensions: ["asc", "sig"],
                },
                "application/pics-rules": {
                    source: "apache",
                    extensions: ["prf"],
                },
                "application/pidf+xml": {
                    source: "iana",
                    charset: "UTF-8",
                    compressible: true,
                },
                "application/pidf-diff+xml": {
                    source: "iana",
                    charset: "UTF-8",
                    compressible: true,
                },
                "application/pkcs10": {
                    source: "iana",
                    extensions: ["p10"],
                },
                "application/pkcs12": {
                    source: "iana",
                },
                "application/pkcs7-mime": {
                    source: "iana",
                    extensions: ["p7m", "p7c"],
                },
                "application/pkcs7-signature": {
                    source: "iana",
                    extensions: ["p7s"],
                },
                "application/pkcs8": {
                    source: "iana",
                    extensions: ["p8"],
                },
                "application/pkcs8-encrypted": {
                    source: "iana",
                },
                "application/pkix-attr-cert": {
                    source: "iana",
                    extensions: ["ac"],
                },
                "application/pkix-cert": {
                    source: "iana",
                    extensions: ["cer"],
                },
                "application/pkix-crl": {
                    source: "iana",
                    extensions: ["crl"],
                },
                "application/pkix-pkipath": {
                    source: "iana",
                    extensions: ["pkipath"],
                },
                "application/pkixcmp": {
                    source: "iana",
                    extensions: ["pki"],
                },
                "application/pls+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["pls"],
                },
                "application/poc-settings+xml": {
                    source: "iana",
                    charset: "UTF-8",
                    compressible: true,
                },
                "application/postscript": {
                    source: "iana",
                    compressible: true,
                    extensions: ["ai", "eps", "ps"],
                },
                "application/ppsp-tracker+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/problem+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/problem+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/provenance+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["provx"],
                },
                "application/prs.alvestrand.titrax-sheet": {
                    source: "iana",
                },
                "application/prs.cww": {
                    source: "iana",
                    extensions: ["cww"],
                },
                "application/prs.hpub+zip": {
                    source: "iana",
                    compressible: false,
                },
                "application/prs.nprend": {
                    source: "iana",
                },
                "application/prs.plucker": {
                    source: "iana",
                },
                "application/prs.rdf-xml-crypt": {
                    source: "iana",
                },
                "application/prs.xsf+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/pskc+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["pskcxml"],
                },
                "application/pvd+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/qsig": {
                    source: "iana",
                },
                "application/raml+yaml": {
                    compressible: true,
                    extensions: ["raml"],
                },
                "application/raptorfec": {
                    source: "iana",
                },
                "application/rdap+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/rdf+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["rdf", "owl"],
                },
                "application/reginfo+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["rif"],
                },
                "application/relax-ng-compact-syntax": {
                    source: "iana",
                    extensions: ["rnc"],
                },
                "application/remote-printing": {
                    source: "iana",
                },
                "application/reputon+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/resource-lists+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["rl"],
                },
                "application/resource-lists-diff+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["rld"],
                },
                "application/rfc+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/riscos": {
                    source: "iana",
                },
                "application/rlmi+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/rls-services+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["rs"],
                },
                "application/route-apd+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["rapd"],
                },
                "application/route-s-tsid+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["sls"],
                },
                "application/route-usd+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["rusd"],
                },
                "application/rpki-ghostbusters": {
                    source: "iana",
                    extensions: ["gbr"],
                },
                "application/rpki-manifest": {
                    source: "iana",
                    extensions: ["mft"],
                },
                "application/rpki-publication": {
                    source: "iana",
                },
                "application/rpki-roa": {
                    source: "iana",
                    extensions: ["roa"],
                },
                "application/rpki-updown": {
                    source: "iana",
                },
                "application/rsd+xml": {
                    source: "apache",
                    compressible: true,
                    extensions: ["rsd"],
                },
                "application/rss+xml": {
                    source: "apache",
                    compressible: true,
                    extensions: ["rss"],
                },
                "application/rtf": {
                    source: "iana",
                    compressible: true,
                    extensions: ["rtf"],
                },
                "application/rtploopback": {
                    source: "iana",
                },
                "application/rtx": {
                    source: "iana",
                },
                "application/samlassertion+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/samlmetadata+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/sbe": {
                    source: "iana",
                },
                "application/sbml+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["sbml"],
                },
                "application/scaip+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/scim+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/scvp-cv-request": {
                    source: "iana",
                    extensions: ["scq"],
                },
                "application/scvp-cv-response": {
                    source: "iana",
                    extensions: ["scs"],
                },
                "application/scvp-vp-request": {
                    source: "iana",
                    extensions: ["spq"],
                },
                "application/scvp-vp-response": {
                    source: "iana",
                    extensions: ["spp"],
                },
                "application/sdp": {
                    source: "iana",
                    extensions: ["sdp"],
                },
                "application/secevent+jwt": {
                    source: "iana",
                },
                "application/senml+cbor": {
                    source: "iana",
                },
                "application/senml+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/senml+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["senmlx"],
                },
                "application/senml-etch+cbor": {
                    source: "iana",
                },
                "application/senml-etch+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/senml-exi": {
                    source: "iana",
                },
                "application/sensml+cbor": {
                    source: "iana",
                },
                "application/sensml+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/sensml+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["sensmlx"],
                },
                "application/sensml-exi": {
                    source: "iana",
                },
                "application/sep+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/sep-exi": {
                    source: "iana",
                },
                "application/session-info": {
                    source: "iana",
                },
                "application/set-payment": {
                    source: "iana",
                },
                "application/set-payment-initiation": {
                    source: "iana",
                    extensions: ["setpay"],
                },
                "application/set-registration": {
                    source: "iana",
                },
                "application/set-registration-initiation": {
                    source: "iana",
                    extensions: ["setreg"],
                },
                "application/sgml": {
                    source: "iana",
                },
                "application/sgml-open-catalog": {
                    source: "iana",
                },
                "application/shf+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["shf"],
                },
                "application/sieve": {
                    source: "iana",
                    extensions: ["siv", "sieve"],
                },
                "application/simple-filter+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/simple-message-summary": {
                    source: "iana",
                },
                "application/simplesymbolcontainer": {
                    source: "iana",
                },
                "application/sipc": {
                    source: "iana",
                },
                "application/slate": {
                    source: "iana",
                },
                "application/smil": {
                    source: "iana",
                },
                "application/smil+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["smi", "smil"],
                },
                "application/smpte336m": {
                    source: "iana",
                },
                "application/soap+fastinfoset": {
                    source: "iana",
                },
                "application/soap+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/sparql-query": {
                    source: "iana",
                    extensions: ["rq"],
                },
                "application/sparql-results+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["srx"],
                },
                "application/spirits-event+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/sql": {
                    source: "iana",
                },
                "application/srgs": {
                    source: "iana",
                    extensions: ["gram"],
                },
                "application/srgs+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["grxml"],
                },
                "application/sru+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["sru"],
                },
                "application/ssdl+xml": {
                    source: "apache",
                    compressible: true,
                    extensions: ["ssdl"],
                },
                "application/ssml+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["ssml"],
                },
                "application/stix+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/swid+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["swidtag"],
                },
                "application/tamp-apex-update": {
                    source: "iana",
                },
                "application/tamp-apex-update-confirm": {
                    source: "iana",
                },
                "application/tamp-community-update": {
                    source: "iana",
                },
                "application/tamp-community-update-confirm": {
                    source: "iana",
                },
                "application/tamp-error": {
                    source: "iana",
                },
                "application/tamp-sequence-adjust": {
                    source: "iana",
                },
                "application/tamp-sequence-adjust-confirm": {
                    source: "iana",
                },
                "application/tamp-status-query": {
                    source: "iana",
                },
                "application/tamp-status-response": {
                    source: "iana",
                },
                "application/tamp-update": {
                    source: "iana",
                },
                "application/tamp-update-confirm": {
                    source: "iana",
                },
                "application/tar": {
                    compressible: true,
                },
                "application/taxii+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/td+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/tei+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["tei", "teicorpus"],
                },
                "application/tetra_isi": {
                    source: "iana",
                },
                "application/thraud+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["tfi"],
                },
                "application/timestamp-query": {
                    source: "iana",
                },
                "application/timestamp-reply": {
                    source: "iana",
                },
                "application/timestamped-data": {
                    source: "iana",
                    extensions: ["tsd"],
                },
                "application/tlsrpt+gzip": {
                    source: "iana",
                },
                "application/tlsrpt+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/tnauthlist": {
                    source: "iana",
                },
                "application/toml": {
                    compressible: true,
                    extensions: ["toml"],
                },
                "application/trickle-ice-sdpfrag": {
                    source: "iana",
                },
                "application/trig": {
                    source: "iana",
                },
                "application/ttml+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["ttml"],
                },
                "application/tve-trigger": {
                    source: "iana",
                },
                "application/tzif": {
                    source: "iana",
                },
                "application/tzif-leap": {
                    source: "iana",
                },
                "application/ulpfec": {
                    source: "iana",
                },
                "application/urc-grpsheet+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/urc-ressheet+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["rsheet"],
                },
                "application/urc-targetdesc+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/urc-uisocketdesc+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vcard+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vcard+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vemmi": {
                    source: "iana",
                },
                "application/vividence.scriptfile": {
                    source: "apache",
                },
                "application/vnd.1000minds.decision-model+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["1km"],
                },
                "application/vnd.3gpp-prose+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp-prose-pc3ch+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp-v2x-local-service-information": {
                    source: "iana",
                },
                "application/vnd.3gpp.access-transfer-events+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.bsf+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.gmop+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mc-signalling-ear": {
                    source: "iana",
                },
                "application/vnd.3gpp.mcdata-affiliation-command+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mcdata-info+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mcdata-payload": {
                    source: "iana",
                },
                "application/vnd.3gpp.mcdata-service-config+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mcdata-signalling": {
                    source: "iana",
                },
                "application/vnd.3gpp.mcdata-ue-config+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mcdata-user-profile+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mcptt-affiliation-command+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mcptt-floor-request+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mcptt-info+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mcptt-location-info+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mcptt-service-config+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mcptt-signed+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mcptt-ue-config+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mcptt-ue-init-config+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mcptt-user-profile+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mcvideo-info+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mcvideo-location-info+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mcvideo-service-config+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mcvideo-transmission-request+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mcvideo-ue-config+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mcvideo-user-profile+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mid-call+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.pic-bw-large": {
                    source: "iana",
                    extensions: ["plb"],
                },
                "application/vnd.3gpp.pic-bw-small": {
                    source: "iana",
                    extensions: ["psb"],
                },
                "application/vnd.3gpp.pic-bw-var": {
                    source: "iana",
                    extensions: ["pvb"],
                },
                "application/vnd.3gpp.sms": {
                    source: "iana",
                },
                "application/vnd.3gpp.sms+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.srvcc-ext+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.srvcc-info+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.state-and-event-info+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.ussd+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp2.bcmcsinfo+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp2.sms": {
                    source: "iana",
                },
                "application/vnd.3gpp2.tcap": {
                    source: "iana",
                    extensions: ["tcap"],
                },
                "application/vnd.3lightssoftware.imagescal": {
                    source: "iana",
                },
                "application/vnd.3m.post-it-notes": {
                    source: "iana",
                    extensions: ["pwn"],
                },
                "application/vnd.accpac.simply.aso": {
                    source: "iana",
                    extensions: ["aso"],
                },
                "application/vnd.accpac.simply.imp": {
                    source: "iana",
                    extensions: ["imp"],
                },
                "application/vnd.acucobol": {
                    source: "iana",
                    extensions: ["acu"],
                },
                "application/vnd.acucorp": {
                    source: "iana",
                    extensions: ["atc", "acutc"],
                },
                "application/vnd.adobe.air-application-installer-package+zip": {
                    source: "apache",
                    compressible: false,
                    extensions: ["air"],
                },
                "application/vnd.adobe.flash.movie": {
                    source: "iana",
                },
                "application/vnd.adobe.formscentral.fcdt": {
                    source: "iana",
                    extensions: ["fcdt"],
                },
                "application/vnd.adobe.fxp": {
                    source: "iana",
                    extensions: ["fxp", "fxpl"],
                },
                "application/vnd.adobe.partial-upload": {
                    source: "iana",
                },
                "application/vnd.adobe.xdp+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["xdp"],
                },
                "application/vnd.adobe.xfdf": {
                    source: "iana",
                    extensions: ["xfdf"],
                },
                "application/vnd.aether.imp": {
                    source: "iana",
                },
                "application/vnd.afpc.afplinedata": {
                    source: "iana",
                },
                "application/vnd.afpc.afplinedata-pagedef": {
                    source: "iana",
                },
                "application/vnd.afpc.foca-charset": {
                    source: "iana",
                },
                "application/vnd.afpc.foca-codedfont": {
                    source: "iana",
                },
                "application/vnd.afpc.foca-codepage": {
                    source: "iana",
                },
                "application/vnd.afpc.modca": {
                    source: "iana",
                },
                "application/vnd.afpc.modca-formdef": {
                    source: "iana",
                },
                "application/vnd.afpc.modca-mediummap": {
                    source: "iana",
                },
                "application/vnd.afpc.modca-objectcontainer": {
                    source: "iana",
                },
                "application/vnd.afpc.modca-overlay": {
                    source: "iana",
                },
                "application/vnd.afpc.modca-pagesegment": {
                    source: "iana",
                },
                "application/vnd.ah-barcode": {
                    source: "iana",
                },
                "application/vnd.ahead.space": {
                    source: "iana",
                    extensions: ["ahead"],
                },
                "application/vnd.airzip.filesecure.azf": {
                    source: "iana",
                    extensions: ["azf"],
                },
                "application/vnd.airzip.filesecure.azs": {
                    source: "iana",
                    extensions: ["azs"],
                },
                "application/vnd.amadeus+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.amazon.ebook": {
                    source: "apache",
                    extensions: ["azw"],
                },
                "application/vnd.amazon.mobi8-ebook": {
                    source: "iana",
                },
                "application/vnd.americandynamics.acc": {
                    source: "iana",
                    extensions: ["acc"],
                },
                "application/vnd.amiga.ami": {
                    source: "iana",
                    extensions: ["ami"],
                },
                "application/vnd.amundsen.maze+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.android.ota": {
                    source: "iana",
                },
                "application/vnd.android.package-archive": {
                    source: "apache",
                    compressible: false,
                    extensions: ["apk"],
                },
                "application/vnd.anki": {
                    source: "iana",
                },
                "application/vnd.anser-web-certificate-issue-initiation": {
                    source: "iana",
                    extensions: ["cii"],
                },
                "application/vnd.anser-web-funds-transfer-initiation": {
                    source: "apache",
                    extensions: ["fti"],
                },
                "application/vnd.antix.game-component": {
                    source: "iana",
                    extensions: ["atx"],
                },
                "application/vnd.apache.thrift.binary": {
                    source: "iana",
                },
                "application/vnd.apache.thrift.compact": {
                    source: "iana",
                },
                "application/vnd.apache.thrift.json": {
                    source: "iana",
                },
                "application/vnd.api+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.aplextor.warrp+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.apothekende.reservation+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.apple.installer+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["mpkg"],
                },
                "application/vnd.apple.keynote": {
                    source: "iana",
                    extensions: ["keynote"],
                },
                "application/vnd.apple.mpegurl": {
                    source: "iana",
                    extensions: ["m3u8"],
                },
                "application/vnd.apple.numbers": {
                    source: "iana",
                    extensions: ["numbers"],
                },
                "application/vnd.apple.pages": {
                    source: "iana",
                    extensions: ["pages"],
                },
                "application/vnd.apple.pkpass": {
                    compressible: false,
                    extensions: ["pkpass"],
                },
                "application/vnd.arastra.swi": {
                    source: "iana",
                },
                "application/vnd.aristanetworks.swi": {
                    source: "iana",
                    extensions: ["swi"],
                },
                "application/vnd.artisan+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.artsquare": {
                    source: "iana",
                },
                "application/vnd.astraea-software.iota": {
                    source: "iana",
                    extensions: ["iota"],
                },
                "application/vnd.audiograph": {
                    source: "iana",
                    extensions: ["aep"],
                },
                "application/vnd.autopackage": {
                    source: "iana",
                },
                "application/vnd.avalon+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.avistar+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.balsamiq.bmml+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["bmml"],
                },
                "application/vnd.balsamiq.bmpr": {
                    source: "iana",
                },
                "application/vnd.banana-accounting": {
                    source: "iana",
                },
                "application/vnd.bbf.usp.error": {
                    source: "iana",
                },
                "application/vnd.bbf.usp.msg": {
                    source: "iana",
                },
                "application/vnd.bbf.usp.msg+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.bekitzur-stech+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.bint.med-content": {
                    source: "iana",
                },
                "application/vnd.biopax.rdf+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.blink-idb-value-wrapper": {
                    source: "iana",
                },
                "application/vnd.blueice.multipass": {
                    source: "iana",
                    extensions: ["mpm"],
                },
                "application/vnd.bluetooth.ep.oob": {
                    source: "iana",
                },
                "application/vnd.bluetooth.le.oob": {
                    source: "iana",
                },
                "application/vnd.bmi": {
                    source: "iana",
                    extensions: ["bmi"],
                },
                "application/vnd.bpf": {
                    source: "iana",
                },
                "application/vnd.bpf3": {
                    source: "iana",
                },
                "application/vnd.businessobjects": {
                    source: "iana",
                    extensions: ["rep"],
                },
                "application/vnd.byu.uapi+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.cab-jscript": {
                    source: "iana",
                },
                "application/vnd.canon-cpdl": {
                    source: "iana",
                },
                "application/vnd.canon-lips": {
                    source: "iana",
                },
                "application/vnd.capasystems-pg+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.cendio.thinlinc.clientconf": {
                    source: "iana",
                },
                "application/vnd.century-systems.tcp_stream": {
                    source: "iana",
                },
                "application/vnd.chemdraw+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["cdxml"],
                },
                "application/vnd.chess-pgn": {
                    source: "iana",
                },
                "application/vnd.chipnuts.karaoke-mmd": {
                    source: "iana",
                    extensions: ["mmd"],
                },
                "application/vnd.ciedi": {
                    source: "iana",
                },
                "application/vnd.cinderella": {
                    source: "iana",
                    extensions: ["cdy"],
                },
                "application/vnd.cirpack.isdn-ext": {
                    source: "iana",
                },
                "application/vnd.citationstyles.style+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["csl"],
                },
                "application/vnd.claymore": {
                    source: "iana",
                    extensions: ["cla"],
                },
                "application/vnd.cloanto.rp9": {
                    source: "iana",
                    extensions: ["rp9"],
                },
                "application/vnd.clonk.c4group": {
                    source: "iana",
                    extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"],
                },
                "application/vnd.cluetrust.cartomobile-config": {
                    source: "iana",
                    extensions: ["c11amc"],
                },
                "application/vnd.cluetrust.cartomobile-config-pkg": {
                    source: "iana",
                    extensions: ["c11amz"],
                },
                "application/vnd.coffeescript": {
                    source: "iana",
                },
                "application/vnd.collabio.xodocuments.document": {
                    source: "iana",
                },
                "application/vnd.collabio.xodocuments.document-template": {
                    source: "iana",
                },
                "application/vnd.collabio.xodocuments.presentation": {
                    source: "iana",
                },
                "application/vnd.collabio.xodocuments.presentation-template": {
                    source: "iana",
                },
                "application/vnd.collabio.xodocuments.spreadsheet": {
                    source: "iana",
                },
                "application/vnd.collabio.xodocuments.spreadsheet-template": {
                    source: "iana",
                },
                "application/vnd.collection+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.collection.doc+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.collection.next+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.comicbook+zip": {
                    source: "iana",
                    compressible: false,
                },
                "application/vnd.comicbook-rar": {
                    source: "iana",
                },
                "application/vnd.commerce-battelle": {
                    source: "iana",
                },
                "application/vnd.commonspace": {
                    source: "iana",
                    extensions: ["csp"],
                },
                "application/vnd.contact.cmsg": {
                    source: "iana",
                    extensions: ["cdbcmsg"],
                },
                "application/vnd.coreos.ignition+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.cosmocaller": {
                    source: "iana",
                    extensions: ["cmc"],
                },
                "application/vnd.crick.clicker": {
                    source: "iana",
                    extensions: ["clkx"],
                },
                "application/vnd.crick.clicker.keyboard": {
                    source: "iana",
                    extensions: ["clkk"],
                },
                "application/vnd.crick.clicker.palette": {
                    source: "iana",
                    extensions: ["clkp"],
                },
                "application/vnd.crick.clicker.template": {
                    source: "iana",
                    extensions: ["clkt"],
                },
                "application/vnd.crick.clicker.wordbank": {
                    source: "iana",
                    extensions: ["clkw"],
                },
                "application/vnd.criticaltools.wbs+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["wbs"],
                },
                "application/vnd.cryptii.pipe+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.crypto-shade-file": {
                    source: "iana",
                },
                "application/vnd.ctc-posml": {
                    source: "iana",
                    extensions: ["pml"],
                },
                "application/vnd.ctct.ws+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.cups-pdf": {
                    source: "iana",
                },
                "application/vnd.cups-postscript": {
                    source: "iana",
                },
                "application/vnd.cups-ppd": {
                    source: "iana",
                    extensions: ["ppd"],
                },
                "application/vnd.cups-raster": {
                    source: "iana",
                },
                "application/vnd.cups-raw": {
                    source: "iana",
                },
                "application/vnd.curl": {
                    source: "iana",
                },
                "application/vnd.curl.car": {
                    source: "apache",
                    extensions: ["car"],
                },
                "application/vnd.curl.pcurl": {
                    source: "apache",
                    extensions: ["pcurl"],
                },
                "application/vnd.cyan.dean.root+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.cybank": {
                    source: "iana",
                },
                "application/vnd.d2l.coursepackage1p0+zip": {
                    source: "iana",
                    compressible: false,
                },
                "application/vnd.dart": {
                    source: "iana",
                    compressible: true,
                    extensions: ["dart"],
                },
                "application/vnd.data-vision.rdz": {
                    source: "iana",
                    extensions: ["rdz"],
                },
                "application/vnd.datapackage+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.dataresource+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.dbf": {
                    source: "iana",
                },
                "application/vnd.debian.binary-package": {
                    source: "iana",
                },
                "application/vnd.dece.data": {
                    source: "iana",
                    extensions: ["uvf", "uvvf", "uvd", "uvvd"],
                },
                "application/vnd.dece.ttml+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["uvt", "uvvt"],
                },
                "application/vnd.dece.unspecified": {
                    source: "iana",
                    extensions: ["uvx", "uvvx"],
                },
                "application/vnd.dece.zip": {
                    source: "iana",
                    extensions: ["uvz", "uvvz"],
                },
                "application/vnd.denovo.fcselayout-link": {
                    source: "iana",
                    extensions: ["fe_launch"],
                },
                "application/vnd.desmume.movie": {
                    source: "iana",
                },
                "application/vnd.dir-bi.plate-dl-nosuffix": {
                    source: "iana",
                },
                "application/vnd.dm.delegation+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.dna": {
                    source: "iana",
                    extensions: ["dna"],
                },
                "application/vnd.document+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.dolby.mlp": {
                    source: "apache",
                    extensions: ["mlp"],
                },
                "application/vnd.dolby.mobile.1": {
                    source: "iana",
                },
                "application/vnd.dolby.mobile.2": {
                    source: "iana",
                },
                "application/vnd.doremir.scorecloud-binary-document": {
                    source: "iana",
                },
                "application/vnd.dpgraph": {
                    source: "iana",
                    extensions: ["dpg"],
                },
                "application/vnd.dreamfactory": {
                    source: "iana",
                    extensions: ["dfac"],
                },
                "application/vnd.drive+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.ds-keypoint": {
                    source: "apache",
                    extensions: ["kpxx"],
                },
                "application/vnd.dtg.local": {
                    source: "iana",
                },
                "application/vnd.dtg.local.flash": {
                    source: "iana",
                },
                "application/vnd.dtg.local.html": {
                    source: "iana",
                },
                "application/vnd.dvb.ait": {
                    source: "iana",
                    extensions: ["ait"],
                },
                "application/vnd.dvb.dvbisl+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.dvb.dvbj": {
                    source: "iana",
                },
                "application/vnd.dvb.esgcontainer": {
                    source: "iana",
                },
                "application/vnd.dvb.ipdcdftnotifaccess": {
                    source: "iana",
                },
                "application/vnd.dvb.ipdcesgaccess": {
                    source: "iana",
                },
                "application/vnd.dvb.ipdcesgaccess2": {
                    source: "iana",
                },
                "application/vnd.dvb.ipdcesgpdd": {
                    source: "iana",
                },
                "application/vnd.dvb.ipdcroaming": {
                    source: "iana",
                },
                "application/vnd.dvb.iptv.alfec-base": {
                    source: "iana",
                },
                "application/vnd.dvb.iptv.alfec-enhancement": {
                    source: "iana",
                },
                "application/vnd.dvb.notif-aggregate-root+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.dvb.notif-container+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.dvb.notif-generic+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.dvb.notif-ia-msglist+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.dvb.notif-ia-registration-request+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.dvb.notif-ia-registration-response+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.dvb.notif-init+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.dvb.pfr": {
                    source: "iana",
                },
                "application/vnd.dvb.service": {
                    source: "iana",
                    extensions: ["svc"],
                },
                "application/vnd.dxr": {
                    source: "iana",
                },
                "application/vnd.dynageo": {
                    source: "iana",
                    extensions: ["geo"],
                },
                "application/vnd.dzr": {
                    source: "iana",
                },
                "application/vnd.easykaraoke.cdgdownload": {
                    source: "iana",
                },
                "application/vnd.ecdis-update": {
                    source: "iana",
                },
                "application/vnd.ecip.rlp": {
                    source: "iana",
                },
                "application/vnd.ecowin.chart": {
                    source: "iana",
                    extensions: ["mag"],
                },
                "application/vnd.ecowin.filerequest": {
                    source: "iana",
                },
                "application/vnd.ecowin.fileupdate": {
                    source: "iana",
                },
                "application/vnd.ecowin.series": {
                    source: "iana",
                },
                "application/vnd.ecowin.seriesrequest": {
                    source: "iana",
                },
                "application/vnd.ecowin.seriesupdate": {
                    source: "iana",
                },
                "application/vnd.efi.img": {
                    source: "iana",
                },
                "application/vnd.efi.iso": {
                    source: "iana",
                },
                "application/vnd.emclient.accessrequest+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.enliven": {
                    source: "iana",
                    extensions: ["nml"],
                },
                "application/vnd.enphase.envoy": {
                    source: "iana",
                },
                "application/vnd.eprints.data+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.epson.esf": {
                    source: "iana",
                    extensions: ["esf"],
                },
                "application/vnd.epson.msf": {
                    source: "iana",
                    extensions: ["msf"],
                },
                "application/vnd.epson.quickanime": {
                    source: "iana",
                    extensions: ["qam"],
                },
                "application/vnd.epson.salt": {
                    source: "iana",
                    extensions: ["slt"],
                },
                "application/vnd.epson.ssf": {
                    source: "iana",
                    extensions: ["ssf"],
                },
                "application/vnd.ericsson.quickcall": {
                    source: "iana",
                },
                "application/vnd.espass-espass+zip": {
                    source: "iana",
                    compressible: false,
                },
                "application/vnd.eszigno3+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["es3", "et3"],
                },
                "application/vnd.etsi.aoc+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.etsi.asic-e+zip": {
                    source: "iana",
                    compressible: false,
                },
                "application/vnd.etsi.asic-s+zip": {
                    source: "iana",
                    compressible: false,
                },
                "application/vnd.etsi.cug+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.etsi.iptvcommand+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.etsi.iptvdiscovery+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.etsi.iptvprofile+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.etsi.iptvsad-bc+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.etsi.iptvsad-cod+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.etsi.iptvsad-npvr+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.etsi.iptvservice+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.etsi.iptvsync+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.etsi.iptvueprofile+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.etsi.mcid+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.etsi.mheg5": {
                    source: "iana",
                },
                "application/vnd.etsi.overload-control-policy-dataset+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.etsi.pstn+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.etsi.sci+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.etsi.simservs+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.etsi.timestamp-token": {
                    source: "iana",
                },
                "application/vnd.etsi.tsl+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.etsi.tsl.der": {
                    source: "iana",
                },
                "application/vnd.eudora.data": {
                    source: "iana",
                },
                "application/vnd.evolv.ecig.profile": {
                    source: "iana",
                },
                "application/vnd.evolv.ecig.settings": {
                    source: "iana",
                },
                "application/vnd.evolv.ecig.theme": {
                    source: "iana",
                },
                "application/vnd.exstream-empower+zip": {
                    source: "iana",
                    compressible: false,
                },
                "application/vnd.exstream-package": {
                    source: "iana",
                },
                "application/vnd.ezpix-album": {
                    source: "iana",
                    extensions: ["ez2"],
                },
                "application/vnd.ezpix-package": {
                    source: "iana",
                    extensions: ["ez3"],
                },
                "application/vnd.f-secure.mobile": {
                    source: "iana",
                },
                "application/vnd.fastcopy-disk-image": {
                    source: "iana",
                },
                "application/vnd.fdf": {
                    source: "iana",
                    extensions: ["fdf"],
                },
                "application/vnd.fdsn.mseed": {
                    source: "iana",
                    extensions: ["mseed"],
                },
                "application/vnd.fdsn.seed": {
                    source: "iana",
                    extensions: ["seed", "dataless"],
                },
                "application/vnd.ffsns": {
                    source: "iana",
                },
                "application/vnd.ficlab.flb+zip": {
                    source: "iana",
                    compressible: false,
                },
                "application/vnd.filmit.zfc": {
                    source: "iana",
                },
                "application/vnd.fints": {
                    source: "iana",
                },
                "application/vnd.firemonkeys.cloudcell": {
                    source: "iana",
                },
                "application/vnd.flographit": {
                    source: "iana",
                    extensions: ["gph"],
                },
                "application/vnd.fluxtime.clip": {
                    source: "iana",
                    extensions: ["ftc"],
                },
                "application/vnd.font-fontforge-sfd": {
                    source: "iana",
                },
                "application/vnd.framemaker": {
                    source: "iana",
                    extensions: ["fm", "frame", "maker", "book"],
                },
                "application/vnd.frogans.fnc": {
                    source: "iana",
                    extensions: ["fnc"],
                },
                "application/vnd.frogans.ltf": {
                    source: "iana",
                    extensions: ["ltf"],
                },
                "application/vnd.fsc.weblaunch": {
                    source: "iana",
                    extensions: ["fsc"],
                },
                "application/vnd.fujitsu.oasys": {
                    source: "iana",
                    extensions: ["oas"],
                },
                "application/vnd.fujitsu.oasys2": {
                    source: "iana",
                    extensions: ["oa2"],
                },
                "application/vnd.fujitsu.oasys3": {
                    source: "iana",
                    extensions: ["oa3"],
                },
                "application/vnd.fujitsu.oasysgp": {
                    source: "iana",
                    extensions: ["fg5"],
                },
                "application/vnd.fujitsu.oasysprs": {
                    source: "iana",
                    extensions: ["bh2"],
                },
                "application/vnd.fujixerox.art-ex": {
                    source: "iana",
                },
                "application/vnd.fujixerox.art4": {
                    source: "iana",
                },
                "application/vnd.fujixerox.ddd": {
                    source: "iana",
                    extensions: ["ddd"],
                },
                "application/vnd.fujixerox.docuworks": {
                    source: "iana",
                    extensions: ["xdw"],
                },
                "application/vnd.fujixerox.docuworks.binder": {
                    source: "iana",
                    extensions: ["xbd"],
                },
                "application/vnd.fujixerox.docuworks.container": {
                    source: "iana",
                },
                "application/vnd.fujixerox.hbpl": {
                    source: "iana",
                },
                "application/vnd.fut-misnet": {
                    source: "iana",
                },
                "application/vnd.futoin+cbor": {
                    source: "iana",
                },
                "application/vnd.futoin+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.fuzzysheet": {
                    source: "iana",
                    extensions: ["fzs"],
                },
                "application/vnd.genomatix.tuxedo": {
                    source: "iana",
                    extensions: ["txd"],
                },
                "application/vnd.gentics.grd+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.geo+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.geocube+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.geogebra.file": {
                    source: "iana",
                    extensions: ["ggb"],
                },
                "application/vnd.geogebra.tool": {
                    source: "iana",
                    extensions: ["ggt"],
                },
                "application/vnd.geometry-explorer": {
                    source: "iana",
                    extensions: ["gex", "gre"],
                },
                "application/vnd.geonext": {
                    source: "iana",
                    extensions: ["gxt"],
                },
                "application/vnd.geoplan": {
                    source: "iana",
                    extensions: ["g2w"],
                },
                "application/vnd.geospace": {
                    source: "iana",
                    extensions: ["g3w"],
                },
                "application/vnd.gerber": {
                    source: "iana",
                },
                "application/vnd.globalplatform.card-content-mgt": {
                    source: "iana",
                },
                "application/vnd.globalplatform.card-content-mgt-response": {
                    source: "iana",
                },
                "application/vnd.gmx": {
                    source: "iana",
                    extensions: ["gmx"],
                },
                "application/vnd.google-apps.document": {
                    compressible: false,
                    extensions: ["gdoc"],
                },
                "application/vnd.google-apps.presentation": {
                    compressible: false,
                    extensions: ["gslides"],
                },
                "application/vnd.google-apps.spreadsheet": {
                    compressible: false,
                    extensions: ["gsheet"],
                },
                "application/vnd.google-earth.kml+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["kml"],
                },
                "application/vnd.google-earth.kmz": {
                    source: "iana",
                    compressible: false,
                    extensions: ["kmz"],
                },
                "application/vnd.gov.sk.e-form+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.gov.sk.e-form+zip": {
                    source: "iana",
                    compressible: false,
                },
                "application/vnd.gov.sk.xmldatacontainer+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.grafeq": {
                    source: "iana",
                    extensions: ["gqf", "gqs"],
                },
                "application/vnd.gridmp": {
                    source: "iana",
                },
                "application/vnd.groove-account": {
                    source: "iana",
                    extensions: ["gac"],
                },
                "application/vnd.groove-help": {
                    source: "iana",
                    extensions: ["ghf"],
                },
                "application/vnd.groove-identity-message": {
                    source: "iana",
                    extensions: ["gim"],
                },
                "application/vnd.groove-injector": {
                    source: "iana",
                    extensions: ["grv"],
                },
                "application/vnd.groove-tool-message": {
                    source: "iana",
                    extensions: ["gtm"],
                },
                "application/vnd.groove-tool-template": {
                    source: "iana",
                    extensions: ["tpl"],
                },
                "application/vnd.groove-vcard": {
                    source: "iana",
                    extensions: ["vcg"],
                },
                "application/vnd.hal+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.hal+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["hal"],
                },
                "application/vnd.handheld-entertainment+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["zmm"],
                },
                "application/vnd.hbci": {
                    source: "iana",
                    extensions: ["hbci"],
                },
                "application/vnd.hc+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.hcl-bireports": {
                    source: "iana",
                },
                "application/vnd.hdt": {
                    source: "iana",
                },
                "application/vnd.heroku+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.hhe.lesson-player": {
                    source: "iana",
                    extensions: ["les"],
                },
                "application/vnd.hp-hpgl": {
                    source: "iana",
                    extensions: ["hpgl"],
                },
                "application/vnd.hp-hpid": {
                    source: "iana",
                    extensions: ["hpid"],
                },
                "application/vnd.hp-hps": {
                    source: "iana",
                    extensions: ["hps"],
                },
                "application/vnd.hp-jlyt": {
                    source: "iana",
                    extensions: ["jlt"],
                },
                "application/vnd.hp-pcl": {
                    source: "iana",
                    extensions: ["pcl"],
                },
                "application/vnd.hp-pclxl": {
                    source: "iana",
                    extensions: ["pclxl"],
                },
                "application/vnd.httphone": {
                    source: "iana",
                },
                "application/vnd.hydrostatix.sof-data": {
                    source: "iana",
                    extensions: ["sfd-hdstx"],
                },
                "application/vnd.hyper+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.hyper-item+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.hyperdrive+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.hzn-3d-crossword": {
                    source: "iana",
                },
                "application/vnd.ibm.afplinedata": {
                    source: "iana",
                },
                "application/vnd.ibm.electronic-media": {
                    source: "iana",
                },
                "application/vnd.ibm.minipay": {
                    source: "iana",
                    extensions: ["mpy"],
                },
                "application/vnd.ibm.modcap": {
                    source: "iana",
                    extensions: ["afp", "listafp", "list3820"],
                },
                "application/vnd.ibm.rights-management": {
                    source: "iana",
                    extensions: ["irm"],
                },
                "application/vnd.ibm.secure-container": {
                    source: "iana",
                    extensions: ["sc"],
                },
                "application/vnd.iccprofile": {
                    source: "iana",
                    extensions: ["icc", "icm"],
                },
                "application/vnd.ieee.1905": {
                    source: "iana",
                },
                "application/vnd.igloader": {
                    source: "iana",
                    extensions: ["igl"],
                },
                "application/vnd.imagemeter.folder+zip": {
                    source: "iana",
                    compressible: false,
                },
                "application/vnd.imagemeter.image+zip": {
                    source: "iana",
                    compressible: false,
                },
                "application/vnd.immervision-ivp": {
                    source: "iana",
                    extensions: ["ivp"],
                },
                "application/vnd.immervision-ivu": {
                    source: "iana",
                    extensions: ["ivu"],
                },
                "application/vnd.ims.imsccv1p1": {
                    source: "iana",
                },
                "application/vnd.ims.imsccv1p2": {
                    source: "iana",
                },
                "application/vnd.ims.imsccv1p3": {
                    source: "iana",
                },
                "application/vnd.ims.lis.v2.result+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.ims.lti.v2.toolproxy+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.ims.lti.v2.toolproxy.id+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.ims.lti.v2.toolsettings+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.ims.lti.v2.toolsettings.simple+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.informedcontrol.rms+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.informix-visionary": {
                    source: "iana",
                },
                "application/vnd.infotech.project": {
                    source: "iana",
                },
                "application/vnd.infotech.project+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.innopath.wamp.notification": {
                    source: "iana",
                },
                "application/vnd.insors.igm": {
                    source: "iana",
                    extensions: ["igm"],
                },
                "application/vnd.intercon.formnet": {
                    source: "iana",
                    extensions: ["xpw", "xpx"],
                },
                "application/vnd.intergeo": {
                    source: "iana",
                    extensions: ["i2g"],
                },
                "application/vnd.intertrust.digibox": {
                    source: "iana",
                },
                "application/vnd.intertrust.nncp": {
                    source: "iana",
                },
                "application/vnd.intu.qbo": {
                    source: "iana",
                    extensions: ["qbo"],
                },
                "application/vnd.intu.qfx": {
                    source: "iana",
                    extensions: ["qfx"],
                },
                "application/vnd.iptc.g2.catalogitem+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.iptc.g2.conceptitem+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.iptc.g2.knowledgeitem+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.iptc.g2.newsitem+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.iptc.g2.newsmessage+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.iptc.g2.packageitem+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.iptc.g2.planningitem+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.ipunplugged.rcprofile": {
                    source: "iana",
                    extensions: ["rcprofile"],
                },
                "application/vnd.irepository.package+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["irp"],
                },
                "application/vnd.is-xpr": {
                    source: "iana",
                    extensions: ["xpr"],
                },
                "application/vnd.isac.fcs": {
                    source: "iana",
                    extensions: ["fcs"],
                },
                "application/vnd.iso11783-10+zip": {
                    source: "iana",
                    compressible: false,
                },
                "application/vnd.jam": {
                    source: "iana",
                    extensions: ["jam"],
                },
                "application/vnd.japannet-directory-service": {
                    source: "iana",
                },
                "application/vnd.japannet-jpnstore-wakeup": {
                    source: "iana",
                },
                "application/vnd.japannet-payment-wakeup": {
                    source: "iana",
                },
                "application/vnd.japannet-registration": {
                    source: "iana",
                },
                "application/vnd.japannet-registration-wakeup": {
                    source: "iana",
                },
                "application/vnd.japannet-setstore-wakeup": {
                    source: "iana",
                },
                "application/vnd.japannet-verification": {
                    source: "iana",
                },
                "application/vnd.japannet-verification-wakeup": {
                    source: "iana",
                },
                "application/vnd.jcp.javame.midlet-rms": {
                    source: "iana",
                    extensions: ["rms"],
                },
                "application/vnd.jisp": {
                    source: "iana",
                    extensions: ["jisp"],
                },
                "application/vnd.joost.joda-archive": {
                    source: "iana",
                    extensions: ["joda"],
                },
                "application/vnd.jsk.isdn-ngn": {
                    source: "iana",
                },
                "application/vnd.kahootz": {
                    source: "iana",
                    extensions: ["ktz", "ktr"],
                },
                "application/vnd.kde.karbon": {
                    source: "iana",
                    extensions: ["karbon"],
                },
                "application/vnd.kde.kchart": {
                    source: "iana",
                    extensions: ["chrt"],
                },
                "application/vnd.kde.kformula": {
                    source: "iana",
                    extensions: ["kfo"],
                },
                "application/vnd.kde.kivio": {
                    source: "iana",
                    extensions: ["flw"],
                },
                "application/vnd.kde.kontour": {
                    source: "iana",
                    extensions: ["kon"],
                },
                "application/vnd.kde.kpresenter": {
                    source: "iana",
                    extensions: ["kpr", "kpt"],
                },
                "application/vnd.kde.kspread": {
                    source: "iana",
                    extensions: ["ksp"],
                },
                "application/vnd.kde.kword": {
                    source: "iana",
                    extensions: ["kwd", "kwt"],
                },
                "application/vnd.kenameaapp": {
                    source: "iana",
                    extensions: ["htke"],
                },
                "application/vnd.kidspiration": {
                    source: "iana",
                    extensions: ["kia"],
                },
                "application/vnd.kinar": {
                    source: "iana",
                    extensions: ["kne", "knp"],
                },
                "application/vnd.koan": {
                    source: "iana",
                    extensions: ["skp", "skd", "skt", "skm"],
                },
                "application/vnd.kodak-descriptor": {
                    source: "iana",
                    extensions: ["sse"],
                },
                "application/vnd.las": {
                    source: "iana",
                },
                "application/vnd.las.las+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.las.las+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["lasxml"],
                },
                "application/vnd.laszip": {
                    source: "iana",
                },
                "application/vnd.leap+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.liberty-request+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.llamagraphics.life-balance.desktop": {
                    source: "iana",
                    extensions: ["lbd"],
                },
                "application/vnd.llamagraphics.life-balance.exchange+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["lbe"],
                },
                "application/vnd.logipipe.circuit+zip": {
                    source: "iana",
                    compressible: false,
                },
                "application/vnd.loom": {
                    source: "iana",
                },
                "application/vnd.lotus-1-2-3": {
                    source: "iana",
                    extensions: ["123"],
                },
                "application/vnd.lotus-approach": {
                    source: "iana",
                    extensions: ["apr"],
                },
                "application/vnd.lotus-freelance": {
                    source: "iana",
                    extensions: ["pre"],
                },
                "application/vnd.lotus-notes": {
                    source: "iana",
                    extensions: ["nsf"],
                },
                "application/vnd.lotus-organizer": {
                    source: "iana",
                    extensions: ["org"],
                },
                "application/vnd.lotus-screencam": {
                    source: "iana",
                    extensions: ["scm"],
                },
                "application/vnd.lotus-wordpro": {
                    source: "iana",
                    extensions: ["lwp"],
                },
                "application/vnd.macports.portpkg": {
                    source: "iana",
                    extensions: ["portpkg"],
                },
                "application/vnd.mapbox-vector-tile": {
                    source: "iana",
                },
                "application/vnd.marlin.drm.actiontoken+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.marlin.drm.conftoken+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.marlin.drm.license+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.marlin.drm.mdcf": {
                    source: "iana",
                },
                "application/vnd.mason+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.maxmind.maxmind-db": {
                    source: "iana",
                },
                "application/vnd.mcd": {
                    source: "iana",
                    extensions: ["mcd"],
                },
                "application/vnd.medcalcdata": {
                    source: "iana",
                    extensions: ["mc1"],
                },
                "application/vnd.mediastation.cdkey": {
                    source: "iana",
                    extensions: ["cdkey"],
                },
                "application/vnd.meridian-slingshot": {
                    source: "iana",
                },
                "application/vnd.mfer": {
                    source: "iana",
                    extensions: ["mwf"],
                },
                "application/vnd.mfmp": {
                    source: "iana",
                    extensions: ["mfm"],
                },
                "application/vnd.micro+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.micrografx.flo": {
                    source: "iana",
                    extensions: ["flo"],
                },
                "application/vnd.micrografx.igx": {
                    source: "iana",
                    extensions: ["igx"],
                },
                "application/vnd.microsoft.portable-executable": {
                    source: "iana",
                },
                "application/vnd.microsoft.windows.thumbnail-cache": {
                    source: "iana",
                },
                "application/vnd.miele+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.mif": {
                    source: "iana",
                    extensions: ["mif"],
                },
                "application/vnd.minisoft-hp3000-save": {
                    source: "iana",
                },
                "application/vnd.mitsubishi.misty-guard.trustweb": {
                    source: "iana",
                },
                "application/vnd.mobius.daf": {
                    source: "iana",
                    extensions: ["daf"],
                },
                "application/vnd.mobius.dis": {
                    source: "iana",
                    extensions: ["dis"],
                },
                "application/vnd.mobius.mbk": {
                    source: "iana",
                    extensions: ["mbk"],
                },
                "application/vnd.mobius.mqy": {
                    source: "iana",
                    extensions: ["mqy"],
                },
                "application/vnd.mobius.msl": {
                    source: "iana",
                    extensions: ["msl"],
                },
                "application/vnd.mobius.plc": {
                    source: "iana",
                    extensions: ["plc"],
                },
                "application/vnd.mobius.txf": {
                    source: "iana",
                    extensions: ["txf"],
                },
                "application/vnd.mophun.application": {
                    source: "iana",
                    extensions: ["mpn"],
                },
                "application/vnd.mophun.certificate": {
                    source: "iana",
                    extensions: ["mpc"],
                },
                "application/vnd.motorola.flexsuite": {
                    source: "iana",
                },
                "application/vnd.motorola.flexsuite.adsi": {
                    source: "iana",
                },
                "application/vnd.motorola.flexsuite.fis": {
                    source: "iana",
                },
                "application/vnd.motorola.flexsuite.gotap": {
                    source: "iana",
                },
                "application/vnd.motorola.flexsuite.kmr": {
                    source: "iana",
                },
                "application/vnd.motorola.flexsuite.ttc": {
                    source: "iana",
                },
                "application/vnd.motorola.flexsuite.wem": {
                    source: "iana",
                },
                "application/vnd.motorola.iprm": {
                    source: "iana",
                },
                "application/vnd.mozilla.xul+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["xul"],
                },
                "application/vnd.ms-3mfdocument": {
                    source: "iana",
                },
                "application/vnd.ms-artgalry": {
                    source: "iana",
                    extensions: ["cil"],
                },
                "application/vnd.ms-asf": {
                    source: "iana",
                },
                "application/vnd.ms-cab-compressed": {
                    source: "iana",
                    extensions: ["cab"],
                },
                "application/vnd.ms-color.iccprofile": {
                    source: "apache",
                },
                "application/vnd.ms-excel": {
                    source: "iana",
                    compressible: false,
                    extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"],
                },
                "application/vnd.ms-excel.addin.macroenabled.12": {
                    source: "iana",
                    extensions: ["xlam"],
                },
                "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
                    source: "iana",
                    extensions: ["xlsb"],
                },
                "application/vnd.ms-excel.sheet.macroenabled.12": {
                    source: "iana",
                    extensions: ["xlsm"],
                },
                "application/vnd.ms-excel.template.macroenabled.12": {
                    source: "iana",
                    extensions: ["xltm"],
                },
                "application/vnd.ms-fontobject": {
                    source: "iana",
                    compressible: true,
                    extensions: ["eot"],
                },
                "application/vnd.ms-htmlhelp": {
                    source: "iana",
                    extensions: ["chm"],
                },
                "application/vnd.ms-ims": {
                    source: "iana",
                    extensions: ["ims"],
                },
                "application/vnd.ms-lrm": {
                    source: "iana",
                    extensions: ["lrm"],
                },
                "application/vnd.ms-office.activex+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.ms-officetheme": {
                    source: "iana",
                    extensions: ["thmx"],
                },
                "application/vnd.ms-opentype": {
                    source: "apache",
                    compressible: true,
                },
                "application/vnd.ms-outlook": {
                    compressible: false,
                    extensions: ["msg"],
                },
                "application/vnd.ms-package.obfuscated-opentype": {
                    source: "apache",
                },
                "application/vnd.ms-pki.seccat": {
                    source: "apache",
                    extensions: ["cat"],
                },
                "application/vnd.ms-pki.stl": {
                    source: "apache",
                    extensions: ["stl"],
                },
                "application/vnd.ms-playready.initiator+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.ms-powerpoint": {
                    source: "iana",
                    compressible: false,
                    extensions: ["ppt", "pps", "pot"],
                },
                "application/vnd.ms-powerpoint.addin.macroenabled.12": {
                    source: "iana",
                    extensions: ["ppam"],
                },
                "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
                    source: "iana",
                    extensions: ["pptm"],
                },
                "application/vnd.ms-powerpoint.slide.macroenabled.12": {
                    source: "iana",
                    extensions: ["sldm"],
                },
                "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
                    source: "iana",
                    extensions: ["ppsm"],
                },
                "application/vnd.ms-powerpoint.template.macroenabled.12": {
                    source: "iana",
                    extensions: ["potm"],
                },
                "application/vnd.ms-printdevicecapabilities+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.ms-printing.printticket+xml": {
                    source: "apache",
                    compressible: true,
                },
                "application/vnd.ms-printschematicket+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.ms-project": {
                    source: "iana",
                    extensions: ["mpp", "mpt"],
                },
                "application/vnd.ms-tnef": {
                    source: "iana",
                },
                "application/vnd.ms-windows.devicepairing": {
                    source: "iana",
                },
                "application/vnd.ms-windows.nwprinting.oob": {
                    source: "iana",
                },
                "application/vnd.ms-windows.printerpairing": {
                    source: "iana",
                },
                "application/vnd.ms-windows.wsd.oob": {
                    source: "iana",
                },
                "application/vnd.ms-wmdrm.lic-chlg-req": {
                    source: "iana",
                },
                "application/vnd.ms-wmdrm.lic-resp": {
                    source: "iana",
                },
                "application/vnd.ms-wmdrm.meter-chlg-req": {
                    source: "iana",
                },
                "application/vnd.ms-wmdrm.meter-resp": {
                    source: "iana",
                },
                "application/vnd.ms-word.document.macroenabled.12": {
                    source: "iana",
                    extensions: ["docm"],
                },
                "application/vnd.ms-word.template.macroenabled.12": {
                    source: "iana",
                    extensions: ["dotm"],
                },
                "application/vnd.ms-works": {
                    source: "iana",
                    extensions: ["wps", "wks", "wcm", "wdb"],
                },
                "application/vnd.ms-wpl": {
                    source: "iana",
                    extensions: ["wpl"],
                },
                "application/vnd.ms-xpsdocument": {
                    source: "iana",
                    compressible: false,
                    extensions: ["xps"],
                },
                "application/vnd.msa-disk-image": {
                    source: "iana",
                },
                "application/vnd.mseq": {
                    source: "iana",
                    extensions: ["mseq"],
                },
                "application/vnd.msign": {
                    source: "iana",
                },
                "application/vnd.multiad.creator": {
                    source: "iana",
                },
                "application/vnd.multiad.creator.cif": {
                    source: "iana",
                },
                "application/vnd.music-niff": {
                    source: "iana",
                },
                "application/vnd.musician": {
                    source: "iana",
                    extensions: ["mus"],
                },
                "application/vnd.muvee.style": {
                    source: "iana",
                    extensions: ["msty"],
                },
                "application/vnd.mynfc": {
                    source: "iana",
                    extensions: ["taglet"],
                },
                "application/vnd.ncd.control": {
                    source: "iana",
                },
                "application/vnd.ncd.reference": {
                    source: "iana",
                },
                "application/vnd.nearst.inv+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.nervana": {
                    source: "iana",
                },
                "application/vnd.netfpx": {
                    source: "iana",
                },
                "application/vnd.neurolanguage.nlu": {
                    source: "iana",
                    extensions: ["nlu"],
                },
                "application/vnd.nimn": {
                    source: "iana",
                },
                "application/vnd.nintendo.nitro.rom": {
                    source: "iana",
                },
                "application/vnd.nintendo.snes.rom": {
                    source: "iana",
                },
                "application/vnd.nitf": {
                    source: "iana",
                    extensions: ["ntf", "nitf"],
                },
                "application/vnd.noblenet-directory": {
                    source: "iana",
                    extensions: ["nnd"],
                },
                "application/vnd.noblenet-sealer": {
                    source: "iana",
                    extensions: ["nns"],
                },
                "application/vnd.noblenet-web": {
                    source: "iana",
                    extensions: ["nnw"],
                },
                "application/vnd.nokia.catalogs": {
                    source: "iana",
                },
                "application/vnd.nokia.conml+wbxml": {
                    source: "iana",
                },
                "application/vnd.nokia.conml+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.nokia.iptv.config+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.nokia.isds-radio-presets": {
                    source: "iana",
                },
                "application/vnd.nokia.landmark+wbxml": {
                    source: "iana",
                },
                "application/vnd.nokia.landmark+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.nokia.landmarkcollection+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.nokia.n-gage.ac+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["ac"],
                },
                "application/vnd.nokia.n-gage.data": {
                    source: "iana",
                    extensions: ["ngdat"],
                },
                "application/vnd.nokia.n-gage.symbian.install": {
                    source: "iana",
                    extensions: ["n-gage"],
                },
                "application/vnd.nokia.ncd": {
                    source: "iana",
                },
                "application/vnd.nokia.pcd+wbxml": {
                    source: "iana",
                },
                "application/vnd.nokia.pcd+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.nokia.radio-preset": {
                    source: "iana",
                    extensions: ["rpst"],
                },
                "application/vnd.nokia.radio-presets": {
                    source: "iana",
                    extensions: ["rpss"],
                },
                "application/vnd.novadigm.edm": {
                    source: "iana",
                    extensions: ["edm"],
                },
                "application/vnd.novadigm.edx": {
                    source: "iana",
                    extensions: ["edx"],
                },
                "application/vnd.novadigm.ext": {
                    source: "iana",
                    extensions: ["ext"],
                },
                "application/vnd.ntt-local.content-share": {
                    source: "iana",
                },
                "application/vnd.ntt-local.file-transfer": {
                    source: "iana",
                },
                "application/vnd.ntt-local.ogw_remote-access": {
                    source: "iana",
                },
                "application/vnd.ntt-local.sip-ta_remote": {
                    source: "iana",
                },
                "application/vnd.ntt-local.sip-ta_tcp_stream": {
                    source: "iana",
                },
                "application/vnd.oasis.opendocument.chart": {
                    source: "iana",
                    extensions: ["odc"],
                },
                "application/vnd.oasis.opendocument.chart-template": {
                    source: "iana",
                    extensions: ["otc"],
                },
                "application/vnd.oasis.opendocument.database": {
                    source: "iana",
                    extensions: ["odb"],
                },
                "application/vnd.oasis.opendocument.formula": {
                    source: "iana",
                    extensions: ["odf"],
                },
                "application/vnd.oasis.opendocument.formula-template": {
                    source: "iana",
                    extensions: ["odft"],
                },
                "application/vnd.oasis.opendocument.graphics": {
                    source: "iana",
                    compressible: false,
                    extensions: ["odg"],
                },
                "application/vnd.oasis.opendocument.graphics-template": {
                    source: "iana",
                    extensions: ["otg"],
                },
                "application/vnd.oasis.opendocument.image": {
                    source: "iana",
                    extensions: ["odi"],
                },
                "application/vnd.oasis.opendocument.image-template": {
                    source: "iana",
                    extensions: ["oti"],
                },
                "application/vnd.oasis.opendocument.presentation": {
                    source: "iana",
                    compressible: false,
                    extensions: ["odp"],
                },
                "application/vnd.oasis.opendocument.presentation-template": {
                    source: "iana",
                    extensions: ["otp"],
                },
                "application/vnd.oasis.opendocument.spreadsheet": {
                    source: "iana",
                    compressible: false,
                    extensions: ["ods"],
                },
                "application/vnd.oasis.opendocument.spreadsheet-template": {
                    source: "iana",
                    extensions: ["ots"],
                },
                "application/vnd.oasis.opendocument.text": {
                    source: "iana",
                    compressible: false,
                    extensions: ["odt"],
                },
                "application/vnd.oasis.opendocument.text-master": {
                    source: "iana",
                    extensions: ["odm"],
                },
                "application/vnd.oasis.opendocument.text-template": {
                    source: "iana",
                    extensions: ["ott"],
                },
                "application/vnd.oasis.opendocument.text-web": {
                    source: "iana",
                    extensions: ["oth"],
                },
                "application/vnd.obn": {
                    source: "iana",
                },
                "application/vnd.ocf+cbor": {
                    source: "iana",
                },
                "application/vnd.oci.image.manifest.v1+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oftn.l10n+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oipf.contentaccessdownload+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oipf.contentaccessstreaming+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oipf.cspg-hexbinary": {
                    source: "iana",
                },
                "application/vnd.oipf.dae.svg+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oipf.dae.xhtml+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oipf.mippvcontrolmessage+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oipf.pae.gem": {
                    source: "iana",
                },
                "application/vnd.oipf.spdiscovery+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oipf.spdlist+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oipf.ueprofile+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oipf.userprofile+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.olpc-sugar": {
                    source: "iana",
                    extensions: ["xo"],
                },
                "application/vnd.oma-scws-config": {
                    source: "iana",
                },
                "application/vnd.oma-scws-http-request": {
                    source: "iana",
                },
                "application/vnd.oma-scws-http-response": {
                    source: "iana",
                },
                "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oma.bcast.drm-trigger+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oma.bcast.imd+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oma.bcast.ltkm": {
                    source: "iana",
                },
                "application/vnd.oma.bcast.notification+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oma.bcast.provisioningtrigger": {
                    source: "iana",
                },
                "application/vnd.oma.bcast.sgboot": {
                    source: "iana",
                },
                "application/vnd.oma.bcast.sgdd+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oma.bcast.sgdu": {
                    source: "iana",
                },
                "application/vnd.oma.bcast.simple-symbol-container": {
                    source: "iana",
                },
                "application/vnd.oma.bcast.smartcard-trigger+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oma.bcast.sprov+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oma.bcast.stkm": {
                    source: "iana",
                },
                "application/vnd.oma.cab-address-book+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oma.cab-feature-handler+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oma.cab-pcc+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oma.cab-subs-invite+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oma.cab-user-prefs+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oma.dcd": {
                    source: "iana",
                },
                "application/vnd.oma.dcdc": {
                    source: "iana",
                },
                "application/vnd.oma.dd2+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["dd2"],
                },
                "application/vnd.oma.drm.risd+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oma.group-usage-list+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oma.lwm2m+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oma.lwm2m+tlv": {
                    source: "iana",
                },
                "application/vnd.oma.pal+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oma.poc.detailed-progress-report+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oma.poc.final-report+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oma.poc.groups+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oma.poc.invocation-descriptor+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oma.poc.optimized-progress-report+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oma.push": {
                    source: "iana",
                },
                "application/vnd.oma.scidm.messages+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oma.xcap-directory+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.omads-email+xml": {
                    source: "iana",
                    charset: "UTF-8",
                    compressible: true,
                },
                "application/vnd.omads-file+xml": {
                    source: "iana",
                    charset: "UTF-8",
                    compressible: true,
                },
                "application/vnd.omads-folder+xml": {
                    source: "iana",
                    charset: "UTF-8",
                    compressible: true,
                },
                "application/vnd.omaloc-supl-init": {
                    source: "iana",
                },
                "application/vnd.onepager": {
                    source: "iana",
                },
                "application/vnd.onepagertamp": {
                    source: "iana",
                },
                "application/vnd.onepagertamx": {
                    source: "iana",
                },
                "application/vnd.onepagertat": {
                    source: "iana",
                },
                "application/vnd.onepagertatp": {
                    source: "iana",
                },
                "application/vnd.onepagertatx": {
                    source: "iana",
                },
                "application/vnd.openblox.game+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["obgx"],
                },
                "application/vnd.openblox.game-binary": {
                    source: "iana",
                },
                "application/vnd.openeye.oeb": {
                    source: "iana",
                },
                "application/vnd.openofficeorg.extension": {
                    source: "apache",
                    extensions: ["oxt"],
                },
                "application/vnd.openstreetmap.data+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["osm"],
                },
                "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.drawing+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
                    source: "iana",
                    compressible: false,
                    extensions: ["pptx"],
                },
                "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.presentationml.slide": {
                    source: "iana",
                    extensions: ["sldx"],
                },
                "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
                    source: "iana",
                    extensions: ["ppsx"],
                },
                "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.presentationml.template": {
                    source: "iana",
                    extensions: ["potx"],
                },
                "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
                    source: "iana",
                    compressible: false,
                    extensions: ["xlsx"],
                },
                "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
                    source: "iana",
                    extensions: ["xltx"],
                },
                "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.theme+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.vmldrawing": {
                    source: "iana",
                },
                "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
                    source: "iana",
                    compressible: false,
                    extensions: ["docx"],
                },
                "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
                    source: "iana",
                    extensions: ["dotx"],
                },
                "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-package.core-properties+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-package.relationships+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oracle.resource+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.orange.indata": {
                    source: "iana",
                },
                "application/vnd.osa.netdeploy": {
                    source: "iana",
                },
                "application/vnd.osgeo.mapguide.package": {
                    source: "iana",
                    extensions: ["mgp"],
                },
                "application/vnd.osgi.bundle": {
                    source: "iana",
                },
                "application/vnd.osgi.dp": {
                    source: "iana",
                    extensions: ["dp"],
                },
                "application/vnd.osgi.subsystem": {
                    source: "iana",
                    extensions: ["esa"],
                },
                "application/vnd.otps.ct-kip+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oxli.countgraph": {
                    source: "iana",
                },
                "application/vnd.pagerduty+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.palm": {
                    source: "iana",
                    extensions: ["pdb", "pqa", "oprc"],
                },
                "application/vnd.panoply": {
                    source: "iana",
                },
                "application/vnd.paos.xml": {
                    source: "iana",
                },
                "application/vnd.patentdive": {
                    source: "iana",
                },
                "application/vnd.patientecommsdoc": {
                    source: "iana",
                },
                "application/vnd.pawaafile": {
                    source: "iana",
                    extensions: ["paw"],
                },
                "application/vnd.pcos": {
                    source: "iana",
                },
                "application/vnd.pg.format": {
                    source: "iana",
                    extensions: ["str"],
                },
                "application/vnd.pg.osasli": {
                    source: "iana",
                    extensions: ["ei6"],
                },
                "application/vnd.piaccess.application-licence": {
                    source: "iana",
                },
                "application/vnd.picsel": {
                    source: "iana",
                    extensions: ["efif"],
                },
                "application/vnd.pmi.widget": {
                    source: "iana",
                    extensions: ["wg"],
                },
                "application/vnd.poc.group-advertisement+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.pocketlearn": {
                    source: "iana",
                    extensions: ["plf"],
                },
                "application/vnd.powerbuilder6": {
                    source: "iana",
                    extensions: ["pbd"],
                },
                "application/vnd.powerbuilder6-s": {
                    source: "iana",
                },
                "application/vnd.powerbuilder7": {
                    source: "iana",
                },
                "application/vnd.powerbuilder7-s": {
                    source: "iana",
                },
                "application/vnd.powerbuilder75": {
                    source: "iana",
                },
                "application/vnd.powerbuilder75-s": {
                    source: "iana",
                },
                "application/vnd.preminet": {
                    source: "iana",
                },
                "application/vnd.previewsystems.box": {
                    source: "iana",
                    extensions: ["box"],
                },
                "application/vnd.proteus.magazine": {
                    source: "iana",
                    extensions: ["mgz"],
                },
                "application/vnd.psfs": {
                    source: "iana",
                },
                "application/vnd.publishare-delta-tree": {
                    source: "iana",
                    extensions: ["qps"],
                },
                "application/vnd.pvi.ptid1": {
                    source: "iana",
                    extensions: ["ptid"],
                },
                "application/vnd.pwg-multiplexed": {
                    source: "iana",
                },
                "application/vnd.pwg-xhtml-print+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.qualcomm.brew-app-res": {
                    source: "iana",
                },
                "application/vnd.quarantainenet": {
                    source: "iana",
                },
                "application/vnd.quark.quarkxpress": {
                    source: "iana",
                    extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"],
                },
                "application/vnd.quobject-quoxdocument": {
                    source: "iana",
                },
                "application/vnd.radisys.moml+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.radisys.msml+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.radisys.msml-audit+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.radisys.msml-audit-conf+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.radisys.msml-audit-conn+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.radisys.msml-audit-dialog+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.radisys.msml-audit-stream+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.radisys.msml-conf+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.radisys.msml-dialog+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.radisys.msml-dialog-base+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.radisys.msml-dialog-fax-detect+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.radisys.msml-dialog-group+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.radisys.msml-dialog-speech+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.radisys.msml-dialog-transform+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.rainstor.data": {
                    source: "iana",
                },
                "application/vnd.rapid": {
                    source: "iana",
                },
                "application/vnd.rar": {
                    source: "iana",
                },
                "application/vnd.realvnc.bed": {
                    source: "iana",
                    extensions: ["bed"],
                },
                "application/vnd.recordare.musicxml": {
                    source: "iana",
                    extensions: ["mxl"],
                },
                "application/vnd.recordare.musicxml+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["musicxml"],
                },
                "application/vnd.renlearn.rlprint": {
                    source: "iana",
                },
                "application/vnd.restful+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.rig.cryptonote": {
                    source: "iana",
                    extensions: ["cryptonote"],
                },
                "application/vnd.rim.cod": {
                    source: "apache",
                    extensions: ["cod"],
                },
                "application/vnd.rn-realmedia": {
                    source: "apache",
                    extensions: ["rm"],
                },
                "application/vnd.rn-realmedia-vbr": {
                    source: "apache",
                    extensions: ["rmvb"],
                },
                "application/vnd.route66.link66+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["link66"],
                },
                "application/vnd.rs-274x": {
                    source: "iana",
                },
                "application/vnd.ruckus.download": {
                    source: "iana",
                },
                "application/vnd.s3sms": {
                    source: "iana",
                },
                "application/vnd.sailingtracker.track": {
                    source: "iana",
                    extensions: ["st"],
                },
                "application/vnd.sar": {
                    source: "iana",
                },
                "application/vnd.sbm.cid": {
                    source: "iana",
                },
                "application/vnd.sbm.mid2": {
                    source: "iana",
                },
                "application/vnd.scribus": {
                    source: "iana",
                },
                "application/vnd.sealed.3df": {
                    source: "iana",
                },
                "application/vnd.sealed.csf": {
                    source: "iana",
                },
                "application/vnd.sealed.doc": {
                    source: "iana",
                },
                "application/vnd.sealed.eml": {
                    source: "iana",
                },
                "application/vnd.sealed.mht": {
                    source: "iana",
                },
                "application/vnd.sealed.net": {
                    source: "iana",
                },
                "application/vnd.sealed.ppt": {
                    source: "iana",
                },
                "application/vnd.sealed.tiff": {
                    source: "iana",
                },
                "application/vnd.sealed.xls": {
                    source: "iana",
                },
                "application/vnd.sealedmedia.softseal.html": {
                    source: "iana",
                },
                "application/vnd.sealedmedia.softseal.pdf": {
                    source: "iana",
                },
                "application/vnd.seemail": {
                    source: "iana",
                    extensions: ["see"],
                },
                "application/vnd.sema": {
                    source: "iana",
                    extensions: ["sema"],
                },
                "application/vnd.semd": {
                    source: "iana",
                    extensions: ["semd"],
                },
                "application/vnd.semf": {
                    source: "iana",
                    extensions: ["semf"],
                },
                "application/vnd.shade-save-file": {
                    source: "iana",
                },
                "application/vnd.shana.informed.formdata": {
                    source: "iana",
                    extensions: ["ifm"],
                },
                "application/vnd.shana.informed.formtemplate": {
                    source: "iana",
                    extensions: ["itp"],
                },
                "application/vnd.shana.informed.interchange": {
                    source: "iana",
                    extensions: ["iif"],
                },
                "application/vnd.shana.informed.package": {
                    source: "iana",
                    extensions: ["ipk"],
                },
                "application/vnd.shootproof+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.shopkick+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.shp": {
                    source: "iana",
                },
                "application/vnd.shx": {
                    source: "iana",
                },
                "application/vnd.sigrok.session": {
                    source: "iana",
                },
                "application/vnd.simtech-mindmapper": {
                    source: "iana",
                    extensions: ["twd", "twds"],
                },
                "application/vnd.siren+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.smaf": {
                    source: "iana",
                    extensions: ["mmf"],
                },
                "application/vnd.smart.notebook": {
                    source: "iana",
                },
                "application/vnd.smart.teacher": {
                    source: "iana",
                    extensions: ["teacher"],
                },
                "application/vnd.snesdev-page-table": {
                    source: "iana",
                },
                "application/vnd.software602.filler.form+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["fo"],
                },
                "application/vnd.software602.filler.form-xml-zip": {
                    source: "iana",
                },
                "application/vnd.solent.sdkm+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["sdkm", "sdkd"],
                },
                "application/vnd.spotfire.dxp": {
                    source: "iana",
                    extensions: ["dxp"],
                },
                "application/vnd.spotfire.sfs": {
                    source: "iana",
                    extensions: ["sfs"],
                },
                "application/vnd.sqlite3": {
                    source: "iana",
                },
                "application/vnd.sss-cod": {
                    source: "iana",
                },
                "application/vnd.sss-dtf": {
                    source: "iana",
                },
                "application/vnd.sss-ntf": {
                    source: "iana",
                },
                "application/vnd.stardivision.calc": {
                    source: "apache",
                    extensions: ["sdc"],
                },
                "application/vnd.stardivision.draw": {
                    source: "apache",
                    extensions: ["sda"],
                },
                "application/vnd.stardivision.impress": {
                    source: "apache",
                    extensions: ["sdd"],
                },
                "application/vnd.stardivision.math": {
                    source: "apache",
                    extensions: ["smf"],
                },
                "application/vnd.stardivision.writer": {
                    source: "apache",
                    extensions: ["sdw", "vor"],
                },
                "application/vnd.stardivision.writer-global": {
                    source: "apache",
                    extensions: ["sgl"],
                },
                "application/vnd.stepmania.package": {
                    source: "iana",
                    extensions: ["smzip"],
                },
                "application/vnd.stepmania.stepchart": {
                    source: "iana",
                    extensions: ["sm"],
                },
                "application/vnd.street-stream": {
                    source: "iana",
                },
                "application/vnd.sun.wadl+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["wadl"],
                },
                "application/vnd.sun.xml.calc": {
                    source: "apache",
                    extensions: ["sxc"],
                },
                "application/vnd.sun.xml.calc.template": {
                    source: "apache",
                    extensions: ["stc"],
                },
                "application/vnd.sun.xml.draw": {
                    source: "apache",
                    extensions: ["sxd"],
                },
                "application/vnd.sun.xml.draw.template": {
                    source: "apache",
                    extensions: ["std"],
                },
                "application/vnd.sun.xml.impress": {
                    source: "apache",
                    extensions: ["sxi"],
                },
                "application/vnd.sun.xml.impress.template": {
                    source: "apache",
                    extensions: ["sti"],
                },
                "application/vnd.sun.xml.math": {
                    source: "apache",
                    extensions: ["sxm"],
                },
                "application/vnd.sun.xml.writer": {
                    source: "apache",
                    extensions: ["sxw"],
                },
                "application/vnd.sun.xml.writer.global": {
                    source: "apache",
                    extensions: ["sxg"],
                },
                "application/vnd.sun.xml.writer.template": {
                    source: "apache",
                    extensions: ["stw"],
                },
                "application/vnd.sus-calendar": {
                    source: "iana",
                    extensions: ["sus", "susp"],
                },
                "application/vnd.svd": {
                    source: "iana",
                    extensions: ["svd"],
                },
                "application/vnd.swiftview-ics": {
                    source: "iana",
                },
                "application/vnd.symbian.install": {
                    source: "apache",
                    extensions: ["sis", "sisx"],
                },
                "application/vnd.syncml+xml": {
                    source: "iana",
                    charset: "UTF-8",
                    compressible: true,
                    extensions: ["xsm"],
                },
                "application/vnd.syncml.dm+wbxml": {
                    source: "iana",
                    charset: "UTF-8",
                    extensions: ["bdm"],
                },
                "application/vnd.syncml.dm+xml": {
                    source: "iana",
                    charset: "UTF-8",
                    compressible: true,
                    extensions: ["xdm"],
                },
                "application/vnd.syncml.dm.notification": {
                    source: "iana",
                },
                "application/vnd.syncml.dmddf+wbxml": {
                    source: "iana",
                },
                "application/vnd.syncml.dmddf+xml": {
                    source: "iana",
                    charset: "UTF-8",
                    compressible: true,
                    extensions: ["ddf"],
                },
                "application/vnd.syncml.dmtnds+wbxml": {
                    source: "iana",
                },
                "application/vnd.syncml.dmtnds+xml": {
                    source: "iana",
                    charset: "UTF-8",
                    compressible: true,
                },
                "application/vnd.syncml.ds.notification": {
                    source: "iana",
                },
                "application/vnd.tableschema+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.tao.intent-module-archive": {
                    source: "iana",
                    extensions: ["tao"],
                },
                "application/vnd.tcpdump.pcap": {
                    source: "iana",
                    extensions: ["pcap", "cap", "dmp"],
                },
                "application/vnd.think-cell.ppttc+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.tmd.mediaflex.api+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.tml": {
                    source: "iana",
                },
                "application/vnd.tmobile-livetv": {
                    source: "iana",
                    extensions: ["tmo"],
                },
                "application/vnd.tri.onesource": {
                    source: "iana",
                },
                "application/vnd.trid.tpt": {
                    source: "iana",
                    extensions: ["tpt"],
                },
                "application/vnd.triscape.mxs": {
                    source: "iana",
                    extensions: ["mxs"],
                },
                "application/vnd.trueapp": {
                    source: "iana",
                    extensions: ["tra"],
                },
                "application/vnd.truedoc": {
                    source: "iana",
                },
                "application/vnd.ubisoft.webplayer": {
                    source: "iana",
                },
                "application/vnd.ufdl": {
                    source: "iana",
                    extensions: ["ufd", "ufdl"],
                },
                "application/vnd.uiq.theme": {
                    source: "iana",
                    extensions: ["utz"],
                },
                "application/vnd.umajin": {
                    source: "iana",
                    extensions: ["umj"],
                },
                "application/vnd.unity": {
                    source: "iana",
                    extensions: ["unityweb"],
                },
                "application/vnd.uoml+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["uoml"],
                },
                "application/vnd.uplanet.alert": {
                    source: "iana",
                },
                "application/vnd.uplanet.alert-wbxml": {
                    source: "iana",
                },
                "application/vnd.uplanet.bearer-choice": {
                    source: "iana",
                },
                "application/vnd.uplanet.bearer-choice-wbxml": {
                    source: "iana",
                },
                "application/vnd.uplanet.cacheop": {
                    source: "iana",
                },
                "application/vnd.uplanet.cacheop-wbxml": {
                    source: "iana",
                },
                "application/vnd.uplanet.channel": {
                    source: "iana",
                },
                "application/vnd.uplanet.channel-wbxml": {
                    source: "iana",
                },
                "application/vnd.uplanet.list": {
                    source: "iana",
                },
                "application/vnd.uplanet.list-wbxml": {
                    source: "iana",
                },
                "application/vnd.uplanet.listcmd": {
                    source: "iana",
                },
                "application/vnd.uplanet.listcmd-wbxml": {
                    source: "iana",
                },
                "application/vnd.uplanet.signal": {
                    source: "iana",
                },
                "application/vnd.uri-map": {
                    source: "iana",
                },
                "application/vnd.valve.source.material": {
                    source: "iana",
                },
                "application/vnd.vcx": {
                    source: "iana",
                    extensions: ["vcx"],
                },
                "application/vnd.vd-study": {
                    source: "iana",
                },
                "application/vnd.vectorworks": {
                    source: "iana",
                },
                "application/vnd.vel+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.verimatrix.vcas": {
                    source: "iana",
                },
                "application/vnd.veryant.thin": {
                    source: "iana",
                },
                "application/vnd.ves.encrypted": {
                    source: "iana",
                },
                "application/vnd.vidsoft.vidconference": {
                    source: "iana",
                },
                "application/vnd.visio": {
                    source: "iana",
                    extensions: ["vsd", "vst", "vss", "vsw"],
                },
                "application/vnd.visionary": {
                    source: "iana",
                    extensions: ["vis"],
                },
                "application/vnd.vividence.scriptfile": {
                    source: "iana",
                },
                "application/vnd.vsf": {
                    source: "iana",
                    extensions: ["vsf"],
                },
                "application/vnd.wap.sic": {
                    source: "iana",
                },
                "application/vnd.wap.slc": {
                    source: "iana",
                },
                "application/vnd.wap.wbxml": {
                    source: "iana",
                    charset: "UTF-8",
                    extensions: ["wbxml"],
                },
                "application/vnd.wap.wmlc": {
                    source: "iana",
                    extensions: ["wmlc"],
                },
                "application/vnd.wap.wmlscriptc": {
                    source: "iana",
                    extensions: ["wmlsc"],
                },
                "application/vnd.webturbo": {
                    source: "iana",
                    extensions: ["wtb"],
                },
                "application/vnd.wfa.p2p": {
                    source: "iana",
                },
                "application/vnd.wfa.wsc": {
                    source: "iana",
                },
                "application/vnd.windows.devicepairing": {
                    source: "iana",
                },
                "application/vnd.wmc": {
                    source: "iana",
                },
                "application/vnd.wmf.bootstrap": {
                    source: "iana",
                },
                "application/vnd.wolfram.mathematica": {
                    source: "iana",
                },
                "application/vnd.wolfram.mathematica.package": {
                    source: "iana",
                },
                "application/vnd.wolfram.player": {
                    source: "iana",
                    extensions: ["nbp"],
                },
                "application/vnd.wordperfect": {
                    source: "iana",
                    extensions: ["wpd"],
                },
                "application/vnd.wqd": {
                    source: "iana",
                    extensions: ["wqd"],
                },
                "application/vnd.wrq-hp3000-labelled": {
                    source: "iana",
                },
                "application/vnd.wt.stf": {
                    source: "iana",
                    extensions: ["stf"],
                },
                "application/vnd.wv.csp+wbxml": {
                    source: "iana",
                },
                "application/vnd.wv.csp+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.wv.ssp+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.xacml+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.xara": {
                    source: "iana",
                    extensions: ["xar"],
                },
                "application/vnd.xfdl": {
                    source: "iana",
                    extensions: ["xfdl"],
                },
                "application/vnd.xfdl.webform": {
                    source: "iana",
                },
                "application/vnd.xmi+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.xmpie.cpkg": {
                    source: "iana",
                },
                "application/vnd.xmpie.dpkg": {
                    source: "iana",
                },
                "application/vnd.xmpie.plan": {
                    source: "iana",
                },
                "application/vnd.xmpie.ppkg": {
                    source: "iana",
                },
                "application/vnd.xmpie.xlim": {
                    source: "iana",
                },
                "application/vnd.yamaha.hv-dic": {
                    source: "iana",
                    extensions: ["hvd"],
                },
                "application/vnd.yamaha.hv-script": {
                    source: "iana",
                    extensions: ["hvs"],
                },
                "application/vnd.yamaha.hv-voice": {
                    source: "iana",
                    extensions: ["hvp"],
                },
                "application/vnd.yamaha.openscoreformat": {
                    source: "iana",
                    extensions: ["osf"],
                },
                "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["osfpvg"],
                },
                "application/vnd.yamaha.remote-setup": {
                    source: "iana",
                },
                "application/vnd.yamaha.smaf-audio": {
                    source: "iana",
                    extensions: ["saf"],
                },
                "application/vnd.yamaha.smaf-phrase": {
                    source: "iana",
                    extensions: ["spf"],
                },
                "application/vnd.yamaha.through-ngn": {
                    source: "iana",
                },
                "application/vnd.yamaha.tunnel-udpencap": {
                    source: "iana",
                },
                "application/vnd.yaoweme": {
                    source: "iana",
                },
                "application/vnd.yellowriver-custom-menu": {
                    source: "iana",
                    extensions: ["cmp"],
                },
                "application/vnd.youtube.yt": {
                    source: "iana",
                },
                "application/vnd.zul": {
                    source: "iana",
                    extensions: ["zir", "zirz"],
                },
                "application/vnd.zzazz.deck+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["zaz"],
                },
                "application/voicexml+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["vxml"],
                },
                "application/voucher-cms+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vq-rtcpxr": {
                    source: "iana",
                },
                "application/wasm": {
                    compressible: true,
                    extensions: ["wasm"],
                },
                "application/watcherinfo+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/webpush-options+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/whoispp-query": {
                    source: "iana",
                },
                "application/whoispp-response": {
                    source: "iana",
                },
                "application/widget": {
                    source: "iana",
                    extensions: ["wgt"],
                },
                "application/winhlp": {
                    source: "apache",
                    extensions: ["hlp"],
                },
                "application/wita": {
                    source: "iana",
                },
                "application/wordperfect5.1": {
                    source: "iana",
                },
                "application/wsdl+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["wsdl"],
                },
                "application/wspolicy+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["wspolicy"],
                },
                "application/x-7z-compressed": {
                    source: "apache",
                    compressible: false,
                    extensions: ["7z"],
                },
                "application/x-abiword": {
                    source: "apache",
                    extensions: ["abw"],
                },
                "application/x-ace-compressed": {
                    source: "apache",
                    extensions: ["ace"],
                },
                "application/x-amf": {
                    source: "apache",
                },
                "application/x-apple-diskimage": {
                    source: "apache",
                    extensions: ["dmg"],
                },
                "application/x-arj": {
                    compressible: false,
                    extensions: ["arj"],
                },
                "application/x-authorware-bin": {
                    source: "apache",
                    extensions: ["aab", "x32", "u32", "vox"],
                },
                "application/x-authorware-map": {
                    source: "apache",
                    extensions: ["aam"],
                },
                "application/x-authorware-seg": {
                    source: "apache",
                    extensions: ["aas"],
                },
                "application/x-bcpio": {
                    source: "apache",
                    extensions: ["bcpio"],
                },
                "application/x-bdoc": {
                    compressible: false,
                    extensions: ["bdoc"],
                },
                "application/x-bittorrent": {
                    source: "apache",
                    extensions: ["torrent"],
                },
                "application/x-blorb": {
                    source: "apache",
                    extensions: ["blb", "blorb"],
                },
                "application/x-bzip": {
                    source: "apache",
                    compressible: false,
                    extensions: ["bz"],
                },
                "application/x-bzip2": {
                    source: "apache",
                    compressible: false,
                    extensions: ["bz2", "boz"],
                },
                "application/x-cbr": {
                    source: "apache",
                    extensions: ["cbr", "cba", "cbt", "cbz", "cb7"],
                },
                "application/x-cdlink": {
                    source: "apache",
                    extensions: ["vcd"],
                },
                "application/x-cfs-compressed": {
                    source: "apache",
                    extensions: ["cfs"],
                },
                "application/x-chat": {
                    source: "apache",
                    extensions: ["chat"],
                },
                "application/x-chess-pgn": {
                    source: "apache",
                    extensions: ["pgn"],
                },
                "application/x-chrome-extension": {
                    extensions: ["crx"],
                },
                "application/x-cocoa": {
                    source: "nginx",
                    extensions: ["cco"],
                },
                "application/x-compress": {
                    source: "apache",
                },
                "application/x-conference": {
                    source: "apache",
                    extensions: ["nsc"],
                },
                "application/x-cpio": {
                    source: "apache",
                    extensions: ["cpio"],
                },
                "application/x-csh": {
                    source: "apache",
                    extensions: ["csh"],
                },
                "application/x-deb": {
                    compressible: false,
                },
                "application/x-debian-package": {
                    source: "apache",
                    extensions: ["deb", "udeb"],
                },
                "application/x-dgc-compressed": {
                    source: "apache",
                    extensions: ["dgc"],
                },
                "application/x-director": {
                    source: "apache",
                    extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"],
                },
                "application/x-doom": {
                    source: "apache",
                    extensions: ["wad"],
                },
                "application/x-dtbncx+xml": {
                    source: "apache",
                    compressible: true,
                    extensions: ["ncx"],
                },
                "application/x-dtbook+xml": {
                    source: "apache",
                    compressible: true,
                    extensions: ["dtb"],
                },
                "application/x-dtbresource+xml": {
                    source: "apache",
                    compressible: true,
                    extensions: ["res"],
                },
                "application/x-dvi": {
                    source: "apache",
                    compressible: false,
                    extensions: ["dvi"],
                },
                "application/x-envoy": {
                    source: "apache",
                    extensions: ["evy"],
                },
                "application/x-eva": {
                    source: "apache",
                    extensions: ["eva"],
                },
                "application/x-font-bdf": {
                    source: "apache",
                    extensions: ["bdf"],
                },
                "application/x-font-dos": {
                    source: "apache",
                },
                "application/x-font-framemaker": {
                    source: "apache",
                },
                "application/x-font-ghostscript": {
                    source: "apache",
                    extensions: ["gsf"],
                },
                "application/x-font-libgrx": {
                    source: "apache",
                },
                "application/x-font-linux-psf": {
                    source: "apache",
                    extensions: ["psf"],
                },
                "application/x-font-pcf": {
                    source: "apache",
                    extensions: ["pcf"],
                },
                "application/x-font-snf": {
                    source: "apache",
                    extensions: ["snf"],
                },
                "application/x-font-speedo": {
                    source: "apache",
                },
                "application/x-font-sunos-news": {
                    source: "apache",
                },
                "application/x-font-type1": {
                    source: "apache",
                    extensions: ["pfa", "pfb", "pfm", "afm"],
                },
                "application/x-font-vfont": {
                    source: "apache",
                },
                "application/x-freearc": {
                    source: "apache",
                    extensions: ["arc"],
                },
                "application/x-futuresplash": {
                    source: "apache",
                    extensions: ["spl"],
                },
                "application/x-gca-compressed": {
                    source: "apache",
                    extensions: ["gca"],
                },
                "application/x-glulx": {
                    source: "apache",
                    extensions: ["ulx"],
                },
                "application/x-gnumeric": {
                    source: "apache",
                    extensions: ["gnumeric"],
                },
                "application/x-gramps-xml": {
                    source: "apache",
                    extensions: ["gramps"],
                },
                "application/x-gtar": {
                    source: "apache",
                    extensions: ["gtar"],
                },
                "application/x-gzip": {
                    source: "apache",
                },
                "application/x-hdf": {
                    source: "apache",
                    extensions: ["hdf"],
                },
                "application/x-httpd-php": {
                    compressible: true,
                    extensions: ["php"],
                },
                "application/x-install-instructions": {
                    source: "apache",
                    extensions: ["install"],
                },
                "application/x-iso9660-image": {
                    source: "apache",
                    extensions: ["iso"],
                },
                "application/x-java-archive-diff": {
                    source: "nginx",
                    extensions: ["jardiff"],
                },
                "application/x-java-jnlp-file": {
                    source: "apache",
                    compressible: false,
                    extensions: ["jnlp"],
                },
                "application/x-javascript": {
                    compressible: true,
                },
                "application/x-keepass2": {
                    extensions: ["kdbx"],
                },
                "application/x-latex": {
                    source: "apache",
                    compressible: false,
                    extensions: ["latex"],
                },
                "application/x-lua-bytecode": {
                    extensions: ["luac"],
                },
                "application/x-lzh-compressed": {
                    source: "apache",
                    extensions: ["lzh", "lha"],
                },
                "application/x-makeself": {
                    source: "nginx",
                    extensions: ["run"],
                },
                "application/x-mie": {
                    source: "apache",
                    extensions: ["mie"],
                },
                "application/x-mobipocket-ebook": {
                    source: "apache",
                    extensions: ["prc", "mobi"],
                },
                "application/x-mpegurl": {
                    compressible: false,
                },
                "application/x-ms-application": {
                    source: "apache",
                    extensions: ["application"],
                },
                "application/x-ms-shortcut": {
                    source: "apache",
                    extensions: ["lnk"],
                },
                "application/x-ms-wmd": {
                    source: "apache",
                    extensions: ["wmd"],
                },
                "application/x-ms-wmz": {
                    source: "apache",
                    extensions: ["wmz"],
                },
                "application/x-ms-xbap": {
                    source: "apache",
                    extensions: ["xbap"],
                },
                "application/x-msaccess": {
                    source: "apache",
                    extensions: ["mdb"],
                },
                "application/x-msbinder": {
                    source: "apache",
                    extensions: ["obd"],
                },
                "application/x-mscardfile": {
                    source: "apache",
                    extensions: ["crd"],
                },
                "application/x-msclip": {
                    source: "apache",
                    extensions: ["clp"],
                },
                "application/x-msdos-program": {
                    extensions: ["exe"],
                },
                "application/x-msdownload": {
                    source: "apache",
                    extensions: ["exe", "dll", "com", "bat", "msi"],
                },
                "application/x-msmediaview": {
                    source: "apache",
                    extensions: ["mvb", "m13", "m14"],
                },
                "application/x-msmetafile": {
                    source: "apache",
                    extensions: ["wmf", "wmz", "emf", "emz"],
                },
                "application/x-msmoney": {
                    source: "apache",
                    extensions: ["mny"],
                },
                "application/x-mspublisher": {
                    source: "apache",
                    extensions: ["pub"],
                },
                "application/x-msschedule": {
                    source: "apache",
                    extensions: ["scd"],
                },
                "application/x-msterminal": {
                    source: "apache",
                    extensions: ["trm"],
                },
                "application/x-mswrite": {
                    source: "apache",
                    extensions: ["wri"],
                },
                "application/x-netcdf": {
                    source: "apache",
                    extensions: ["nc", "cdf"],
                },
                "application/x-ns-proxy-autoconfig": {
                    compressible: true,
                    extensions: ["pac"],
                },
                "application/x-nzb": {
                    source: "apache",
                    extensions: ["nzb"],
                },
                "application/x-perl": {
                    source: "nginx",
                    extensions: ["pl", "pm"],
                },
                "application/x-pilot": {
                    source: "nginx",
                    extensions: ["prc", "pdb"],
                },
                "application/x-pkcs12": {
                    source: "apache",
                    compressible: false,
                    extensions: ["p12", "pfx"],
                },
                "application/x-pkcs7-certificates": {
                    source: "apache",
                    extensions: ["p7b", "spc"],
                },
                "application/x-pkcs7-certreqresp": {
                    source: "apache",
                    extensions: ["p7r"],
                },
                "application/x-pki-message": {
                    source: "iana",
                },
                "application/x-rar-compressed": {
                    source: "apache",
                    compressible: false,
                    extensions: ["rar"],
                },
                "application/x-redhat-package-manager": {
                    source: "nginx",
                    extensions: ["rpm"],
                },
                "application/x-research-info-systems": {
                    source: "apache",
                    extensions: ["ris"],
                },
                "application/x-sea": {
                    source: "nginx",
                    extensions: ["sea"],
                },
                "application/x-sh": {
                    source: "apache",
                    compressible: true,
                    extensions: ["sh"],
                },
                "application/x-shar": {
                    source: "apache",
                    extensions: ["shar"],
                },
                "application/x-shockwave-flash": {
                    source: "apache",
                    compressible: false,
                    extensions: ["swf"],
                },
                "application/x-silverlight-app": {
                    source: "apache",
                    extensions: ["xap"],
                },
                "application/x-sql": {
                    source: "apache",
                    extensions: ["sql"],
                },
                "application/x-stuffit": {
                    source: "apache",
                    compressible: false,
                    extensions: ["sit"],
                },
                "application/x-stuffitx": {
                    source: "apache",
                    extensions: ["sitx"],
                },
                "application/x-subrip": {
                    source: "apache",
                    extensions: ["srt"],
                },
                "application/x-sv4cpio": {
                    source: "apache",
                    extensions: ["sv4cpio"],
                },
                "application/x-sv4crc": {
                    source: "apache",
                    extensions: ["sv4crc"],
                },
                "application/x-t3vm-image": {
                    source: "apache",
                    extensions: ["t3"],
                },
                "application/x-tads": {
                    source: "apache",
                    extensions: ["gam"],
                },
                "application/x-tar": {
                    source: "apache",
                    compressible: true,
                    extensions: ["tar"],
                },
                "application/x-tcl": {
                    source: "apache",
                    extensions: ["tcl", "tk"],
                },
                "application/x-tex": {
                    source: "apache",
                    extensions: ["tex"],
                },
                "application/x-tex-tfm": {
                    source: "apache",
                    extensions: ["tfm"],
                },
                "application/x-texinfo": {
                    source: "apache",
                    extensions: ["texinfo", "texi"],
                },
                "application/x-tgif": {
                    source: "apache",
                    extensions: ["obj"],
                },
                "application/x-ustar": {
                    source: "apache",
                    extensions: ["ustar"],
                },
                "application/x-virtualbox-hdd": {
                    compressible: true,
                    extensions: ["hdd"],
                },
                "application/x-virtualbox-ova": {
                    compressible: true,
                    extensions: ["ova"],
                },
                "application/x-virtualbox-ovf": {
                    compressible: true,
                    extensions: ["ovf"],
                },
                "application/x-virtualbox-vbox": {
                    compressible: true,
                    extensions: ["vbox"],
                },
                "application/x-virtualbox-vbox-extpack": {
                    compressible: false,
                    extensions: ["vbox-extpack"],
                },
                "application/x-virtualbox-vdi": {
                    compressible: true,
                    extensions: ["vdi"],
                },
                "application/x-virtualbox-vhd": {
                    compressible: true,
                    extensions: ["vhd"],
                },
                "application/x-virtualbox-vmdk": {
                    compressible: true,
                    extensions: ["vmdk"],
                },
                "application/x-wais-source": {
                    source: "apache",
                    extensions: ["src"],
                },
                "application/x-web-app-manifest+json": {
                    compressible: true,
                    extensions: ["webapp"],
                },
                "application/x-www-form-urlencoded": {
                    source: "iana",
                    compressible: true,
                },
                "application/x-x509-ca-cert": {
                    source: "iana",
                    extensions: ["der", "crt", "pem"],
                },
                "application/x-x509-ca-ra-cert": {
                    source: "iana",
                },
                "application/x-x509-next-ca-cert": {
                    source: "iana",
                },
                "application/x-xfig": {
                    source: "apache",
                    extensions: ["fig"],
                },
                "application/x-xliff+xml": {
                    source: "apache",
                    compressible: true,
                    extensions: ["xlf"],
                },
                "application/x-xpinstall": {
                    source: "apache",
                    compressible: false,
                    extensions: ["xpi"],
                },
                "application/x-xz": {
                    source: "apache",
                    extensions: ["xz"],
                },
                "application/x-zmachine": {
                    source: "apache",
                    extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"],
                },
                "application/x400-bp": {
                    source: "iana",
                },
                "application/xacml+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/xaml+xml": {
                    source: "apache",
                    compressible: true,
                    extensions: ["xaml"],
                },
                "application/xcap-att+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["xav"],
                },
                "application/xcap-caps+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["xca"],
                },
                "application/xcap-diff+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["xdf"],
                },
                "application/xcap-el+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["xel"],
                },
                "application/xcap-error+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["xer"],
                },
                "application/xcap-ns+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["xns"],
                },
                "application/xcon-conference-info+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/xcon-conference-info-diff+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/xenc+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["xenc"],
                },
                "application/xhtml+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["xhtml", "xht"],
                },
                "application/xhtml-voice+xml": {
                    source: "apache",
                    compressible: true,
                },
                "application/xliff+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["xlf"],
                },
                "application/xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["xml", "xsl", "xsd", "rng"],
                },
                "application/xml-dtd": {
                    source: "iana",
                    compressible: true,
                    extensions: ["dtd"],
                },
                "application/xml-external-parsed-entity": {
                    source: "iana",
                },
                "application/xml-patch+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/xmpp+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/xop+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["xop"],
                },
                "application/xproc+xml": {
                    source: "apache",
                    compressible: true,
                    extensions: ["xpl"],
                },
                "application/xslt+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["xslt"],
                },
                "application/xspf+xml": {
                    source: "apache",
                    compressible: true,
                    extensions: ["xspf"],
                },
                "application/xv+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["mxml", "xhvml", "xvml", "xvm"],
                },
                "application/yang": {
                    source: "iana",
                    extensions: ["yang"],
                },
                "application/yang-data+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/yang-data+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/yang-patch+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/yang-patch+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/yin+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["yin"],
                },
                "application/zip": {
                    source: "iana",
                    compressible: false,
                    extensions: ["zip"],
                },
                "application/zlib": {
                    source: "iana",
                },
                "application/zstd": {
                    source: "iana",
                },
                "audio/1d-interleaved-parityfec": {
                    source: "iana",
                },
                "audio/32kadpcm": {
                    source: "iana",
                },
                "audio/3gpp": {
                    source: "iana",
                    compressible: false,
                    extensions: ["3gpp"],
                },
                "audio/3gpp2": {
                    source: "iana",
                },
                "audio/aac": {
                    source: "iana",
                },
                "audio/ac3": {
                    source: "iana",
                },
                "audio/adpcm": {
                    source: "apache",
                    extensions: ["adp"],
                },
                "audio/amr": {
                    source: "iana",
                },
                "audio/amr-wb": {
                    source: "iana",
                },
                "audio/amr-wb+": {
                    source: "iana",
                },
                "audio/aptx": {
                    source: "iana",
                },
                "audio/asc": {
                    source: "iana",
                },
                "audio/atrac-advanced-lossless": {
                    source: "iana",
                },
                "audio/atrac-x": {
                    source: "iana",
                },
                "audio/atrac3": {
                    source: "iana",
                },
                "audio/basic": {
                    source: "iana",
                    compressible: false,
                    extensions: ["au", "snd"],
                },
                "audio/bv16": {
                    source: "iana",
                },
                "audio/bv32": {
                    source: "iana",
                },
                "audio/clearmode": {
                    source: "iana",
                },
                "audio/cn": {
                    source: "iana",
                },
                "audio/dat12": {
                    source: "iana",
                },
                "audio/dls": {
                    source: "iana",
                },
                "audio/dsr-es201108": {
                    source: "iana",
                },
                "audio/dsr-es202050": {
                    source: "iana",
                },
                "audio/dsr-es202211": {
                    source: "iana",
                },
                "audio/dsr-es202212": {
                    source: "iana",
                },
                "audio/dv": {
                    source: "iana",
                },
                "audio/dvi4": {
                    source: "iana",
                },
                "audio/eac3": {
                    source: "iana",
                },
                "audio/encaprtp": {
                    source: "iana",
                },
                "audio/evrc": {
                    source: "iana",
                },
                "audio/evrc-qcp": {
                    source: "iana",
                },
                "audio/evrc0": {
                    source: "iana",
                },
                "audio/evrc1": {
                    source: "iana",
                },
                "audio/evrcb": {
                    source: "iana",
                },
                "audio/evrcb0": {
                    source: "iana",
                },
                "audio/evrcb1": {
                    source: "iana",
                },
                "audio/evrcnw": {
                    source: "iana",
                },
                "audio/evrcnw0": {
                    source: "iana",
                },
                "audio/evrcnw1": {
                    source: "iana",
                },
                "audio/evrcwb": {
                    source: "iana",
                },
                "audio/evrcwb0": {
                    source: "iana",
                },
                "audio/evrcwb1": {
                    source: "iana",
                },
                "audio/evs": {
                    source: "iana",
                },
                "audio/flexfec": {
                    source: "iana",
                },
                "audio/fwdred": {
                    source: "iana",
                },
                "audio/g711-0": {
                    source: "iana",
                },
                "audio/g719": {
                    source: "iana",
                },
                "audio/g722": {
                    source: "iana",
                },
                "audio/g7221": {
                    source: "iana",
                },
                "audio/g723": {
                    source: "iana",
                },
                "audio/g726-16": {
                    source: "iana",
                },
                "audio/g726-24": {
                    source: "iana",
                },
                "audio/g726-32": {
                    source: "iana",
                },
                "audio/g726-40": {
                    source: "iana",
                },
                "audio/g728": {
                    source: "iana",
                },
                "audio/g729": {
                    source: "iana",
                },
                "audio/g7291": {
                    source: "iana",
                },
                "audio/g729d": {
                    source: "iana",
                },
                "audio/g729e": {
                    source: "iana",
                },
                "audio/gsm": {
                    source: "iana",
                },
                "audio/gsm-efr": {
                    source: "iana",
                },
                "audio/gsm-hr-08": {
                    source: "iana",
                },
                "audio/ilbc": {
                    source: "iana",
                },
                "audio/ip-mr_v2.5": {
                    source: "iana",
                },
                "audio/isac": {
                    source: "apache",
                },
                "audio/l16": {
                    source: "iana",
                },
                "audio/l20": {
                    source: "iana",
                },
                "audio/l24": {
                    source: "iana",
                    compressible: false,
                },
                "audio/l8": {
                    source: "iana",
                },
                "audio/lpc": {
                    source: "iana",
                },
                "audio/melp": {
                    source: "iana",
                },
                "audio/melp1200": {
                    source: "iana",
                },
                "audio/melp2400": {
                    source: "iana",
                },
                "audio/melp600": {
                    source: "iana",
                },
                "audio/mhas": {
                    source: "iana",
                },
                "audio/midi": {
                    source: "apache",
                    extensions: ["mid", "midi", "kar", "rmi"],
                },
                "audio/mobile-xmf": {
                    source: "iana",
                    extensions: ["mxmf"],
                },
                "audio/mp3": {
                    compressible: false,
                    extensions: ["mp3"],
                },
                "audio/mp4": {
                    source: "iana",
                    compressible: false,
                    extensions: ["m4a", "mp4a"],
                },
                "audio/mp4a-latm": {
                    source: "iana",
                },
                "audio/mpa": {
                    source: "iana",
                },
                "audio/mpa-robust": {
                    source: "iana",
                },
                "audio/mpeg": {
                    source: "iana",
                    compressible: false,
                    extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"],
                },
                "audio/mpeg4-generic": {
                    source: "iana",
                },
                "audio/musepack": {
                    source: "apache",
                },
                "audio/ogg": {
                    source: "iana",
                    compressible: false,
                    extensions: ["oga", "ogg", "spx"],
                },
                "audio/opus": {
                    source: "iana",
                },
                "audio/parityfec": {
                    source: "iana",
                },
                "audio/pcma": {
                    source: "iana",
                },
                "audio/pcma-wb": {
                    source: "iana",
                },
                "audio/pcmu": {
                    source: "iana",
                },
                "audio/pcmu-wb": {
                    source: "iana",
                },
                "audio/prs.sid": {
                    source: "iana",
                },
                "audio/qcelp": {
                    source: "iana",
                },
                "audio/raptorfec": {
                    source: "iana",
                },
                "audio/red": {
                    source: "iana",
                },
                "audio/rtp-enc-aescm128": {
                    source: "iana",
                },
                "audio/rtp-midi": {
                    source: "iana",
                },
                "audio/rtploopback": {
                    source: "iana",
                },
                "audio/rtx": {
                    source: "iana",
                },
                "audio/s3m": {
                    source: "apache",
                    extensions: ["s3m"],
                },
                "audio/silk": {
                    source: "apache",
                    extensions: ["sil"],
                },
                "audio/smv": {
                    source: "iana",
                },
                "audio/smv-qcp": {
                    source: "iana",
                },
                "audio/smv0": {
                    source: "iana",
                },
                "audio/sp-midi": {
                    source: "iana",
                },
                "audio/speex": {
                    source: "iana",
                },
                "audio/t140c": {
                    source: "iana",
                },
                "audio/t38": {
                    source: "iana",
                },
                "audio/telephone-event": {
                    source: "iana",
                },
                "audio/tetra_acelp": {
                    source: "iana",
                },
                "audio/tetra_acelp_bb": {
                    source: "iana",
                },
                "audio/tone": {
                    source: "iana",
                },
                "audio/uemclip": {
                    source: "iana",
                },
                "audio/ulpfec": {
                    source: "iana",
                },
                "audio/usac": {
                    source: "iana",
                },
                "audio/vdvi": {
                    source: "iana",
                },
                "audio/vmr-wb": {
                    source: "iana",
                },
                "audio/vnd.3gpp.iufp": {
                    source: "iana",
                },
                "audio/vnd.4sb": {
                    source: "iana",
                },
                "audio/vnd.audiokoz": {
                    source: "iana",
                },
                "audio/vnd.celp": {
                    source: "iana",
                },
                "audio/vnd.cisco.nse": {
                    source: "iana",
                },
                "audio/vnd.cmles.radio-events": {
                    source: "iana",
                },
                "audio/vnd.cns.anp1": {
                    source: "iana",
                },
                "audio/vnd.cns.inf1": {
                    source: "iana",
                },
                "audio/vnd.dece.audio": {
                    source: "iana",
                    extensions: ["uva", "uvva"],
                },
                "audio/vnd.digital-winds": {
                    source: "iana",
                    extensions: ["eol"],
                },
                "audio/vnd.dlna.adts": {
                    source: "iana",
                },
                "audio/vnd.dolby.heaac.1": {
                    source: "iana",
                },
                "audio/vnd.dolby.heaac.2": {
                    source: "iana",
                },
                "audio/vnd.dolby.mlp": {
                    source: "iana",
                },
                "audio/vnd.dolby.mps": {
                    source: "iana",
                },
                "audio/vnd.dolby.pl2": {
                    source: "iana",
                },
                "audio/vnd.dolby.pl2x": {
                    source: "iana",
                },
                "audio/vnd.dolby.pl2z": {
                    source: "iana",
                },
                "audio/vnd.dolby.pulse.1": {
                    source: "iana",
                },
                "audio/vnd.dra": {
                    source: "iana",
                    extensions: ["dra"],
                },
                "audio/vnd.dts": {
                    source: "iana",
                    extensions: ["dts"],
                },
                "audio/vnd.dts.hd": {
                    source: "iana",
                    extensions: ["dtshd"],
                },
                "audio/vnd.dts.uhd": {
                    source: "iana",
                },
                "audio/vnd.dvb.file": {
                    source: "iana",
                },
                "audio/vnd.everad.plj": {
                    source: "iana",
                },
                "audio/vnd.hns.audio": {
                    source: "iana",
                },
                "audio/vnd.lucent.voice": {
                    source: "iana",
                    extensions: ["lvp"],
                },
                "audio/vnd.ms-playready.media.pya": {
                    source: "iana",
                    extensions: ["pya"],
                },
                "audio/vnd.nokia.mobile-xmf": {
                    source: "iana",
                },
                "audio/vnd.nortel.vbk": {
                    source: "iana",
                },
                "audio/vnd.nuera.ecelp4800": {
                    source: "iana",
                    extensions: ["ecelp4800"],
                },
                "audio/vnd.nuera.ecelp7470": {
                    source: "iana",
                    extensions: ["ecelp7470"],
                },
                "audio/vnd.nuera.ecelp9600": {
                    source: "iana",
                    extensions: ["ecelp9600"],
                },
                "audio/vnd.octel.sbc": {
                    source: "iana",
                },
                "audio/vnd.presonus.multitrack": {
                    source: "iana",
                },
                "audio/vnd.qcelp": {
                    source: "iana",
                },
                "audio/vnd.rhetorex.32kadpcm": {
                    source: "iana",
                },
                "audio/vnd.rip": {
                    source: "iana",
                    extensions: ["rip"],
                },
                "audio/vnd.rn-realaudio": {
                    compressible: false,
                },
                "audio/vnd.sealedmedia.softseal.mpeg": {
                    source: "iana",
                },
                "audio/vnd.vmx.cvsd": {
                    source: "iana",
                },
                "audio/vnd.wave": {
                    compressible: false,
                },
                "audio/vorbis": {
                    source: "iana",
                    compressible: false,
                },
                "audio/vorbis-config": {
                    source: "iana",
                },
                "audio/wav": {
                    compressible: false,
                    extensions: ["wav"],
                },
                "audio/wave": {
                    compressible: false,
                    extensions: ["wav"],
                },
                "audio/webm": {
                    source: "apache",
                    compressible: false,
                    extensions: ["weba"],
                },
                "audio/x-aac": {
                    source: "apache",
                    compressible: false,
                    extensions: ["aac"],
                },
                "audio/x-aiff": {
                    source: "apache",
                    extensions: ["aif", "aiff", "aifc"],
                },
                "audio/x-caf": {
                    source: "apache",
                    compressible: false,
                    extensions: ["caf"],
                },
                "audio/x-flac": {
                    source: "apache",
                    extensions: ["flac"],
                },
                "audio/x-m4a": {
                    source: "nginx",
                    extensions: ["m4a"],
                },
                "audio/x-matroska": {
                    source: "apache",
                    extensions: ["mka"],
                },
                "audio/x-mpegurl": {
                    source: "apache",
                    extensions: ["m3u"],
                },
                "audio/x-ms-wax": {
                    source: "apache",
                    extensions: ["wax"],
                },
                "audio/x-ms-wma": {
                    source: "apache",
                    extensions: ["wma"],
                },
                "audio/x-pn-realaudio": {
                    source: "apache",
                    extensions: ["ram", "ra"],
                },
                "audio/x-pn-realaudio-plugin": {
                    source: "apache",
                    extensions: ["rmp"],
                },
                "audio/x-realaudio": {
                    source: "nginx",
                    extensions: ["ra"],
                },
                "audio/x-tta": {
                    source: "apache",
                },
                "audio/x-wav": {
                    source: "apache",
                    extensions: ["wav"],
                },
                "audio/xm": {
                    source: "apache",
                    extensions: ["xm"],
                },
                "chemical/x-cdx": {
                    source: "apache",
                    extensions: ["cdx"],
                },
                "chemical/x-cif": {
                    source: "apache",
                    extensions: ["cif"],
                },
                "chemical/x-cmdf": {
                    source: "apache",
                    extensions: ["cmdf"],
                },
                "chemical/x-cml": {
                    source: "apache",
                    extensions: ["cml"],
                },
                "chemical/x-csml": {
                    source: "apache",
                    extensions: ["csml"],
                },
                "chemical/x-pdb": {
                    source: "apache",
                },
                "chemical/x-xyz": {
                    source: "apache",
                    extensions: ["xyz"],
                },
                "font/collection": {
                    source: "iana",
                    extensions: ["ttc"],
                },
                "font/otf": {
                    source: "iana",
                    compressible: true,
                    extensions: ["otf"],
                },
                "font/sfnt": {
                    source: "iana",
                },
                "font/ttf": {
                    source: "iana",
                    compressible: true,
                    extensions: ["ttf"],
                },
                "font/woff": {
                    source: "iana",
                    extensions: ["woff"],
                },
                "font/woff2": {
                    source: "iana",
                    extensions: ["woff2"],
                },
                "image/aces": {
                    source: "iana",
                    extensions: ["exr"],
                },
                "image/apng": {
                    compressible: false,
                    extensions: ["apng"],
                },
                "image/avci": {
                    source: "iana",
                },
                "image/avcs": {
                    source: "iana",
                },
                "image/bmp": {
                    source: "iana",
                    compressible: true,
                    extensions: ["bmp"],
                },
                "image/cgm": {
                    source: "iana",
                    extensions: ["cgm"],
                },
                "image/dicom-rle": {
                    source: "iana",
                    extensions: ["drle"],
                },
                "image/emf": {
                    source: "iana",
                    extensions: ["emf"],
                },
                "image/fits": {
                    source: "iana",
                    extensions: ["fits"],
                },
                "image/g3fax": {
                    source: "iana",
                    extensions: ["g3"],
                },
                "image/gif": {
                    source: "iana",
                    compressible: false,
                    extensions: ["gif"],
                },
                "image/heic": {
                    source: "iana",
                    extensions: ["heic"],
                },
                "image/heic-sequence": {
                    source: "iana",
                    extensions: ["heics"],
                },
                "image/heif": {
                    source: "iana",
                    extensions: ["heif"],
                },
                "image/heif-sequence": {
                    source: "iana",
                    extensions: ["heifs"],
                },
                "image/hej2k": {
                    source: "iana",
                    extensions: ["hej2"],
                },
                "image/hsj2": {
                    source: "iana",
                    extensions: ["hsj2"],
                },
                "image/ief": {
                    source: "iana",
                    extensions: ["ief"],
                },
                "image/jls": {
                    source: "iana",
                    extensions: ["jls"],
                },
                "image/jp2": {
                    source: "iana",
                    compressible: false,
                    extensions: ["jp2", "jpg2"],
                },
                "image/jpeg": {
                    source: "iana",
                    compressible: false,
                    extensions: ["jpeg", "jpg", "jpe"],
                },
                "image/jph": {
                    source: "iana",
                    extensions: ["jph"],
                },
                "image/jphc": {
                    source: "iana",
                    extensions: ["jhc"],
                },
                "image/jpm": {
                    source: "iana",
                    compressible: false,
                    extensions: ["jpm"],
                },
                "image/jpx": {
                    source: "iana",
                    compressible: false,
                    extensions: ["jpx", "jpf"],
                },
                "image/jxr": {
                    source: "iana",
                    extensions: ["jxr"],
                },
                "image/jxra": {
                    source: "iana",
                    extensions: ["jxra"],
                },
                "image/jxrs": {
                    source: "iana",
                    extensions: ["jxrs"],
                },
                "image/jxs": {
                    source: "iana",
                    extensions: ["jxs"],
                },
                "image/jxsc": {
                    source: "iana",
                    extensions: ["jxsc"],
                },
                "image/jxsi": {
                    source: "iana",
                    extensions: ["jxsi"],
                },
                "image/jxss": {
                    source: "iana",
                    extensions: ["jxss"],
                },
                "image/ktx": {
                    source: "iana",
                    extensions: ["ktx"],
                },
                "image/naplps": {
                    source: "iana",
                },
                "image/pjpeg": {
                    compressible: false,
                },
                "image/png": {
                    source: "iana",
                    compressible: false,
                    extensions: ["png"],
                },
                "image/prs.btif": {
                    source: "iana",
                    extensions: ["btif"],
                },
                "image/prs.pti": {
                    source: "iana",
                    extensions: ["pti"],
                },
                "image/pwg-raster": {
                    source: "iana",
                },
                "image/sgi": {
                    source: "apache",
                    extensions: ["sgi"],
                },
                "image/svg+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["svg", "svgz"],
                },
                "image/t38": {
                    source: "iana",
                    extensions: ["t38"],
                },
                "image/tiff": {
                    source: "iana",
                    compressible: false,
                    extensions: ["tif", "tiff"],
                },
                "image/tiff-fx": {
                    source: "iana",
                    extensions: ["tfx"],
                },
                "image/vnd.adobe.photoshop": {
                    source: "iana",
                    compressible: true,
                    extensions: ["psd"],
                },
                "image/vnd.airzip.accelerator.azv": {
                    source: "iana",
                    extensions: ["azv"],
                },
                "image/vnd.cns.inf2": {
                    source: "iana",
                },
                "image/vnd.dece.graphic": {
                    source: "iana",
                    extensions: ["uvi", "uvvi", "uvg", "uvvg"],
                },
                "image/vnd.djvu": {
                    source: "iana",
                    extensions: ["djvu", "djv"],
                },
                "image/vnd.dvb.subtitle": {
                    source: "iana",
                    extensions: ["sub"],
                },
                "image/vnd.dwg": {
                    source: "iana",
                    extensions: ["dwg"],
                },
                "image/vnd.dxf": {
                    source: "iana",
                    extensions: ["dxf"],
                },
                "image/vnd.fastbidsheet": {
                    source: "iana",
                    extensions: ["fbs"],
                },
                "image/vnd.fpx": {
                    source: "iana",
                    extensions: ["fpx"],
                },
                "image/vnd.fst": {
                    source: "iana",
                    extensions: ["fst"],
                },
                "image/vnd.fujixerox.edmics-mmr": {
                    source: "iana",
                    extensions: ["mmr"],
                },
                "image/vnd.fujixerox.edmics-rlc": {
                    source: "iana",
                    extensions: ["rlc"],
                },
                "image/vnd.globalgraphics.pgb": {
                    source: "iana",
                },
                "image/vnd.microsoft.icon": {
                    source: "iana",
                    extensions: ["ico"],
                },
                "image/vnd.mix": {
                    source: "iana",
                },
                "image/vnd.mozilla.apng": {
                    source: "iana",
                },
                "image/vnd.ms-dds": {
                    extensions: ["dds"],
                },
                "image/vnd.ms-modi": {
                    source: "iana",
                    extensions: ["mdi"],
                },
                "image/vnd.ms-photo": {
                    source: "apache",
                    extensions: ["wdp"],
                },
                "image/vnd.net-fpx": {
                    source: "iana",
                    extensions: ["npx"],
                },
                "image/vnd.radiance": {
                    source: "iana",
                },
                "image/vnd.sealed.png": {
                    source: "iana",
                },
                "image/vnd.sealedmedia.softseal.gif": {
                    source: "iana",
                },
                "image/vnd.sealedmedia.softseal.jpg": {
                    source: "iana",
                },
                "image/vnd.svf": {
                    source: "iana",
                },
                "image/vnd.tencent.tap": {
                    source: "iana",
                    extensions: ["tap"],
                },
                "image/vnd.valve.source.texture": {
                    source: "iana",
                    extensions: ["vtf"],
                },
                "image/vnd.wap.wbmp": {
                    source: "iana",
                    extensions: ["wbmp"],
                },
                "image/vnd.xiff": {
                    source: "iana",
                    extensions: ["xif"],
                },
                "image/vnd.zbrush.pcx": {
                    source: "iana",
                    extensions: ["pcx"],
                },
                "image/webp": {
                    source: "apache",
                    extensions: ["webp"],
                },
                "image/wmf": {
                    source: "iana",
                    extensions: ["wmf"],
                },
                "image/x-3ds": {
                    source: "apache",
                    extensions: ["3ds"],
                },
                "image/x-cmu-raster": {
                    source: "apache",
                    extensions: ["ras"],
                },
                "image/x-cmx": {
                    source: "apache",
                    extensions: ["cmx"],
                },
                "image/x-freehand": {
                    source: "apache",
                    extensions: ["fh", "fhc", "fh4", "fh5", "fh7"],
                },
                "image/x-icon": {
                    source: "apache",
                    compressible: true,
                    extensions: ["ico"],
                },
                "image/x-jng": {
                    source: "nginx",
                    extensions: ["jng"],
                },
                "image/x-mrsid-image": {
                    source: "apache",
                    extensions: ["sid"],
                },
                "image/x-ms-bmp": {
                    source: "nginx",
                    compressible: true,
                    extensions: ["bmp"],
                },
                "image/x-pcx": {
                    source: "apache",
                    extensions: ["pcx"],
                },
                "image/x-pict": {
                    source: "apache",
                    extensions: ["pic", "pct"],
                },
                "image/x-portable-anymap": {
                    source: "apache",
                    extensions: ["pnm"],
                },
                "image/x-portable-bitmap": {
                    source: "apache",
                    extensions: ["pbm"],
                },
                "image/x-portable-graymap": {
                    source: "apache",
                    extensions: ["pgm"],
                },
                "image/x-portable-pixmap": {
                    source: "apache",
                    extensions: ["ppm"],
                },
                "image/x-rgb": {
                    source: "apache",
                    extensions: ["rgb"],
                },
                "image/x-tga": {
                    source: "apache",
                    extensions: ["tga"],
                },
                "image/x-xbitmap": {
                    source: "apache",
                    extensions: ["xbm"],
                },
                "image/x-xcf": {
                    compressible: false,
                },
                "image/x-xpixmap": {
                    source: "apache",
                    extensions: ["xpm"],
                },
                "image/x-xwindowdump": {
                    source: "apache",
                    extensions: ["xwd"],
                },
                "message/cpim": {
                    source: "iana",
                },
                "message/delivery-status": {
                    source: "iana",
                },
                "message/disposition-notification": {
                    source: "iana",
                    extensions: ["disposition-notification"],
                },
                "message/external-body": {
                    source: "iana",
                },
                "message/feedback-report": {
                    source: "iana",
                },
                "message/global": {
                    source: "iana",
                    extensions: ["u8msg"],
                },
                "message/global-delivery-status": {
                    source: "iana",
                    extensions: ["u8dsn"],
                },
                "message/global-disposition-notification": {
                    source: "iana",
                    extensions: ["u8mdn"],
                },
                "message/global-headers": {
                    source: "iana",
                    extensions: ["u8hdr"],
                },
                "message/http": {
                    source: "iana",
                    compressible: false,
                },
                "message/imdn+xml": {
                    source: "iana",
                    compressible: true,
                },
                "message/news": {
                    source: "iana",
                },
                "message/partial": {
                    source: "iana",
                    compressible: false,
                },
                "message/rfc822": {
                    source: "iana",
                    compressible: true,
                    extensions: ["eml", "mime"],
                },
                "message/s-http": {
                    source: "iana",
                },
                "message/sip": {
                    source: "iana",
                },
                "message/sipfrag": {
                    source: "iana",
                },
                "message/tracking-status": {
                    source: "iana",
                },
                "message/vnd.si.simp": {
                    source: "iana",
                },
                "message/vnd.wfa.wsc": {
                    source: "iana",
                    extensions: ["wsc"],
                },
                "model/3mf": {
                    source: "iana",
                    extensions: ["3mf"],
                },
                "model/gltf+json": {
                    source: "iana",
                    compressible: true,
                    extensions: ["gltf"],
                },
                "model/gltf-binary": {
                    source: "iana",
                    compressible: true,
                    extensions: ["glb"],
                },
                "model/iges": {
                    source: "iana",
                    compressible: false,
                    extensions: ["igs", "iges"],
                },
                "model/mesh": {
                    source: "iana",
                    compressible: false,
                    extensions: ["msh", "mesh", "silo"],
                },
                "model/mtl": {
                    source: "iana",
                    extensions: ["mtl"],
                },
                "model/obj": {
                    source: "iana",
                    extensions: ["obj"],
                },
                "model/stl": {
                    source: "iana",
                    extensions: ["stl"],
                },
                "model/vnd.collada+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["dae"],
                },
                "model/vnd.dwf": {
                    source: "iana",
                    extensions: ["dwf"],
                },
                "model/vnd.flatland.3dml": {
                    source: "iana",
                },
                "model/vnd.gdl": {
                    source: "iana",
                    extensions: ["gdl"],
                },
                "model/vnd.gs-gdl": {
                    source: "apache",
                },
                "model/vnd.gs.gdl": {
                    source: "iana",
                },
                "model/vnd.gtw": {
                    source: "iana",
                    extensions: ["gtw"],
                },
                "model/vnd.moml+xml": {
                    source: "iana",
                    compressible: true,
                },
                "model/vnd.mts": {
                    source: "iana",
                    extensions: ["mts"],
                },
                "model/vnd.opengex": {
                    source: "iana",
                    extensions: ["ogex"],
                },
                "model/vnd.parasolid.transmit.binary": {
                    source: "iana",
                    extensions: ["x_b"],
                },
                "model/vnd.parasolid.transmit.text": {
                    source: "iana",
                    extensions: ["x_t"],
                },
                "model/vnd.rosette.annotated-data-model": {
                    source: "iana",
                },
                "model/vnd.usdz+zip": {
                    source: "iana",
                    compressible: false,
                    extensions: ["usdz"],
                },
                "model/vnd.valve.source.compiled-map": {
                    source: "iana",
                    extensions: ["bsp"],
                },
                "model/vnd.vtu": {
                    source: "iana",
                    extensions: ["vtu"],
                },
                "model/vrml": {
                    source: "iana",
                    compressible: false,
                    extensions: ["wrl", "vrml"],
                },
                "model/x3d+binary": {
                    source: "apache",
                    compressible: false,
                    extensions: ["x3db", "x3dbz"],
                },
                "model/x3d+fastinfoset": {
                    source: "iana",
                    extensions: ["x3db"],
                },
                "model/x3d+vrml": {
                    source: "apache",
                    compressible: false,
                    extensions: ["x3dv", "x3dvz"],
                },
                "model/x3d+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["x3d", "x3dz"],
                },
                "model/x3d-vrml": {
                    source: "iana",
                    extensions: ["x3dv"],
                },
                "multipart/alternative": {
                    source: "iana",
                    compressible: false,
                },
                "multipart/appledouble": {
                    source: "iana",
                },
                "multipart/byteranges": {
                    source: "iana",
                },
                "multipart/digest": {
                    source: "iana",
                },
                "multipart/encrypted": {
                    source: "iana",
                    compressible: false,
                },
                "multipart/form-data": {
                    source: "iana",
                    compressible: false,
                },
                "multipart/header-set": {
                    source: "iana",
                },
                "multipart/mixed": {
                    source: "iana",
                },
                "multipart/multilingual": {
                    source: "iana",
                },
                "multipart/parallel": {
                    source: "iana",
                },
                "multipart/related": {
                    source: "iana",
                    compressible: false,
                },
                "multipart/report": {
                    source: "iana",
                },
                "multipart/signed": {
                    source: "iana",
                    compressible: false,
                },
                "multipart/vnd.bint.med-plus": {
                    source: "iana",
                },
                "multipart/voice-message": {
                    source: "iana",
                },
                "multipart/x-mixed-replace": {
                    source: "iana",
                },
                "text/1d-interleaved-parityfec": {
                    source: "iana",
                },
                "text/cache-manifest": {
                    source: "iana",
                    compressible: true,
                    extensions: ["appcache", "manifest"],
                },
                "text/calendar": {
                    source: "iana",
                    extensions: ["ics", "ifb"],
                },
                "text/calender": {
                    compressible: true,
                },
                "text/cmd": {
                    compressible: true,
                },
                "text/coffeescript": {
                    extensions: ["coffee", "litcoffee"],
                },
                "text/css": {
                    source: "iana",
                    charset: "UTF-8",
                    compressible: true,
                    extensions: ["css"],
                },
                "text/csv": {
                    source: "iana",
                    compressible: true,
                    extensions: ["csv"],
                },
                "text/csv-schema": {
                    source: "iana",
                },
                "text/directory": {
                    source: "iana",
                },
                "text/dns": {
                    source: "iana",
                },
                "text/ecmascript": {
                    source: "iana",
                },
                "text/encaprtp": {
                    source: "iana",
                },
                "text/enriched": {
                    source: "iana",
                },
                "text/flexfec": {
                    source: "iana",
                },
                "text/fwdred": {
                    source: "iana",
                },
                "text/grammar-ref-list": {
                    source: "iana",
                },
                "text/html": {
                    source: "iana",
                    compressible: true,
                    extensions: ["html", "htm", "shtml"],
                },
                "text/jade": {
                    extensions: ["jade"],
                },
                "text/javascript": {
                    source: "iana",
                    compressible: true,
                },
                "text/jcr-cnd": {
                    source: "iana",
                },
                "text/jsx": {
                    compressible: true,
                    extensions: ["jsx"],
                },
                "text/less": {
                    compressible: true,
                    extensions: ["less"],
                },
                "text/markdown": {
                    source: "iana",
                    compressible: true,
                    extensions: ["markdown", "md"],
                },
                "text/mathml": {
                    source: "nginx",
                    extensions: ["mml"],
                },
                "text/mdx": {
                    compressible: true,
                    extensions: ["mdx"],
                },
                "text/mizar": {
                    source: "iana",
                },
                "text/n3": {
                    source: "iana",
                    charset: "UTF-8",
                    compressible: true,
                    extensions: ["n3"],
                },
                "text/parameters": {
                    source: "iana",
                    charset: "UTF-8",
                },
                "text/parityfec": {
                    source: "iana",
                },
                "text/plain": {
                    source: "iana",
                    compressible: true,
                    extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"],
                },
                "text/provenance-notation": {
                    source: "iana",
                    charset: "UTF-8",
                },
                "text/prs.fallenstein.rst": {
                    source: "iana",
                },
                "text/prs.lines.tag": {
                    source: "iana",
                    extensions: ["dsc"],
                },
                "text/prs.prop.logic": {
                    source: "iana",
                },
                "text/raptorfec": {
                    source: "iana",
                },
                "text/red": {
                    source: "iana",
                },
                "text/rfc822-headers": {
                    source: "iana",
                },
                "text/richtext": {
                    source: "iana",
                    compressible: true,
                    extensions: ["rtx"],
                },
                "text/rtf": {
                    source: "iana",
                    compressible: true,
                    extensions: ["rtf"],
                },
                "text/rtp-enc-aescm128": {
                    source: "iana",
                },
                "text/rtploopback": {
                    source: "iana",
                },
                "text/rtx": {
                    source: "iana",
                },
                "text/sgml": {
                    source: "iana",
                    extensions: ["sgml", "sgm"],
                },
                "text/shex": {
                    extensions: ["shex"],
                },
                "text/slim": {
                    extensions: ["slim", "slm"],
                },
                "text/strings": {
                    source: "iana",
                },
                "text/stylus": {
                    extensions: ["stylus", "styl"],
                },
                "text/t140": {
                    source: "iana",
                },
                "text/tab-separated-values": {
                    source: "iana",
                    compressible: true,
                    extensions: ["tsv"],
                },
                "text/troff": {
                    source: "iana",
                    extensions: ["t", "tr", "roff", "man", "me", "ms"],
                },
                "text/turtle": {
                    source: "iana",
                    charset: "UTF-8",
                    extensions: ["ttl"],
                },
                "text/ulpfec": {
                    source: "iana",
                },
                "text/uri-list": {
                    source: "iana",
                    compressible: true,
                    extensions: ["uri", "uris", "urls"],
                },
                "text/vcard": {
                    source: "iana",
                    compressible: true,
                    extensions: ["vcard"],
                },
                "text/vnd.a": {
                    source: "iana",
                },
                "text/vnd.abc": {
                    source: "iana",
                },
                "text/vnd.ascii-art": {
                    source: "iana",
                },
                "text/vnd.curl": {
                    source: "iana",
                    extensions: ["curl"],
                },
                "text/vnd.curl.dcurl": {
                    source: "apache",
                    extensions: ["dcurl"],
                },
                "text/vnd.curl.mcurl": {
                    source: "apache",
                    extensions: ["mcurl"],
                },
                "text/vnd.curl.scurl": {
                    source: "apache",
                    extensions: ["scurl"],
                },
                "text/vnd.debian.copyright": {
                    source: "iana",
                    charset: "UTF-8",
                },
                "text/vnd.dmclientscript": {
                    source: "iana",
                },
                "text/vnd.dvb.subtitle": {
                    source: "iana",
                    extensions: ["sub"],
                },
                "text/vnd.esmertec.theme-descriptor": {
                    source: "iana",
                    charset: "UTF-8",
                },
                "text/vnd.ficlab.flt": {
                    source: "iana",
                },
                "text/vnd.fly": {
                    source: "iana",
                    extensions: ["fly"],
                },
                "text/vnd.fmi.flexstor": {
                    source: "iana",
                    extensions: ["flx"],
                },
                "text/vnd.gml": {
                    source: "iana",
                },
                "text/vnd.graphviz": {
                    source: "iana",
                    extensions: ["gv"],
                },
                "text/vnd.hgl": {
                    source: "iana",
                },
                "text/vnd.in3d.3dml": {
                    source: "iana",
                    extensions: ["3dml"],
                },
                "text/vnd.in3d.spot": {
                    source: "iana",
                    extensions: ["spot"],
                },
                "text/vnd.iptc.newsml": {
                    source: "iana",
                },
                "text/vnd.iptc.nitf": {
                    source: "iana",
                },
                "text/vnd.latex-z": {
                    source: "iana",
                },
                "text/vnd.motorola.reflex": {
                    source: "iana",
                },
                "text/vnd.ms-mediapackage": {
                    source: "iana",
                },
                "text/vnd.net2phone.commcenter.command": {
                    source: "iana",
                },
                "text/vnd.radisys.msml-basic-layout": {
                    source: "iana",
                },
                "text/vnd.senx.warpscript": {
                    source: "iana",
                },
                "text/vnd.si.uricatalogue": {
                    source: "iana",
                },
                "text/vnd.sosi": {
                    source: "iana",
                },
                "text/vnd.sun.j2me.app-descriptor": {
                    source: "iana",
                    charset: "UTF-8",
                    extensions: ["jad"],
                },
                "text/vnd.trolltech.linguist": {
                    source: "iana",
                    charset: "UTF-8",
                },
                "text/vnd.wap.si": {
                    source: "iana",
                },
                "text/vnd.wap.sl": {
                    source: "iana",
                },
                "text/vnd.wap.wml": {
                    source: "iana",
                    extensions: ["wml"],
                },
                "text/vnd.wap.wmlscript": {
                    source: "iana",
                    extensions: ["wmls"],
                },
                "text/vtt": {
                    source: "iana",
                    charset: "UTF-8",
                    compressible: true,
                    extensions: ["vtt"],
                },
                "text/x-asm": {
                    source: "apache",
                    extensions: ["s", "asm"],
                },
                "text/x-c": {
                    source: "apache",
                    extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"],
                },
                "text/x-component": {
                    source: "nginx",
                    extensions: ["htc"],
                },
                "text/x-fortran": {
                    source: "apache",
                    extensions: ["f", "for", "f77", "f90"],
                },
                "text/x-gwt-rpc": {
                    compressible: true,
                },
                "text/x-handlebars-template": {
                    extensions: ["hbs"],
                },
                "text/x-java-source": {
                    source: "apache",
                    extensions: ["java"],
                },
                "text/x-jquery-tmpl": {
                    compressible: true,
                },
                "text/x-lua": {
                    extensions: ["lua"],
                },
                "text/x-markdown": {
                    compressible: true,
                    extensions: ["mkd"],
                },
                "text/x-nfo": {
                    source: "apache",
                    extensions: ["nfo"],
                },
                "text/x-opml": {
                    source: "apache",
                    extensions: ["opml"],
                },
                "text/x-org": {
                    compressible: true,
                    extensions: ["org"],
                },
                "text/x-pascal": {
                    source: "apache",
                    extensions: ["p", "pas"],
                },
                "text/x-processing": {
                    compressible: true,
                    extensions: ["pde"],
                },
                "text/x-sass": {
                    extensions: ["sass"],
                },
                "text/x-scss": {
                    extensions: ["scss"],
                },
                "text/x-setext": {
                    source: "apache",
                    extensions: ["etx"],
                },
                "text/x-sfv": {
                    source: "apache",
                    extensions: ["sfv"],
                },
                "text/x-suse-ymp": {
                    compressible: true,
                    extensions: ["ymp"],
                },
                "text/x-uuencode": {
                    source: "apache",
                    extensions: ["uu"],
                },
                "text/x-vcalendar": {
                    source: "apache",
                    extensions: ["vcs"],
                },
                "text/x-vcard": {
                    source: "apache",
                    extensions: ["vcf"],
                },
                "text/xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["xml"],
                },
                "text/xml-external-parsed-entity": {
                    source: "iana",
                },
                "text/yaml": {
                    extensions: ["yaml", "yml"],
                },
                "video/1d-interleaved-parityfec": {
                    source: "iana",
                },
                "video/3gpp": {
                    source: "iana",
                    extensions: ["3gp", "3gpp"],
                },
                "video/3gpp-tt": {
                    source: "iana",
                },
                "video/3gpp2": {
                    source: "iana",
                    extensions: ["3g2"],
                },
                "video/bmpeg": {
                    source: "iana",
                },
                "video/bt656": {
                    source: "iana",
                },
                "video/celb": {
                    source: "iana",
                },
                "video/dv": {
                    source: "iana",
                },
                "video/encaprtp": {
                    source: "iana",
                },
                "video/flexfec": {
                    source: "iana",
                },
                "video/h261": {
                    source: "iana",
                    extensions: ["h261"],
                },
                "video/h263": {
                    source: "iana",
                    extensions: ["h263"],
                },
                "video/h263-1998": {
                    source: "iana",
                },
                "video/h263-2000": {
                    source: "iana",
                },
                "video/h264": {
                    source: "iana",
                    extensions: ["h264"],
                },
                "video/h264-rcdo": {
                    source: "iana",
                },
                "video/h264-svc": {
                    source: "iana",
                },
                "video/h265": {
                    source: "iana",
                },
                "video/iso.segment": {
                    source: "iana",
                },
                "video/jpeg": {
                    source: "iana",
                    extensions: ["jpgv"],
                },
                "video/jpeg2000": {
                    source: "iana",
                },
                "video/jpm": {
                    source: "apache",
                    extensions: ["jpm", "jpgm"],
                },
                "video/mj2": {
                    source: "iana",
                    extensions: ["mj2", "mjp2"],
                },
                "video/mp1s": {
                    source: "iana",
                },
                "video/mp2p": {
                    source: "iana",
                },
                "video/mp2t": {
                    source: "iana",
                    extensions: ["ts"],
                },
                "video/mp4": {
                    source: "iana",
                    compressible: false,
                    extensions: ["mp4", "mp4v", "mpg4"],
                },
                "video/mp4v-es": {
                    source: "iana",
                },
                "video/mpeg": {
                    source: "iana",
                    compressible: false,
                    extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"],
                },
                "video/mpeg4-generic": {
                    source: "iana",
                },
                "video/mpv": {
                    source: "iana",
                },
                "video/nv": {
                    source: "iana",
                },
                "video/ogg": {
                    source: "iana",
                    compressible: false,
                    extensions: ["ogv"],
                },
                "video/parityfec": {
                    source: "iana",
                },
                "video/pointer": {
                    source: "iana",
                },
                "video/quicktime": {
                    source: "iana",
                    compressible: false,
                    extensions: ["qt", "mov"],
                },
                "video/raptorfec": {
                    source: "iana",
                },
                "video/raw": {
                    source: "iana",
                },
                "video/rtp-enc-aescm128": {
                    source: "iana",
                },
                "video/rtploopback": {
                    source: "iana",
                },
                "video/rtx": {
                    source: "iana",
                },
                "video/smpte291": {
                    source: "iana",
                },
                "video/smpte292m": {
                    source: "iana",
                },
                "video/ulpfec": {
                    source: "iana",
                },
                "video/vc1": {
                    source: "iana",
                },
                "video/vc2": {
                    source: "iana",
                },
                "video/vnd.cctv": {
                    source: "iana",
                },
                "video/vnd.dece.hd": {
                    source: "iana",
                    extensions: ["uvh", "uvvh"],
                },
                "video/vnd.dece.mobile": {
                    source: "iana",
                    extensions: ["uvm", "uvvm"],
                },
                "video/vnd.dece.mp4": {
                    source: "iana",
                },
                "video/vnd.dece.pd": {
                    source: "iana",
                    extensions: ["uvp", "uvvp"],
                },
                "video/vnd.dece.sd": {
                    source: "iana",
                    extensions: ["uvs", "uvvs"],
                },
                "video/vnd.dece.video": {
                    source: "iana",
                    extensions: ["uvv", "uvvv"],
                },
                "video/vnd.directv.mpeg": {
                    source: "iana",
                },
                "video/vnd.directv.mpeg-tts": {
                    source: "iana",
                },
                "video/vnd.dlna.mpeg-tts": {
                    source: "iana",
                },
                "video/vnd.dvb.file": {
                    source: "iana",
                    extensions: ["dvb"],
                },
                "video/vnd.fvt": {
                    source: "iana",
                    extensions: ["fvt"],
                },
                "video/vnd.hns.video": {
                    source: "iana",
                },
                "video/vnd.iptvforum.1dparityfec-1010": {
                    source: "iana",
                },
                "video/vnd.iptvforum.1dparityfec-2005": {
                    source: "iana",
                },
                "video/vnd.iptvforum.2dparityfec-1010": {
                    source: "iana",
                },
                "video/vnd.iptvforum.2dparityfec-2005": {
                    source: "iana",
                },
                "video/vnd.iptvforum.ttsavc": {
                    source: "iana",
                },
                "video/vnd.iptvforum.ttsmpeg2": {
                    source: "iana",
                },
                "video/vnd.motorola.video": {
                    source: "iana",
                },
                "video/vnd.motorola.videop": {
                    source: "iana",
                },
                "video/vnd.mpegurl": {
                    source: "iana",
                    extensions: ["mxu", "m4u"],
                },
                "video/vnd.ms-playready.media.pyv": {
                    source: "iana",
                    extensions: ["pyv"],
                },
                "video/vnd.nokia.interleaved-multimedia": {
                    source: "iana",
                },
                "video/vnd.nokia.mp4vr": {
                    source: "iana",
                },
                "video/vnd.nokia.videovoip": {
                    source: "iana",
                },
                "video/vnd.objectvideo": {
                    source: "iana",
                },
                "video/vnd.radgamettools.bink": {
                    source: "iana",
                },
                "video/vnd.radgamettools.smacker": {
                    source: "iana",
                },
                "video/vnd.sealed.mpeg1": {
                    source: "iana",
                },
                "video/vnd.sealed.mpeg4": {
                    source: "iana",
                },
                "video/vnd.sealed.swf": {
                    source: "iana",
                },
                "video/vnd.sealedmedia.softseal.mov": {
                    source: "iana",
                },
                "video/vnd.uvvu.mp4": {
                    source: "iana",
                    extensions: ["uvu", "uvvu"],
                },
                "video/vnd.vivo": {
                    source: "iana",
                    extensions: ["viv"],
                },
                "video/vnd.youtube.yt": {
                    source: "iana",
                },
                "video/vp8": {
                    source: "iana",
                },
                "video/webm": {
                    source: "apache",
                    compressible: false,
                    extensions: ["webm"],
                },
                "video/x-f4v": {
                    source: "apache",
                    extensions: ["f4v"],
                },
                "video/x-fli": {
                    source: "apache",
                    extensions: ["fli"],
                },
                "video/x-flv": {
                    source: "apache",
                    compressible: false,
                    extensions: ["flv"],
                },
                "video/x-m4v": {
                    source: "apache",
                    extensions: ["m4v"],
                },
                "video/x-matroska": {
                    source: "apache",
                    compressible: false,
                    extensions: ["mkv", "mk3d", "mks"],
                },
                "video/x-mng": {
                    source: "apache",
                    extensions: ["mng"],
                },
                "video/x-ms-asf": {
                    source: "apache",
                    extensions: ["asf", "asx"],
                },
                "video/x-ms-vob": {
                    source: "apache",
                    extensions: ["vob"],
                },
                "video/x-ms-wm": {
                    source: "apache",
                    extensions: ["wm"],
                },
                "video/x-ms-wmv": {
                    source: "apache",
                    compressible: false,
                    extensions: ["wmv"],
                },
                "video/x-ms-wmx": {
                    source: "apache",
                    extensions: ["wmx"],
                },
                "video/x-ms-wvx": {
                    source: "apache",
                    extensions: ["wvx"],
                },
                "video/x-msvideo": {
                    source: "apache",
                    extensions: ["avi"],
                },
                "video/x-sgi-movie": {
                    source: "apache",
                    extensions: ["movie"],
                },
                "video/x-smv": {
                    source: "apache",
                    extensions: ["smv"],
                },
                "x-conference/x-cooltalk": {
                    source: "apache",
                    extensions: ["ice"],
                },
                "x-shader/x-fragment": {
                    compressible: true,
                },
                "x-shader/x-vertex": {
                    compressible: true,
                },
            });
        }
    };
});
// Copyright 2018-2020 the Deno authors. All rights reserved. MIT license.
System.register("https://deno.land/x/media_types@v2.3.6/deps", ["https://deno.land/std@0.57.0/path/mod"], function (exports_61, context_61) {
    "use strict";
    var __moduleName = context_61 && context_61.id;
    return {
        setters: [
            function (mod_ts_11_1) {
                exports_61({
                    "extname": mod_ts_11_1["extname"]
                });
            }
        ],
        execute: function () {
        }
    };
});
/*!
 * Ported from: https://github.com/jshttp/mime-types and licensed as:
 *
 * (The MIT License)
 *
 * Copyright (c) 2014 Jonathan Ong <me@jongleberry.com>
 * Copyright (c) 2015 Douglas Christopher Wilson <doug@somethingdoug.com>
 * Copyright (c) 2020 the Deno authors
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * 'Software'), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
System.register("https://deno.land/x/media_types@v2.3.6/mod", ["https://deno.land/x/media_types@v2.3.6/db", "https://deno.land/x/media_types@v2.3.6/deps"], function (exports_62, context_62) {
    "use strict";
    var db_ts_1, deps_ts_1, EXTRACT_TYPE_REGEXP, TEXT_TYPE_REGEXP, extensions, types;
    var __moduleName = context_62 && context_62.id;
    /** Internal function to populate the maps based on the Mime DB */
    function populateMaps(extensions, types) {
        const preference = ["nginx", "apache", undefined, "iana"];
        for (const type of Object.keys(db_ts_1.db)) {
            const mime = db_ts_1.db[type];
            const exts = mime.extensions;
            if (!exts || !exts.length) {
                continue;
            }
            extensions.set(type, exts);
            for (const ext of exts) {
                const current = types.get(ext);
                if (current) {
                    const from = preference.indexOf(db_ts_1.db[current].source);
                    const to = preference.indexOf(mime.source);
                    if (current !== "application/octet-stream" &&
                        (from > to ||
                            (from === to && current.substr(0, 12) === "application/"))) {
                        continue;
                    }
                }
                types.set(ext, type);
            }
        }
    }
    /** Given a media type return any default charset string.  Returns `undefined`
     * if not resolvable.
     */
    function charset(type) {
        const m = EXTRACT_TYPE_REGEXP.exec(type);
        if (!m) {
            return;
        }
        const [match] = m;
        const mime = db_ts_1.db[match.toLowerCase()];
        if (mime && mime.charset) {
            return mime.charset;
        }
        if (TEXT_TYPE_REGEXP.test(match)) {
            return "UTF-8";
        }
    }
    exports_62("charset", charset);
    /** Given an extension, lookup the appropriate media type for that extension.
     * Likely you should be using `contentType()` though instead.
     */
    function lookup(path) {
        const extension = deps_ts_1.extname("x." + path)
            .toLowerCase()
            .substr(1);
        return types.get(extension);
    }
    exports_62("lookup", lookup);
    /** Given an extension or media type, return the full `Content-Type` header
     * string.  Returns `undefined` if not resolvable.
     */
    function contentType(str) {
        let mime = str.includes("/") ? str : lookup(str);
        if (!mime) {
            return;
        }
        if (!mime.includes("charset")) {
            const cs = charset(mime);
            if (cs) {
                mime += `; charset=${cs.toLowerCase()}`;
            }
        }
        return mime;
    }
    exports_62("contentType", contentType);
    /** Given a media type, return the most appropriate extension or return
     * `undefined` if there is none.
     */
    function extension(type) {
        const match = EXTRACT_TYPE_REGEXP.exec(type);
        if (!match) {
            return;
        }
        const exts = extensions.get(match[1].toLowerCase());
        if (!exts || !exts.length) {
            return;
        }
        return exts[0];
    }
    exports_62("extension", extension);
    return {
        setters: [
            function (db_ts_1_1) {
                db_ts_1 = db_ts_1_1;
            },
            function (deps_ts_1_1) {
                deps_ts_1 = deps_ts_1_1;
            }
        ],
        execute: function () {
            EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
            TEXT_TYPE_REGEXP = /^text\//i;
            /** A map of extensions for a given media type */
            exports_62("extensions", extensions = new Map());
            /** A map of the media type for a given extension */
            exports_62("types", types = new Map());
            // Populate the maps upon module load
            populateMaps(extensions, types);
        }
    };
});
System.register("https://raw.githubusercontent.com/pillarjs/path-to-regexp/v6.1.0/src/index", [], function (exports_63, context_63) {
    "use strict";
    var __moduleName = context_63 && context_63.id;
    /**
     * Tokenize input string.
     */
    function lexer(str) {
        const tokens = [];
        let i = 0;
        while (i < str.length) {
            const char = str[i];
            if (char === "*" || char === "+" || char === "?") {
                tokens.push({ type: "MODIFIER", index: i, value: str[i++] });
                continue;
            }
            if (char === "\\") {
                tokens.push({ type: "ESCAPED_CHAR", index: i++, value: str[i++] });
                continue;
            }
            if (char === "{") {
                tokens.push({ type: "OPEN", index: i, value: str[i++] });
                continue;
            }
            if (char === "}") {
                tokens.push({ type: "CLOSE", index: i, value: str[i++] });
                continue;
            }
            if (char === ":") {
                let name = "";
                let j = i + 1;
                while (j < str.length) {
                    const code = str.charCodeAt(j);
                    if (
                    // `0-9`
                    (code >= 48 && code <= 57) ||
                        // `A-Z`
                        (code >= 65 && code <= 90) ||
                        // `a-z`
                        (code >= 97 && code <= 122) ||
                        // `_`
                        code === 95) {
                        name += str[j++];
                        continue;
                    }
                    break;
                }
                if (!name)
                    throw new TypeError(`Missing parameter name at ${i}`);
                tokens.push({ type: "NAME", index: i, value: name });
                i = j;
                continue;
            }
            if (char === "(") {
                let count = 1;
                let pattern = "";
                let j = i + 1;
                if (str[j] === "?") {
                    throw new TypeError(`Pattern cannot start with "?" at ${j}`);
                }
                while (j < str.length) {
                    if (str[j] === "\\") {
                        pattern += str[j++] + str[j++];
                        continue;
                    }
                    if (str[j] === ")") {
                        count--;
                        if (count === 0) {
                            j++;
                            break;
                        }
                    }
                    else if (str[j] === "(") {
                        count++;
                        if (str[j + 1] !== "?") {
                            throw new TypeError(`Capturing groups are not allowed at ${j}`);
                        }
                    }
                    pattern += str[j++];
                }
                if (count)
                    throw new TypeError(`Unbalanced pattern at ${i}`);
                if (!pattern)
                    throw new TypeError(`Missing pattern at ${i}`);
                tokens.push({ type: "PATTERN", index: i, value: pattern });
                i = j;
                continue;
            }
            tokens.push({ type: "CHAR", index: i, value: str[i++] });
        }
        tokens.push({ type: "END", index: i, value: "" });
        return tokens;
    }
    /**
     * Parse a string for the raw tokens.
     */
    function parse(str, options = {}) {
        const tokens = lexer(str);
        const { prefixes = "./" } = options;
        const defaultPattern = `[^${escapeString(options.delimiter || "/#?")}]+?`;
        const result = [];
        let key = 0;
        let i = 0;
        let path = "";
        const tryConsume = (type) => {
            if (i < tokens.length && tokens[i].type === type)
                return tokens[i++].value;
        };
        const mustConsume = (type) => {
            const value = tryConsume(type);
            if (value !== undefined)
                return value;
            const { type: nextType, index } = tokens[i];
            throw new TypeError(`Unexpected ${nextType} at ${index}, expected ${type}`);
        };
        const consumeText = () => {
            let result = "";
            let value;
            // tslint:disable-next-line
            while ((value = tryConsume("CHAR") || tryConsume("ESCAPED_CHAR"))) {
                result += value;
            }
            return result;
        };
        while (i < tokens.length) {
            const char = tryConsume("CHAR");
            const name = tryConsume("NAME");
            const pattern = tryConsume("PATTERN");
            if (name || pattern) {
                let prefix = char || "";
                if (prefixes.indexOf(prefix) === -1) {
                    path += prefix;
                    prefix = "";
                }
                if (path) {
                    result.push(path);
                    path = "";
                }
                result.push({
                    name: name || key++,
                    prefix,
                    suffix: "",
                    pattern: pattern || defaultPattern,
                    modifier: tryConsume("MODIFIER") || ""
                });
                continue;
            }
            const value = char || tryConsume("ESCAPED_CHAR");
            if (value) {
                path += value;
                continue;
            }
            if (path) {
                result.push(path);
                path = "";
            }
            const open = tryConsume("OPEN");
            if (open) {
                const prefix = consumeText();
                const name = tryConsume("NAME") || "";
                const pattern = tryConsume("PATTERN") || "";
                const suffix = consumeText();
                mustConsume("CLOSE");
                result.push({
                    name: name || (pattern ? key++ : ""),
                    pattern: name && !pattern ? defaultPattern : pattern,
                    prefix,
                    suffix,
                    modifier: tryConsume("MODIFIER") || ""
                });
                continue;
            }
            mustConsume("END");
        }
        return result;
    }
    exports_63("parse", parse);
    /**
     * Compile a string to a template function for the path.
     */
    function compile(str, options) {
        return tokensToFunction(parse(str, options), options);
    }
    exports_63("compile", compile);
    /**
     * Expose a method for transforming tokens into the path function.
     */
    function tokensToFunction(tokens, options = {}) {
        const reFlags = flags(options);
        const { encode = (x) => x, validate = true } = options;
        // Compile all the tokens into regexps.
        const matches = tokens.map(token => {
            if (typeof token === "object") {
                return new RegExp(`^(?:${token.pattern})$`, reFlags);
            }
        });
        return (data) => {
            let path = "";
            for (let i = 0; i < tokens.length; i++) {
                const token = tokens[i];
                if (typeof token === "string") {
                    path += token;
                    continue;
                }
                const value = data ? data[token.name] : undefined;
                const optional = token.modifier === "?" || token.modifier === "*";
                const repeat = token.modifier === "*" || token.modifier === "+";
                if (Array.isArray(value)) {
                    if (!repeat) {
                        throw new TypeError(`Expected "${token.name}" to not repeat, but got an array`);
                    }
                    if (value.length === 0) {
                        if (optional)
                            continue;
                        throw new TypeError(`Expected "${token.name}" to not be empty`);
                    }
                    for (let j = 0; j < value.length; j++) {
                        const segment = encode(value[j], token);
                        if (validate && !matches[i].test(segment)) {
                            throw new TypeError(`Expected all "${token.name}" to match "${token.pattern}", but got "${segment}"`);
                        }
                        path += token.prefix + segment + token.suffix;
                    }
                    continue;
                }
                if (typeof value === "string" || typeof value === "number") {
                    const segment = encode(String(value), token);
                    if (validate && !matches[i].test(segment)) {
                        throw new TypeError(`Expected "${token.name}" to match "${token.pattern}", but got "${segment}"`);
                    }
                    path += token.prefix + segment + token.suffix;
                    continue;
                }
                if (optional)
                    continue;
                const typeOfMessage = repeat ? "an array" : "a string";
                throw new TypeError(`Expected "${token.name}" to be ${typeOfMessage}`);
            }
            return path;
        };
    }
    exports_63("tokensToFunction", tokensToFunction);
    /**
     * Create path match function from `path-to-regexp` spec.
     */
    function match(str, options) {
        const keys = [];
        const re = pathToRegexp(str, keys, options);
        return regexpToFunction(re, keys, options);
    }
    exports_63("match", match);
    /**
     * Create a path match function from `path-to-regexp` output.
     */
    function regexpToFunction(re, keys, options = {}) {
        const { decode = (x) => x } = options;
        return function (pathname) {
            const m = re.exec(pathname);
            if (!m)
                return false;
            const { 0: path, index } = m;
            const params = Object.create(null);
            for (let i = 1; i < m.length; i++) {
                // tslint:disable-next-line
                if (m[i] === undefined)
                    continue;
                const key = keys[i - 1];
                if (key.modifier === "*" || key.modifier === "+") {
                    params[key.name] = m[i].split(key.prefix + key.suffix).map(value => {
                        return decode(value, key);
                    });
                }
                else {
                    params[key.name] = decode(m[i], key);
                }
            }
            return { path, index, params };
        };
    }
    exports_63("regexpToFunction", regexpToFunction);
    /**
     * Escape a regular expression string.
     */
    function escapeString(str) {
        return str.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
    }
    /**
     * Get the flags for a regexp from the options.
     */
    function flags(options) {
        return options && options.sensitive ? "" : "i";
    }
    /**
     * Pull out keys from a regexp.
     */
    function regexpToRegexp(path, keys) {
        if (!keys)
            return path;
        // Use a negative lookahead to match only capturing groups.
        const groups = path.source.match(/\((?!\?)/g);
        if (groups) {
            for (let i = 0; i < groups.length; i++) {
                keys.push({
                    name: i,
                    prefix: "",
                    suffix: "",
                    modifier: "",
                    pattern: ""
                });
            }
        }
        return path;
    }
    /**
     * Transform an array into a regexp.
     */
    function arrayToRegexp(paths, keys, options) {
        const parts = paths.map(path => pathToRegexp(path, keys, options).source);
        return new RegExp(`(?:${parts.join("|")})`, flags(options));
    }
    /**
     * Create a path regexp from string input.
     */
    function stringToRegexp(path, keys, options) {
        return tokensToRegexp(parse(path, options), keys, options);
    }
    /**
     * Expose a function for taking tokens and returning a RegExp.
     */
    function tokensToRegexp(tokens, keys, options = {}) {
        const { strict = false, start = true, end = true, encode = (x) => x } = options;
        const endsWith = `[${escapeString(options.endsWith || "")}]|$`;
        const delimiter = `[${escapeString(options.delimiter || "/#?")}]`;
        let route = start ? "^" : "";
        // Iterate over the tokens and create our regexp string.
        for (const token of tokens) {
            if (typeof token === "string") {
                route += escapeString(encode(token));
            }
            else {
                const prefix = escapeString(encode(token.prefix));
                const suffix = escapeString(encode(token.suffix));
                if (token.pattern) {
                    if (keys)
                        keys.push(token);
                    if (prefix || suffix) {
                        if (token.modifier === "+" || token.modifier === "*") {
                            const mod = token.modifier === "*" ? "?" : "";
                            route += `(?:${prefix}((?:${token.pattern})(?:${suffix}${prefix}(?:${token.pattern}))*)${suffix})${mod}`;
                        }
                        else {
                            route += `(?:${prefix}(${token.pattern})${suffix})${token.modifier}`;
                        }
                    }
                    else {
                        route += `(${token.pattern})${token.modifier}`;
                    }
                }
                else {
                    route += `(?:${prefix}${suffix})${token.modifier}`;
                }
            }
        }
        if (end) {
            if (!strict)
                route += `${delimiter}?`;
            route += !options.endsWith ? "$" : `(?=${endsWith})`;
        }
        else {
            const endToken = tokens[tokens.length - 1];
            const isEndDelimited = typeof endToken === "string"
                ? delimiter.indexOf(endToken[endToken.length - 1]) > -1
                : // tslint:disable-next-line
                    endToken === undefined;
            if (!strict) {
                route += `(?:${delimiter}(?=${endsWith}))?`;
            }
            if (!isEndDelimited) {
                route += `(?=${delimiter}|${endsWith})`;
            }
        }
        return new RegExp(route, flags(options));
    }
    exports_63("tokensToRegexp", tokensToRegexp);
    /**
     * Normalize the given path string, returning a regular expression.
     *
     * An empty array can be passed in for the keys, which will hold the
     * placeholder key descriptions. For example, using `/user/:id`, `keys` will
     * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
     */
    function pathToRegexp(path, keys, options) {
        if (path instanceof RegExp)
            return regexpToRegexp(path, keys);
        if (Array.isArray(path))
            return arrayToRegexp(path, keys, options);
        return stringToRegexp(path, keys, options);
    }
    exports_63("pathToRegexp", pathToRegexp);
    return {
        setters: [],
        execute: function () {
        }
    };
});
// Copyright 2018-2020 the oak authors. All rights reserved. MIT license.
System.register("https://deno.land/x/oak/deps", ["https://deno.land/std@0.57.0/bytes/mod", "https://deno.land/std@0.57.0/hash/sha1", "https://deno.land/std@0.57.0/hash/sha256", "https://deno.land/std@0.57.0/http/server", "https://deno.land/std@0.57.0/http/http_status", "https://deno.land/std@0.57.0/io/bufio", "https://deno.land/std@0.57.0/io/util", "https://deno.land/std@0.57.0/path/mod", "https://deno.land/std@0.57.0/testing/asserts", "https://deno.land/std@0.57.0/ws/mod", "https://deno.land/x/media_types@v2.3.6/mod", "https://raw.githubusercontent.com/pillarjs/path-to-regexp/v6.1.0/src/index"], function (exports_64, context_64) {
    "use strict";
    var __moduleName = context_64 && context_64.id;
    return {
        setters: [
            function (mod_ts_12_1) {
                exports_64({
                    "equal": mod_ts_12_1["equal"]
                });
            },
            function (sha1_ts_2_1) {
                exports_64({
                    "Sha1": sha1_ts_2_1["Sha1"]
                });
            },
            function (sha256_ts_1_1) {
                exports_64({
                    "HmacSha256": sha256_ts_1_1["HmacSha256"]
                });
            },
            function (server_ts_2_1) {
                exports_64({
                    "serve": server_ts_2_1["serve"],
                    "Server": server_ts_2_1["Server"],
                    "ServerRequest": server_ts_2_1["ServerRequest"],
                    "serveTLS": server_ts_2_1["serveTLS"]
                });
            },
            function (http_status_ts_2_1) {
                exports_64({
                    "Status": http_status_ts_2_1["Status"],
                    "STATUS_TEXT": http_status_ts_2_1["STATUS_TEXT"]
                });
            },
            function (bufio_ts_4_1) {
                exports_64({
                    "BufWriter": bufio_ts_4_1["BufWriter"]
                });
            },
            function (util_ts_4_1) {
                exports_64({
                    "copyBytes": util_ts_4_1["copyBytes"]
                });
            },
            function (mod_ts_13_1) {
                exports_64({
                    "basename": mod_ts_13_1["basename"],
                    "extname": mod_ts_13_1["extname"],
                    "join": mod_ts_13_1["join"],
                    "isAbsolute": mod_ts_13_1["isAbsolute"],
                    "normalize": mod_ts_13_1["normalize"],
                    "parse": mod_ts_13_1["parse"],
                    "resolve": mod_ts_13_1["resolve"],
                    "sep": mod_ts_13_1["sep"]
                });
            },
            function (asserts_ts_1_1) {
                exports_64({
                    "assert": asserts_ts_1_1["assert"]
                });
            },
            function (mod_ts_14_1) {
                exports_64({
                    "acceptable": mod_ts_14_1["acceptable"],
                    "acceptWebSocket": mod_ts_14_1["acceptWebSocket"]
                });
            },
            function (mod_ts_15_1) {
                exports_64({
                    "contentType": mod_ts_15_1["contentType"],
                    "extension": mod_ts_15_1["extension"],
                    "lookup": mod_ts_15_1["lookup"]
                });
            },
            function (index_ts_1_1) {
                exports_64({
                    "compile": index_ts_1_1["compile"],
                    "pathParse": index_ts_1_1["parse"],
                    "pathToRegexp": index_ts_1_1["pathToRegexp"]
                });
            }
        ],
        execute: function () {
        }
    };
});
// Copyright 2018-2020 the oak authors. All rights reserved. MIT license.
System.register("https://deno.land/x/oak/tssCompare", ["https://deno.land/x/oak/deps"], function (exports_65, context_65) {
    "use strict";
    var deps_ts_2;
    var __moduleName = context_65 && context_65.id;
    function compareArrayBuffer(a, b) {
        deps_ts_2.assert(a.byteLength === b.byteLength, "ArrayBuffer lengths must match.");
        const va = new DataView(a);
        const vb = new DataView(b);
        const length = va.byteLength;
        let out = 0;
        let i = -1;
        while (++i < length) {
            out |= va.getUint8(i) ^ vb.getUint8(i);
        }
        return out === 0;
    }
    /** Compare two strings, Uint8Arrays, ArrayBuffers, or arrays of numbers in a
     * way that avoids timing based attacks on the comparisons on the values.
     *
     * The function will return `true` if the values match, or `false`, if they
     * do not match. */
    function compare(a, b) {
        const key = new Uint8Array(32);
        globalThis.crypto.getRandomValues(key);
        const ah = (new deps_ts_2.HmacSha256(key)).update(a).arrayBuffer();
        const bh = (new deps_ts_2.HmacSha256(key)).update(b).arrayBuffer();
        return compareArrayBuffer(ah, bh);
    }
    exports_65("compare", compare);
    return {
        setters: [
            function (deps_ts_2_1) {
                deps_ts_2 = deps_ts_2_1;
            }
        ],
        execute: function () {
        }
    };
});
// Copyright 2018-2020 the oak authors. All rights reserved. MIT license.
System.register("https://deno.land/x/oak/keyStack", ["https://deno.land/x/oak/deps", "https://deno.land/x/oak/tssCompare"], function (exports_66, context_66) {
    "use strict";
    var deps_ts_3, tssCompare_ts_1, replacements, KeyStack;
    var __moduleName = context_66 && context_66.id;
    return {
        setters: [
            function (deps_ts_3_1) {
                deps_ts_3 = deps_ts_3_1;
            },
            function (tssCompare_ts_1_1) {
                tssCompare_ts_1 = tssCompare_ts_1_1;
            }
        ],
        execute: function () {
            replacements = {
                "/": "_",
                "+": "-",
                "=": "",
            };
            KeyStack = class KeyStack {
                /** A class which accepts an array of keys that are used to sign and verify
                 * data and allows easy key rotation without invalidation of previously signed
                 * data.
                 *
                 * @param keys An array of keys, of which the index 0 will be used to sign
                 *             data, but verification can happen against any key.
                 */
                constructor(keys) {
                    this.#sign = (data, key) => {
                        return btoa(String.fromCharCode.apply(undefined, new Uint8Array(new deps_ts_3.HmacSha256(key).update(data).arrayBuffer())))
                            .replace(/\/|\+|=/g, (c) => replacements[c]);
                    };
                    if (!(0 in keys)) {
                        throw new TypeError("keys must contain at least one value");
                    }
                    this.#keys = keys;
                }
                #keys;
                #sign;
                /** Take `data` and return a SHA256 HMAC digest that uses the current 0 index
                 * of the `keys` passed to the constructor.  This digest is in the form of a
                 * URL safe base64 encoded string. */
                sign(data) {
                    return this.#sign(data, this.#keys[0]);
                }
                /** Given `data` and a `digest`, verify that one of the `keys` provided the
                 * constructor was used to generate the `digest`.  Returns `true` if one of
                 * the keys was used, otherwise `false`. */
                verify(data, digest) {
                    return this.indexOf(data, digest) > -1;
                }
                /** Given `data` and a `digest`, return the current index of the key in the
                 * `keys` passed the constructor that was used to generate the digest.  If no
                 * key can be found, the method returns `-1`. */
                indexOf(data, digest) {
                    for (let i = 0; i < this.#keys.length; i++) {
                        if (tssCompare_ts_1.compare(digest, this.#sign(data, this.#keys[i]))) {
                            return i;
                        }
                    }
                    return -1;
                }
            };
            exports_66("KeyStack", KeyStack);
        }
    };
});
/*!
 * Adapted directly from http-errors at https://github.com/jshttp/http-errors
 * which is licensed as follows:
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2014 Jonathan Ong me@jongleberry.com
 * Copyright (c) 2016 Douglas Christopher Wilson doug@somethingdoug.com
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
System.register("https://deno.land/x/oak/httpError", ["https://deno.land/x/oak/deps"], function (exports_67, context_67) {
    "use strict";
    var deps_ts_4, errorStatusMap, HttpError, httpErrors;
    var __moduleName = context_67 && context_67.id;
    function createHttpErrorConstructor(status) {
        const name = `${deps_ts_4.Status[status]}Error`;
        const Ctor = class extends HttpError {
            constructor(message) {
                super();
                this.message = message || deps_ts_4.STATUS_TEXT.get(status);
                this.status = status;
                this.expose = status >= 400 && status < 500 ? true : false;
                Object.defineProperty(this, "name", {
                    configurable: true,
                    enumerable: false,
                    value: name,
                    writable: true,
                });
            }
        };
        return Ctor;
    }
    /** Create a specific class of `HttpError` based on the status, which defaults
     * to _500 Internal Server Error_.
     */
    function createHttpError(status = 500, message) {
        return new httpErrors[deps_ts_4.Status[status]](message);
    }
    exports_67("createHttpError", createHttpError);
    function isHttpError(value) {
        return value instanceof HttpError;
    }
    exports_67("isHttpError", isHttpError);
    return {
        setters: [
            function (deps_ts_4_1) {
                deps_ts_4 = deps_ts_4_1;
            }
        ],
        execute: function () {
            errorStatusMap = {
                "BadRequest": 400,
                "Unauthorized": 401,
                "PaymentRequired": 402,
                "Forbidden": 403,
                "NotFound": 404,
                "MethodNotAllowed": 405,
                "NotAcceptable": 406,
                "ProxyAuthRequired": 407,
                "RequestTimeout": 408,
                "Conflict": 409,
                "Gone": 410,
                "LengthRequired": 411,
                "PreconditionFailed": 412,
                "RequestEntityTooLarge": 413,
                "RequestURITooLong": 414,
                "UnsupportedMediaType": 415,
                "RequestedRangeNotSatisfiable": 416,
                "ExpectationFailed": 417,
                "Teapot": 418,
                "MisdirectedRequest": 421,
                "UnprocessableEntity": 422,
                "Locked": 423,
                "FailedDependency": 424,
                "UpgradeRequired": 426,
                "PreconditionRequired": 428,
                "TooManyRequests": 429,
                "RequestHeaderFieldsTooLarge": 431,
                "UnavailableForLegalReasons": 451,
                "InternalServerError": 500,
                "NotImplemented": 501,
                "BadGateway": 502,
                "ServiceUnavailable": 503,
                "GatewayTimeout": 504,
                "HTTPVersionNotSupported": 505,
                "VariantAlsoNegotiates": 506,
                "InsufficientStorage": 507,
                "LoopDetected": 508,
                "NotExtended": 510,
                "NetworkAuthenticationRequired": 511,
            };
            /** A base class for individual classes of HTTP errors. */
            HttpError = class HttpError extends Error {
                constructor() {
                    super(...arguments);
                    /** Determines if details about the error should be automatically exposed
                     * in a response.  This is automatically set to `true` for 4XX errors, as
                     * they represent errors in the request, while 5XX errors are set to `false`
                     * as they are internal server errors and exposing details could leak
                     * important server security information. */
                    this.expose = false;
                    /** The HTTP error status associated with this class of error. */
                    this.status = deps_ts_4.Status.InternalServerError;
                }
            };
            exports_67("HttpError", HttpError);
            /** An object which contains an individual HTTP Error for each HTTP status
             * error code (4XX and 5XX).  When errors are raised related to a particular
             * HTTP status code, they will be of the appropriate instance located on this
             * object.  Also, context's `.throw()` will throw errors based on the passed
             * status code. */
            exports_67("httpErrors", httpErrors = {});
            for (const [key, value] of Object.entries(errorStatusMap)) {
                httpErrors[key] = createHttpErrorConstructor(value);
            }
        }
    };
});
/*!
 * Adapted directly from media-typer at https://github.com/jshttp/media-typer/
 * which is licensed as follows:
 *
 * media-typer
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
System.register("https://deno.land/x/oak/mediaTyper", [], function (exports_68, context_68) {
    "use strict";
    var SUBTYPE_NAME_REGEXP, TYPE_NAME_REGEXP, TYPE_REGEXP, MediaType;
    var __moduleName = context_68 && context_68.id;
    /** Given a media type object, return a media type string.
     *
     *       format({
     *         type: "text",
     *         subtype: "html"
     *       }); // returns "text/html"
     */
    function format(obj) {
        const { subtype, suffix, type } = obj;
        if (!TYPE_NAME_REGEXP.test(type)) {
            throw new TypeError("Invalid type.");
        }
        if (!SUBTYPE_NAME_REGEXP.test(subtype)) {
            throw new TypeError("Invalid subtype.");
        }
        let str = `${type}/${subtype}`;
        if (suffix) {
            if (!TYPE_NAME_REGEXP.test(suffix)) {
                throw new TypeError("Invalid suffix.");
            }
            str += `+${suffix}`;
        }
        return str;
    }
    exports_68("format", format);
    /** Given a media type string, return a media type object.
     *
     *       parse("application/json-patch+json");
     *       // returns {
     *       //   type: "application",
     *       //   subtype: "json-patch",
     *       //   suffix: "json"
     *       // }
     */
    function parse(str) {
        const match = TYPE_REGEXP.exec(str.toLowerCase());
        if (!match) {
            throw new TypeError("Invalid media type.");
        }
        let [, type, subtype] = match;
        let suffix;
        const idx = subtype.lastIndexOf("+");
        if (idx !== -1) {
            suffix = subtype.substr(idx + 1);
            subtype = subtype.substr(0, idx);
        }
        return new MediaType(type, subtype, suffix);
    }
    exports_68("parse", parse);
    return {
        setters: [],
        execute: function () {
            SUBTYPE_NAME_REGEXP = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/;
            TYPE_NAME_REGEXP = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/;
            TYPE_REGEXP = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;
            MediaType = class MediaType {
                constructor(
                /** The type of the media type. */
                type, 
                /** The subtype of the media type. */
                subtype, 
                /** The optional suffix of the media type. */
                suffix) {
                    this.type = type;
                    this.subtype = subtype;
                    this.suffix = suffix;
                }
            };
        }
    };
});
/*!
 * Adapted directly from type-is at https://github.com/jshttp/type-is/
 * which is licensed as follows:
 *
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
System.register("https://deno.land/x/oak/isMediaType", ["https://deno.land/x/oak/deps", "https://deno.land/x/oak/mediaTyper"], function (exports_69, context_69) {
    "use strict";
    var deps_ts_5, mediaTyper_ts_1;
    var __moduleName = context_69 && context_69.id;
    function mimeMatch(expected, actual) {
        if (expected === undefined) {
            return false;
        }
        const actualParts = actual.split("/");
        const expectedParts = expected.split("/");
        if (actualParts.length !== 2 || expectedParts.length !== 2) {
            return false;
        }
        const [actualType, actualSubtype] = actualParts;
        const [expectedType, expectedSubtype] = expectedParts;
        if (expectedType !== "*" && expectedType !== actualType) {
            return false;
        }
        if (expectedSubtype.substr(0, 2) === "*+") {
            return (expectedSubtype.length <= actualSubtype.length + 1 &&
                expectedSubtype.substr(1) ===
                    actualSubtype.substr(1 - expectedSubtype.length));
        }
        if (expectedSubtype !== "*" && expectedSubtype !== actualSubtype) {
            return false;
        }
        return true;
    }
    function normalize(type) {
        switch (type) {
            case "urlencoded":
                return "application/x-www-form-urlencoded";
            case "multipart":
                return "multipart/*";
        }
        if (type[0] === "+") {
            return `*/*${type}`;
        }
        return type.includes("/") ? type : deps_ts_5.lookup(type);
    }
    function normalizeType(value) {
        try {
            const val = value.split(";");
            const type = mediaTyper_ts_1.parse(val[0]);
            return mediaTyper_ts_1.format(type);
        }
        catch {
            return;
        }
    }
    /** Given a value of the content type of a request and an array of types,
     * provide the matching type or `false` if no types are matched.
     */
    function isMediaType(value, types) {
        const val = normalizeType(value);
        if (!val) {
            return false;
        }
        if (!types.length) {
            return val;
        }
        for (const type of types) {
            if (mimeMatch(normalize(type), val)) {
                return type[0] === "+" || type.includes("*") ? val : type;
            }
        }
        return false;
    }
    exports_69("isMediaType", isMediaType);
    return {
        setters: [
            function (deps_ts_5_1) {
                deps_ts_5 = deps_ts_5_1;
            },
            function (mediaTyper_ts_1_1) {
                mediaTyper_ts_1 = mediaTyper_ts_1_1;
            }
        ],
        execute: function () {
        }
    };
});
// Copyright 2018-2020 the oak authors. All rights reserved. MIT license.
System.register("https://deno.land/x/oak/util", ["https://deno.land/x/oak/deps", "https://deno.land/x/oak/httpError"], function (exports_70, context_70) {
    "use strict";
    var deps_ts_6, httpError_ts_1, ENCODE_CHARS_REGEXP, HTAB, SPACE, CR, LF, UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE, UP_PATH_REGEXP;
    var __moduleName = context_70 && context_70.id;
    /** Safely decode a URI component, where if it fails, instead of throwing,
     * just returns the original string
     */
    function decodeComponent(text) {
        try {
            return decodeURIComponent(text);
        }
        catch {
            return text;
        }
    }
    exports_70("decodeComponent", decodeComponent);
    /** Encodes the url preventing double enconding */
    function encodeUrl(url) {
        return String(url)
            .replace(UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE)
            .replace(ENCODE_CHARS_REGEXP, encodeURI);
    }
    exports_70("encodeUrl", encodeUrl);
    function getRandomFilename(prefix = "", extension = "") {
        return `${prefix}${new deps_ts_6.Sha1().update(crypto.getRandomValues(new Uint8Array(256))).hex()}${extension ? `.${extension}` : ""}`;
    }
    exports_70("getRandomFilename", getRandomFilename);
    /** Determines if a HTTP `Status` is an `ErrorStatus` (4XX or 5XX). */
    function isErrorStatus(value) {
        return [
            deps_ts_6.Status.BadRequest,
            deps_ts_6.Status.Unauthorized,
            deps_ts_6.Status.PaymentRequired,
            deps_ts_6.Status.Forbidden,
            deps_ts_6.Status.NotFound,
            deps_ts_6.Status.MethodNotAllowed,
            deps_ts_6.Status.NotAcceptable,
            deps_ts_6.Status.ProxyAuthRequired,
            deps_ts_6.Status.RequestTimeout,
            deps_ts_6.Status.Conflict,
            deps_ts_6.Status.Gone,
            deps_ts_6.Status.LengthRequired,
            deps_ts_6.Status.PreconditionFailed,
            deps_ts_6.Status.RequestEntityTooLarge,
            deps_ts_6.Status.RequestURITooLong,
            deps_ts_6.Status.UnsupportedMediaType,
            deps_ts_6.Status.RequestedRangeNotSatisfiable,
            deps_ts_6.Status.ExpectationFailed,
            deps_ts_6.Status.Teapot,
            deps_ts_6.Status.MisdirectedRequest,
            deps_ts_6.Status.UnprocessableEntity,
            deps_ts_6.Status.Locked,
            deps_ts_6.Status.FailedDependency,
            deps_ts_6.Status.UpgradeRequired,
            deps_ts_6.Status.PreconditionRequired,
            deps_ts_6.Status.TooManyRequests,
            deps_ts_6.Status.RequestHeaderFieldsTooLarge,
            deps_ts_6.Status.UnavailableForLegalReasons,
            deps_ts_6.Status.InternalServerError,
            deps_ts_6.Status.NotImplemented,
            deps_ts_6.Status.BadGateway,
            deps_ts_6.Status.ServiceUnavailable,
            deps_ts_6.Status.GatewayTimeout,
            deps_ts_6.Status.HTTPVersionNotSupported,
            deps_ts_6.Status.VariantAlsoNegotiates,
            deps_ts_6.Status.InsufficientStorage,
            deps_ts_6.Status.LoopDetected,
            deps_ts_6.Status.NotExtended,
            deps_ts_6.Status.NetworkAuthenticationRequired,
        ].includes(value);
    }
    exports_70("isErrorStatus", isErrorStatus);
    /** Determines if a HTTP `Status` is a `RedirectStatus` (3XX). */
    function isRedirectStatus(value) {
        return [
            deps_ts_6.Status.MultipleChoices,
            deps_ts_6.Status.MovedPermanently,
            deps_ts_6.Status.Found,
            deps_ts_6.Status.SeeOther,
            deps_ts_6.Status.UseProxy,
            deps_ts_6.Status.TemporaryRedirect,
            deps_ts_6.Status.PermanentRedirect,
        ].includes(value);
    }
    exports_70("isRedirectStatus", isRedirectStatus);
    /** Determines if a string "looks" like HTML */
    function isHtml(value) {
        return /^\s*<(?:!DOCTYPE|html|body)/i.test(value);
    }
    exports_70("isHtml", isHtml);
    /** Returns `u8` with leading white space removed. */
    function skipLWSPChar(u8) {
        const result = new Uint8Array(u8.length);
        let j = 0;
        for (let i = 0; i < u8.length; i++) {
            if (u8[i] === SPACE || u8[i] === HTAB)
                continue;
            result[j++] = u8[i];
        }
        return result.slice(0, j);
    }
    exports_70("skipLWSPChar", skipLWSPChar);
    function stripEol(value) {
        if (value[value.byteLength - 1] == LF) {
            let drop = 1;
            if (value.byteLength > 1 && value[value.byteLength - 2] === CR) {
                drop = 2;
            }
            return value.subarray(0, value.byteLength - drop);
        }
        return value;
    }
    exports_70("stripEol", stripEol);
    function resolvePath(rootPath, relativePath) {
        let path = relativePath;
        let root = rootPath;
        // root is optional, similar to root.resolve
        if (arguments.length === 1) {
            path = rootPath;
            root = Deno.cwd();
        }
        if (path == null) {
            throw new TypeError("Argument relativePath is required.");
        }
        // containing NULL bytes is malicious
        if (path.includes("\0")) {
            throw httpError_ts_1.createHttpError(400, "Malicious Path");
        }
        // path should never be absolute
        if (deps_ts_6.isAbsolute(path)) {
            throw httpError_ts_1.createHttpError(400, "Malicious Path");
        }
        // path outside root
        if (UP_PATH_REGEXP.test(deps_ts_6.normalize("." + deps_ts_6.sep + path))) {
            throw httpError_ts_1.createHttpError(403);
        }
        // join the relative path
        return deps_ts_6.normalize(deps_ts_6.join(deps_ts_6.resolve(root), path));
    }
    exports_70("resolvePath", resolvePath);
    return {
        setters: [
            function (deps_ts_6_1) {
                deps_ts_6 = deps_ts_6_1;
            },
            function (httpError_ts_1_1) {
                httpError_ts_1 = httpError_ts_1_1;
            }
        ],
        execute: function () {
            ENCODE_CHARS_REGEXP = /(?:[^\x21\x25\x26-\x3B\x3D\x3F-\x5B\x5D\x5F\x61-\x7A\x7E]|%(?:[^0-9A-Fa-f]|[0-9A-Fa-f][^0-9A-Fa-f]|$))+/g;
            HTAB = "\t".charCodeAt(0);
            SPACE = " ".charCodeAt(0);
            CR = "\r".charCodeAt(0);
            LF = "\n".charCodeAt(0);
            UNMATCHED_SURROGATE_PAIR_REGEXP = /(^|[^\uD800-\uDBFF])[\uDC00-\uDFFF]|[\uD800-\uDBFF]([^\uDC00-\uDFFF]|$)/g;
            UNMATCHED_SURROGATE_PAIR_REPLACE = "$1\uFFFD$2";
            /*!
             * Adapted directly from https://github.com/pillarjs/resolve-path
             * which is licensed as follows:
             *
             * The MIT License (MIT)
             *
             * Copyright (c) 2014 Jonathan Ong <me@jongleberry.com>
             * Copyright (c) 2015-2018 Douglas Christopher Wilson <doug@somethingdoug.com>
             *
             * Permission is hereby granted, free of charge, to any person obtaining
             * a copy of this software and associated documentation files (the
             * 'Software'), to deal in the Software without restriction, including
             * without limitation the rights to use, copy, modify, merge, publish,
             * distribute, sublicense, and/or sell copies of the Software, and to
             * permit persons to whom the Software is furnished to do so, subject to
             * the following conditions:
             *
             * The above copyright notice and this permission notice shall be
             * included in all copies or substantial portions of the Software.
             *
             * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
             * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
             * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
             * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
             * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
             * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
             * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
             */
            UP_PATH_REGEXP = /(?:^|[\\/])\.\.(?:[\\/]|$)/;
        }
    };
});
// Copyright 2018-2020 the oak authors. All rights reserved. MIT license.
System.register("https://deno.land/x/oak/buf_reader", ["https://deno.land/x/oak/deps", "https://deno.land/x/oak/util"], function (exports_71, context_71) {
    "use strict";
    var deps_ts_7, util_ts_5, DEFAULT_BUF_SIZE, MIN_BUF_SIZE, MAX_CONSECUTIVE_EMPTY_READS, CR, LF, BufferFullError, BufReader;
    var __moduleName = context_71 && context_71.id;
    return {
        setters: [
            function (deps_ts_7_1) {
                deps_ts_7 = deps_ts_7_1;
            },
            function (util_ts_5_1) {
                util_ts_5 = util_ts_5_1;
            }
        ],
        execute: function () {
            DEFAULT_BUF_SIZE = 4096;
            MIN_BUF_SIZE = 16;
            MAX_CONSECUTIVE_EMPTY_READS = 100;
            CR = "\r".charCodeAt(0);
            LF = "\n".charCodeAt(0);
            BufferFullError = class BufferFullError extends Error {
                constructor(partial) {
                    super("Buffer full");
                    this.partial = partial;
                    this.name = "BufferFullError";
                }
            };
            exports_71("BufferFullError", BufferFullError);
            /** BufReader implements buffering for a Reader object. */
            BufReader = class BufReader {
                constructor(rd, size = DEFAULT_BUF_SIZE) {
                    this.#posRead = 0;
                    this.#posWrite = 0;
                    this.#eof = false;
                    // Reads a new chunk into the buffer.
                    this.#fill = async () => {
                        // Slide existing data to beginning.
                        if (this.#posRead > 0) {
                            this.#buffer.copyWithin(0, this.#posRead, this.#posWrite);
                            this.#posWrite -= this.#posRead;
                            this.#posRead = 0;
                        }
                        if (this.#posWrite >= this.#buffer.byteLength) {
                            throw Error("bufio: tried to fill full buffer");
                        }
                        // Read new data: try a limited number of times.
                        for (let i = MAX_CONSECUTIVE_EMPTY_READS; i > 0; i--) {
                            const rr = await this.#reader.read(this.#buffer.subarray(this.#posWrite));
                            if (rr === null) {
                                this.#eof = true;
                                return;
                            }
                            deps_ts_7.assert(rr >= 0, "negative read");
                            this.#posWrite += rr;
                            if (rr > 0) {
                                return;
                            }
                        }
                        throw new Error(`No progress after ${MAX_CONSECUTIVE_EMPTY_READS} read() calls`);
                    };
                    this.#reset = (buffer, reader) => {
                        this.#buffer = buffer;
                        this.#reader = reader;
                        this.#eof = false;
                    };
                    if (size < MIN_BUF_SIZE) {
                        size = MIN_BUF_SIZE;
                    }
                    this.#reset(new Uint8Array(size), rd);
                }
                #buffer;
                #reader;
                #posRead;
                #posWrite;
                #eof;
                // Reads a new chunk into the buffer.
                #fill;
                #reset;
                buffered() {
                    return this.#posWrite - this.#posRead;
                }
                async readLine(strip = true) {
                    let line;
                    try {
                        line = await this.readSlice(LF);
                    }
                    catch (err) {
                        let { partial } = err;
                        deps_ts_7.assert(partial instanceof Uint8Array, "Caught error from `readSlice()` without `partial` property");
                        // Don't throw if `readSlice()` failed with `BufferFullError`, instead we
                        // just return whatever is available and set the `more` flag.
                        if (!(err instanceof BufferFullError)) {
                            throw err;
                        }
                        // Handle the case where "\r\n" straddles the buffer.
                        if (!this.#eof &&
                            partial.byteLength > 0 &&
                            partial[partial.byteLength - 1] === CR) {
                            // Put the '\r' back on buf and drop it from line.
                            // Let the next call to ReadLine check for "\r\n".
                            deps_ts_7.assert(this.#posRead > 0, "Tried to rewind past start of buffer");
                            this.#posRead--;
                            partial = partial.subarray(0, partial.byteLength - 1);
                        }
                        return { bytes: partial, eol: this.#eof };
                    }
                    if (line === null) {
                        return null;
                    }
                    if (line.byteLength === 0) {
                        return { bytes: line, eol: true };
                    }
                    if (strip) {
                        line = util_ts_5.stripEol(line);
                    }
                    return { bytes: line, eol: true };
                }
                async readSlice(delim) {
                    let s = 0; // search start index
                    let slice;
                    while (true) {
                        // Search buffer.
                        let i = this.#buffer.subarray(this.#posRead + s, this.#posWrite).indexOf(delim);
                        if (i >= 0) {
                            i += s;
                            slice = this.#buffer.subarray(this.#posRead, this.#posRead + i + 1);
                            this.#posRead += i + 1;
                            break;
                        }
                        // EOF?
                        if (this.#eof) {
                            if (this.#posRead === this.#posWrite) {
                                return null;
                            }
                            slice = this.#buffer.subarray(this.#posRead, this.#posWrite);
                            this.#posRead = this.#posWrite;
                            break;
                        }
                        // Buffer full?
                        if (this.buffered() >= this.#buffer.byteLength) {
                            this.#posRead = this.#posWrite;
                            // #4521 The internal buffer should not be reused across reads because it causes corruption of data.
                            const oldbuf = this.#buffer;
                            const newbuf = this.#buffer.slice(0);
                            this.#buffer = newbuf;
                            throw new BufferFullError(oldbuf);
                        }
                        s = this.#posWrite - this.#posRead; // do not rescan area we scanned before
                        // Buffer is not full.
                        try {
                            await this.#fill();
                        }
                        catch (err) {
                            err.partial = slice;
                            throw err;
                        }
                    }
                    return slice;
                }
            };
            exports_71("BufReader", BufReader);
        }
    };
});
// Copyright 2018-2020 the oak authors. All rights reserved. MIT license.
System.register("https://deno.land/x/oak/headers", ["https://deno.land/x/oak/httpError"], function (exports_72, context_72) {
    "use strict";
    var httpError_ts_2, COLON, HTAB, SPACE, decoder;
    var __moduleName = context_72 && context_72.id;
    /** With a provided attribute pattern, return a RegExp which will match and
     * capture in the first group the value of the attribute from a header value. */
    function toParamRegExp(attributePattern, flags) {
        // deno-fmt-ignore
        return new RegExp(`(?:^|;)\\s*${attributePattern}\\s*=\\s*` +
            `(` +
            `[^";\\s][^;\\s]*` +
            `|` +
            `"(?:[^"\\\\]|\\\\"?)+"?` +
            `)`, flags);
    }
    exports_72("toParamRegExp", toParamRegExp);
    /** Asynchronously read the headers out of body request and resolve with them as
     * a `Headers` object. */
    async function readHeaders(body) {
        const headers = new Headers();
        let readResult = await body.readLine();
        while (readResult) {
            const { bytes } = readResult;
            if (!bytes.length) {
                return headers;
            }
            let i = bytes.indexOf(COLON);
            if (i === -1) {
                throw new httpError_ts_2.httpErrors.BadRequest(`Malformed header: ${decoder.decode(bytes)}`);
            }
            const key = decoder.decode(bytes.subarray(0, i));
            if (key === "") {
                throw new httpError_ts_2.httpErrors.BadRequest("Invalid header key.");
            }
            i++;
            while (i < bytes.byteLength && (bytes[i] === SPACE || bytes[i] === HTAB)) {
                i++;
            }
            const value = decoder.decode(bytes.subarray(i));
            try {
                headers.append(key, value);
            }
            catch { }
            readResult = await body.readLine();
        }
        throw new httpError_ts_2.httpErrors.BadRequest("Unexpected end of body reached.");
    }
    exports_72("readHeaders", readHeaders);
    /** Unquotes attribute values that might be pass as part of a header. */
    function unquote(value) {
        if (value.startsWith(`"`)) {
            const parts = value.slice(1).split(`\\"`);
            for (let i = 0; i < parts.length; ++i) {
                const quoteIndex = parts[i].indexOf(`"`);
                if (quoteIndex !== -1) {
                    parts[i] = parts[i].slice(0, quoteIndex);
                    parts.length = i + 1; // Truncates and stops the loop
                }
                parts[i] = parts[i].replace(/\\(.)/g, "$1");
            }
            value = parts.join(`"`);
        }
        return value;
    }
    exports_72("unquote", unquote);
    return {
        setters: [
            function (httpError_ts_2_1) {
                httpError_ts_2 = httpError_ts_2_1;
            }
        ],
        execute: function () {
            COLON = ":".charCodeAt(0);
            HTAB = "\t".charCodeAt(0);
            SPACE = " ".charCodeAt(0);
            decoder = new TextDecoder();
        }
    };
});
/**
 * Adapted directly from content-disposition.js at
 * https://github.com/Rob--W/open-in-browser/blob/master/extension/content-disposition.js
 * which is licensed as:
 *
 * (c) 2017 Rob Wu <rob@robwu.nl> (https://robwu.nl)
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
System.register("https://deno.land/x/oak/content_disposition", ["https://deno.land/x/oak/headers"], function (exports_73, context_73) {
    "use strict";
    var headers_ts_1, needsEncodingFixup, FILENAME_STAR_REGEX, FILENAME_START_ITER_REGEX, FILENAME_REGEX;
    var __moduleName = context_73 && context_73.id;
    function fixupEncoding(value) {
        if (needsEncodingFixup && /[\x80-\xff]/.test(value)) {
            value = textDecode("utf-8", value);
            if (needsEncodingFixup) {
                value = textDecode("iso-8859-1", value);
            }
        }
        return value;
    }
    function rfc2047decode(value) {
        if (!value.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(value)) {
            return value;
        }
        return value.replace(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, (_, charset, encoding, text) => {
            if (encoding === "q" || encoding === "Q") {
                text = text.replace(/_/g, " ");
                text = text.replace(/=([0-9a-fA-F]{2})/g, (_, hex) => String.fromCharCode(parseInt(hex, 16)));
                return textDecode(charset, text);
            }
            try {
                text = atob(text);
            }
            catch { }
            return textDecode(charset, text);
        });
    }
    function rfc2231getParam(header) {
        const matches = [];
        let match;
        while ((match = FILENAME_START_ITER_REGEX.exec(header))) {
            const [, ns, quote, part] = match;
            const n = parseInt(ns, 10);
            if (n in matches) {
                if (n === 0) {
                    break;
                }
                continue;
            }
            matches[n] = [quote, part];
        }
        const parts = [];
        for (let n = 0; n < matches.length; ++n) {
            if (!(n in matches)) {
                break;
            }
            let [quote, part] = matches[n];
            part = headers_ts_1.unquote(part);
            if (quote) {
                part = unescape(part);
                if (n === 0) {
                    part = rfc5987decode(part);
                }
            }
            parts.push(part);
        }
        return parts.join("");
    }
    function rfc5987decode(value) {
        const encodingEnd = value.indexOf(`'`);
        if (encodingEnd === -1) {
            return value;
        }
        const encoding = value.slice(0, encodingEnd);
        const langValue = value.slice(encodingEnd + 1);
        return textDecode(encoding, langValue.replace(/^[^']*'/, ""));
    }
    function textDecode(encoding, value) {
        if (encoding) {
            try {
                const decoder = new TextDecoder(encoding, { fatal: true });
                const bytes = Array.from(value, (c) => c.charCodeAt(0));
                if (bytes.every((code) => code <= 0xFF)) {
                    value = decoder.decode(new Uint8Array(bytes));
                    needsEncodingFixup = false;
                }
            }
            catch { }
        }
        return value;
    }
    function getFilename(header) {
        needsEncodingFixup = true;
        // filename*=ext-value ("ext-value" from RFC 5987, referenced by RFC 6266).
        let matches = FILENAME_STAR_REGEX.exec(header);
        if (matches) {
            const [, filename] = matches;
            return fixupEncoding(rfc2047decode(rfc5987decode(unescape(headers_ts_1.unquote(filename)))));
        }
        // Continuations (RFC 2231 section 3, referenced by RFC 5987 section 3.1).
        // filename*n*=part
        // filename*n=part
        const filename = rfc2231getParam(header);
        if (filename) {
            return fixupEncoding(rfc2047decode(filename));
        }
        // filename=value (RFC 5987, section 4.1).
        matches = FILENAME_REGEX.exec(header);
        if (matches) {
            const [, filename] = matches;
            return fixupEncoding(rfc2047decode(headers_ts_1.unquote(filename)));
        }
        return "";
    }
    exports_73("getFilename", getFilename);
    return {
        setters: [
            function (headers_ts_1_1) {
                headers_ts_1 = headers_ts_1_1;
            }
        ],
        execute: function () {
            needsEncodingFixup = false;
            FILENAME_STAR_REGEX = headers_ts_1.toParamRegExp("filename\\*", "i");
            FILENAME_START_ITER_REGEX = headers_ts_1.toParamRegExp("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");
            FILENAME_REGEX = headers_ts_1.toParamRegExp("filename", "i");
        }
    };
});
// Copyright 2018-2020 the oak authors. All rights reserved. MIT license.
System.register("https://deno.land/x/oak/multipart", ["https://deno.land/x/oak/buf_reader", "https://deno.land/x/oak/content_disposition", "https://deno.land/x/oak/deps", "https://deno.land/x/oak/headers", "https://deno.land/x/oak/httpError", "https://deno.land/x/oak/util"], function (exports_74, context_74) {
    "use strict";
    var buf_reader_ts_1, content_disposition_ts_1, deps_ts_8, headers_ts_2, httpError_ts_3, util_ts_6, decoder, encoder, BOUNDARY_PARAM_REGEX, DEFAULT_BUFFER_SIZE, DEFAULT_MAX_FILE_SIZE, DEFAULT_MAX_SIZE, NAME_PARAM_REGEX, FormDataReader;
    var __moduleName = context_74 && context_74.id;
    function append(a, b) {
        const ab = new Uint8Array(a.length + b.length);
        ab.set(a, 0);
        ab.set(b, a.length);
        return ab;
    }
    function isEqual(a, b) {
        return deps_ts_8.equal(util_ts_6.skipLWSPChar(a), b);
    }
    async function readToStart(body, part) {
        let lineResult;
        let started = false;
        while ((lineResult = await body.readLine())) {
            if (isEqual(lineResult.bytes, part)) {
                started = true;
                break;
            }
        }
        if (!started) {
            throw new httpError_ts_3.httpErrors.BadRequest("Unable to find start of multi-part body.");
        }
    }
    /** Yield up individual parts by reading the body and parsing out the ford
     * data values. */
    async function* parts({ body, final, part, maxFileSize, maxSize, outPath, prefix }) {
        async function getFile(contentType) {
            const ext = deps_ts_8.extension(contentType);
            if (!ext) {
                throw new httpError_ts_3.httpErrors.BadRequest(`Invalid media type for part: ${ext}`);
            }
            if (!outPath) {
                outPath = await Deno.makeTempDir();
            }
            const filename = `${outPath}/${util_ts_6.getRandomFilename(prefix, ext)}`;
            const file = await Deno.open(filename, { write: true, createNew: true });
            return [filename, file];
        }
        while (true) {
            const headers = await headers_ts_2.readHeaders(body);
            const contentType = headers.get("content-type");
            const contentDisposition = headers.get("content-disposition");
            if (!contentDisposition) {
                throw new httpError_ts_3.httpErrors.BadRequest("Form data part missing content-disposition header");
            }
            if (!contentDisposition.match(/^form-data;/i)) {
                throw new httpError_ts_3.httpErrors.BadRequest(`Unexpected content-disposition header: "${contentDisposition}"`);
            }
            const matches = NAME_PARAM_REGEX.exec(contentDisposition);
            if (!matches) {
                throw new httpError_ts_3.httpErrors.BadRequest(`Unable to determine name of form body part`);
            }
            let [, name] = matches;
            name = headers_ts_2.unquote(name);
            if (contentType) {
                const originalName = content_disposition_ts_1.getFilename(contentDisposition);
                let byteLength = 0;
                let file;
                let filename;
                let buf;
                if (maxSize) {
                    buf = new Uint8Array();
                }
                else {
                    const result = await getFile(contentType);
                    filename = result[0];
                    file = result[1];
                }
                while (true) {
                    const readResult = await body.readLine(false);
                    if (!readResult) {
                        throw new httpError_ts_3.httpErrors.BadRequest("Unexpected EOF reached");
                    }
                    let { bytes } = readResult;
                    const strippedBytes = util_ts_6.stripEol(bytes);
                    if (isEqual(strippedBytes, part) || isEqual(strippedBytes, final)) {
                        if (file) {
                            file.close();
                        }
                        yield [
                            name,
                            {
                                content: buf,
                                contentType,
                                name,
                                filename,
                                originalName,
                            },
                        ];
                        if (isEqual(strippedBytes, final)) {
                            return;
                        }
                        break;
                    }
                    byteLength += bytes.byteLength;
                    if (byteLength > maxFileSize) {
                        if (file) {
                            file.close();
                        }
                        throw new httpError_ts_3.httpErrors.RequestEntityTooLarge(`File size exceeds limit of ${maxFileSize} bytes.`);
                    }
                    if (buf) {
                        if (byteLength > maxSize) {
                            const result = await getFile(contentType);
                            filename = result[0];
                            file = result[1];
                            await Deno.writeAll(file, buf);
                            buf = undefined;
                        }
                        else {
                            buf = append(buf, bytes);
                        }
                    }
                    if (file) {
                        await Deno.writeAll(file, bytes);
                    }
                }
            }
            else {
                const lines = [];
                while (true) {
                    const readResult = await body.readLine();
                    if (!readResult) {
                        throw new httpError_ts_3.httpErrors.BadRequest("Unexpected EOF reached");
                    }
                    const { bytes } = readResult;
                    if (isEqual(bytes, part) || isEqual(bytes, final)) {
                        yield [name, lines.join("\n")];
                        if (isEqual(bytes, final)) {
                            return;
                        }
                        break;
                    }
                    lines.push(decoder.decode(bytes));
                }
            }
        }
    }
    return {
        setters: [
            function (buf_reader_ts_1_1) {
                buf_reader_ts_1 = buf_reader_ts_1_1;
            },
            function (content_disposition_ts_1_1) {
                content_disposition_ts_1 = content_disposition_ts_1_1;
            },
            function (deps_ts_8_1) {
                deps_ts_8 = deps_ts_8_1;
            },
            function (headers_ts_2_1) {
                headers_ts_2 = headers_ts_2_1;
            },
            function (httpError_ts_3_1) {
                httpError_ts_3 = httpError_ts_3_1;
            },
            function (util_ts_6_1) {
                util_ts_6 = util_ts_6_1;
            }
        ],
        execute: function () {
            decoder = new TextDecoder();
            encoder = new TextEncoder();
            BOUNDARY_PARAM_REGEX = headers_ts_2.toParamRegExp("boundary", "i");
            DEFAULT_BUFFER_SIZE = 1048576; // 1mb
            DEFAULT_MAX_FILE_SIZE = 10485760; // 10mb
            DEFAULT_MAX_SIZE = 0; // all files written to disc
            NAME_PARAM_REGEX = headers_ts_2.toParamRegExp("name", "i");
            /** A class which provides an interface to access the fields of a
             * `multipart/form-data` body. */
            FormDataReader = class FormDataReader {
                constructor(contentType, body) {
                    this.#reading = false;
                    const matches = contentType.match(BOUNDARY_PARAM_REGEX);
                    if (!matches) {
                        throw new httpError_ts_3.httpErrors.BadRequest(`Content type "${contentType}" does not contain a valid boundary.`);
                    }
                    let [, boundary] = matches;
                    boundary = headers_ts_2.unquote(boundary);
                    this.#boundaryPart = encoder.encode(`--${boundary}`);
                    this.#boundaryFinal = encoder.encode(`--${boundary}--`);
                    this.#body = body;
                }
                #body;
                #boundaryFinal;
                #boundaryPart;
                #reading;
                /** Reads the multipart body of the response and resolves with an object which
                 * contains fields and files that were part of the response.
                 *
                 * *Note*: this method handles multiple files with the same `name` attribute
                 * in the request, but by design it does not handle multiple fields that share
                 * the same `name`.  If you expect the request body to contain multiple form
                 * data fields with the same name, it is better to use the `.stream()` method
                 * which will iterate over each form data field individually. */
                async read(options = {}) {
                    if (this.#reading) {
                        throw new Error("Body is already being read.");
                    }
                    this.#reading = true;
                    const { outPath, maxFileSize = DEFAULT_MAX_FILE_SIZE, maxSize = DEFAULT_MAX_SIZE, bufferSize = DEFAULT_BUFFER_SIZE, } = options;
                    const body = new buf_reader_ts_1.BufReader(this.#body, bufferSize);
                    await readToStart(body, this.#boundaryPart);
                    const result = { fields: {} };
                    try {
                        for await (const part of parts({
                            body,
                            part: this.#boundaryPart,
                            final: this.#boundaryFinal,
                            maxFileSize,
                            maxSize,
                            outPath,
                        })) {
                            const [key, value] = part;
                            if (typeof value === "string") {
                                result.fields[key] = value;
                            }
                            else {
                                if (!result.files) {
                                    result.files = [];
                                }
                                result.files.push(value);
                            }
                        }
                    }
                    catch (err) {
                        if (err instanceof Deno.errors.PermissionDenied) {
                            console.error(err.stack ? err.stack : `${err.name}: ${err.message}`);
                        }
                        else {
                            throw err;
                        }
                    }
                    return result;
                }
                /** Returns an iterator which will asynchronously yield each part of the form
                 * data.  The yielded value is a tuple, where the first element is the name
                 * of the part and the second element is a `string` or a `FormDataFile`
                 * object. */
                async *stream(options = {}) {
                    if (this.#reading) {
                        throw new Error("Body is already being read.");
                    }
                    this.#reading = true;
                    const { outPath, maxFileSize = DEFAULT_MAX_FILE_SIZE, maxSize = DEFAULT_MAX_SIZE, bufferSize = 32000, } = options;
                    const body = new buf_reader_ts_1.BufReader(this.#body, bufferSize);
                    await readToStart(body, this.#boundaryPart);
                    try {
                        for await (const part of parts({
                            body,
                            part: this.#boundaryPart,
                            final: this.#boundaryFinal,
                            maxFileSize,
                            maxSize,
                            outPath,
                        })) {
                            yield part;
                        }
                    }
                    catch (err) {
                        if (err instanceof Deno.errors.PermissionDenied) {
                            console.error(err.stack ? err.stack : `${err.name}: ${err.message}`);
                        }
                        else {
                            throw err;
                        }
                    }
                }
            };
            exports_74("FormDataReader", FormDataReader);
        }
    };
});
/*!
 * Adapted directly from negotiator at https://github.com/jshttp/negotiator/
 * which is licensed as follows:
 *
 * (The MIT License)
 *
 * Copyright (c) 2012-2014 Federico Romero
 * Copyright (c) 2012-2014 Isaac Z. Schlueter
 * Copyright (c) 2014-2015 Douglas Christopher Wilson
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * 'Software'), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
System.register("https://deno.land/x/oak/negotiation/common", [], function (exports_75, context_75) {
    "use strict";
    var __moduleName = context_75 && context_75.id;
    function compareSpecs(a, b) {
        return (b.q - a.q ||
            (b.s ?? 0) - (a.s ?? 0) ||
            (a.o ?? 0) - (b.o ?? 0) ||
            a.i - b.i ||
            0);
    }
    exports_75("compareSpecs", compareSpecs);
    function isQuality(spec) {
        return spec.q > 0;
    }
    exports_75("isQuality", isQuality);
    return {
        setters: [],
        execute: function () {
        }
    };
});
/*!
 * Adapted directly from negotiator at https://github.com/jshttp/negotiator/
 * which is licensed as follows:
 *
 * (The MIT License)
 *
 * Copyright (c) 2012-2014 Federico Romero
 * Copyright (c) 2012-2014 Isaac Z. Schlueter
 * Copyright (c) 2014-2015 Douglas Christopher Wilson
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * 'Software'), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
System.register("https://deno.land/x/oak/negotiation/charset", ["https://deno.land/x/oak/negotiation/common"], function (exports_76, context_76) {
    "use strict";
    var common_ts_3, SIMPLE_CHARSET_REGEXP;
    var __moduleName = context_76 && context_76.id;
    function parseCharset(str, i) {
        const match = SIMPLE_CHARSET_REGEXP.exec(str);
        if (!match) {
            return;
        }
        const [, charset] = match;
        let q = 1;
        if (match[2]) {
            const params = match[2].split(";");
            for (const param of params) {
                const [key, value] = param.trim().split("=");
                if (key === "q") {
                    q = parseFloat(value);
                    break;
                }
            }
        }
        return { charset, q, i };
    }
    function parseAcceptCharset(accept) {
        const accepts = accept.split(",");
        const result = [];
        for (let i = 0; i < accepts.length; i++) {
            const charset = parseCharset(accepts[i].trim(), i);
            if (charset) {
                result.push(charset);
            }
        }
        return result;
    }
    function specify(charset, spec, i) {
        let s = 0;
        if (spec.charset.toLowerCase() === charset.toLocaleLowerCase()) {
            s |= 1;
        }
        else if (spec.charset !== "*") {
            return;
        }
        return { i, o: spec.i, q: spec.q, s };
    }
    function getCharsetPriority(charset, accepted, index) {
        let priority = { i: -1, o: -1, q: 0, s: 0 };
        for (const accepts of accepted) {
            const spec = specify(charset, accepts, index);
            if (spec &&
                ((priority.s ?? 0) - (spec.s ?? 0) || priority.q - spec.q ||
                    (priority.o ?? 0) - (spec.o ?? 0)) < 0) {
                priority = spec;
            }
        }
        return priority;
    }
    function preferredCharsets(accept = "*", provided) {
        const accepts = parseAcceptCharset(accept);
        if (!provided) {
            return accepts
                .filter(common_ts_3.isQuality)
                .sort(common_ts_3.compareSpecs)
                .map((spec) => spec.charset);
        }
        const priorities = provided
            .map((type, index) => getCharsetPriority(type, accepts, index));
        return priorities
            .filter(common_ts_3.isQuality)
            .sort(common_ts_3.compareSpecs)
            .map((priority) => provided[priorities.indexOf(priority)]);
    }
    exports_76("preferredCharsets", preferredCharsets);
    return {
        setters: [
            function (common_ts_3_1) {
                common_ts_3 = common_ts_3_1;
            }
        ],
        execute: function () {
            SIMPLE_CHARSET_REGEXP = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
        }
    };
});
/*!
 * Adapted directly from negotiator at https://github.com/jshttp/negotiator/
 * which is licensed as follows:
 *
 * (The MIT License)
 *
 * Copyright (c) 2012-2014 Federico Romero
 * Copyright (c) 2012-2014 Isaac Z. Schlueter
 * Copyright (c) 2014-2015 Douglas Christopher Wilson
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * 'Software'), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
System.register("https://deno.land/x/oak/negotiation/encoding", ["https://deno.land/x/oak/negotiation/common"], function (exports_77, context_77) {
    "use strict";
    var common_ts_4, simpleEncodingRegExp;
    var __moduleName = context_77 && context_77.id;
    function parseEncoding(str, i) {
        const match = simpleEncodingRegExp.exec(str);
        if (!match) {
            return undefined;
        }
        const encoding = match[1];
        let q = 1;
        if (match[2]) {
            const params = match[2].split(";");
            for (const param of params) {
                const p = param.trim().split("=");
                if (p[0] === "q") {
                    q = parseFloat(p[1]);
                    break;
                }
            }
        }
        return { encoding, q, i };
    }
    function specify(encoding, spec, i = -1) {
        if (!spec.encoding) {
            return;
        }
        let s = 0;
        if (spec.encoding.toLocaleLowerCase() === encoding.toLocaleLowerCase()) {
            s = 1;
        }
        else if (spec.encoding !== "*") {
            return;
        }
        return {
            i,
            o: spec.i,
            q: spec.q,
            s,
        };
    }
    function parseAcceptEncoding(accept) {
        const accepts = accept.split(",");
        const parsedAccepts = [];
        let hasIdentity = false;
        let minQuality = 1;
        for (let i = 0; i < accepts.length; i++) {
            const encoding = parseEncoding(accepts[i].trim(), i);
            if (encoding) {
                parsedAccepts.push(encoding);
                hasIdentity = hasIdentity || !!specify("identity", encoding);
                minQuality = Math.min(minQuality, encoding.q || 1);
            }
        }
        if (!hasIdentity) {
            parsedAccepts.push({
                encoding: "identity",
                q: minQuality,
                i: accepts.length - 1,
            });
        }
        return parsedAccepts;
    }
    function getEncodingPriority(encoding, accepted, index) {
        let priority = { o: -1, q: 0, s: 0, i: 0 };
        for (const s of accepted) {
            const spec = specify(encoding, s, index);
            if (spec &&
                (priority.s - spec.s || priority.q - spec.q ||
                    priority.o - spec.o) <
                    0) {
                priority = spec;
            }
        }
        return priority;
    }
    /** Given an `Accept-Encoding` string, parse out the encoding returning a
     * negotiated encoding based on the `provided` encodings otherwise just a
     * prioritized array of encodings. */
    function preferredEncodings(accept, provided) {
        const accepts = parseAcceptEncoding(accept);
        if (!provided) {
            return accepts
                .filter(common_ts_4.isQuality)
                .sort(common_ts_4.compareSpecs)
                .map((spec) => spec.encoding);
        }
        const priorities = provided.map((type, index) => getEncodingPriority(type, accepts, index));
        return priorities
            .filter(common_ts_4.isQuality)
            .sort(common_ts_4.compareSpecs)
            .map((priority) => provided[priorities.indexOf(priority)]);
    }
    exports_77("preferredEncodings", preferredEncodings);
    return {
        setters: [
            function (common_ts_4_1) {
                common_ts_4 = common_ts_4_1;
            }
        ],
        execute: function () {
            simpleEncodingRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
        }
    };
});
/*!
 * Adapted directly from negotiator at https://github.com/jshttp/negotiator/
 * which is licensed as follows:
 *
 * (The MIT License)
 *
 * Copyright (c) 2012-2014 Federico Romero
 * Copyright (c) 2012-2014 Isaac Z. Schlueter
 * Copyright (c) 2014-2015 Douglas Christopher Wilson
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * 'Software'), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
System.register("https://deno.land/x/oak/negotiation/language", ["https://deno.land/x/oak/negotiation/common"], function (exports_78, context_78) {
    "use strict";
    var common_ts_5, SIMPLE_LANGUAGE_REGEXP;
    var __moduleName = context_78 && context_78.id;
    function parseLanguage(str, i) {
        const match = SIMPLE_LANGUAGE_REGEXP.exec(str);
        if (!match) {
            return undefined;
        }
        const [, prefix, suffix] = match;
        const full = suffix ? `${prefix}-${suffix}` : prefix;
        let q = 1;
        if (match[3]) {
            const params = match[3].split(";");
            for (const param of params) {
                const [key, value] = param.trim().split("=");
                if (key === "q") {
                    q = parseFloat(value);
                    break;
                }
            }
        }
        return { prefix, suffix, full, q, i };
    }
    function parseAcceptLanguage(accept) {
        const accepts = accept.split(",");
        const result = [];
        for (let i = 0; i < accepts.length; i++) {
            const language = parseLanguage(accepts[i].trim(), i);
            if (language) {
                result.push(language);
            }
        }
        return result;
    }
    function specify(language, spec, i) {
        const p = parseLanguage(language, i);
        if (!p) {
            return undefined;
        }
        let s = 0;
        if (spec.full.toLowerCase() === p.full.toLowerCase()) {
            s |= 4;
        }
        else if (spec.prefix.toLowerCase() === p.prefix.toLowerCase()) {
            s |= 2;
        }
        else if (spec.full.toLowerCase() === p.prefix.toLowerCase()) {
            s |= 1;
        }
        else if (spec.full !== "*") {
            return;
        }
        return { i, o: spec.i, q: spec.q, s };
    }
    function getLanguagePriority(language, accepted, index) {
        let priority = { i: -1, o: -1, q: 0, s: 0 };
        for (const accepts of accepted) {
            const spec = specify(language, accepts, index);
            if (spec &&
                ((priority.s ?? 0) - (spec.s ?? 0) || priority.q - spec.q ||
                    (priority.o ?? 0) - (spec.o ?? 0)) < 0) {
                priority = spec;
            }
        }
        return priority;
    }
    function preferredLanguages(accept = "*", provided) {
        const accepts = parseAcceptLanguage(accept);
        if (!provided) {
            return accepts
                .filter(common_ts_5.isQuality)
                .sort(common_ts_5.compareSpecs)
                .map((spec) => spec.full);
        }
        const priorities = provided
            .map((type, index) => getLanguagePriority(type, accepts, index));
        return priorities
            .filter(common_ts_5.isQuality)
            .sort(common_ts_5.compareSpecs)
            .map((priority) => provided[priorities.indexOf(priority)]);
    }
    exports_78("preferredLanguages", preferredLanguages);
    return {
        setters: [
            function (common_ts_5_1) {
                common_ts_5 = common_ts_5_1;
            }
        ],
        execute: function () {
            SIMPLE_LANGUAGE_REGEXP = /^\s*([^\s\-;]+)(?:-([^\s;]+))?\s*(?:;(.*))?$/;
        }
    };
});
/*!
 * Adapted directly from negotiator at https://github.com/jshttp/negotiator/
 * which is licensed as follows:
 *
 * (The MIT License)
 *
 * Copyright (c) 2012-2014 Federico Romero
 * Copyright (c) 2012-2014 Isaac Z. Schlueter
 * Copyright (c) 2014-2015 Douglas Christopher Wilson
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * 'Software'), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
System.register("https://deno.land/x/oak/negotiation/mediaType", ["https://deno.land/x/oak/negotiation/common"], function (exports_79, context_79) {
    "use strict";
    var common_ts_6, simpleMediaTypeRegExp;
    var __moduleName = context_79 && context_79.id;
    function quoteCount(str) {
        let count = 0;
        let index = 0;
        while ((index = str.indexOf(`"`, index)) !== -1) {
            count++;
            index++;
        }
        return count;
    }
    function splitMediaTypes(accept) {
        const accepts = accept.split(",");
        let j = 0;
        for (let i = 1; i < accepts.length; i++) {
            if (quoteCount(accepts[j]) % 2 === 0) {
                accepts[++j] = accepts[i];
            }
            else {
                accepts[j] += `,${accepts[i]}`;
            }
        }
        accepts.length = j + 1;
        return accepts;
    }
    function splitParameters(str) {
        const parameters = str.split(";");
        let j = 0;
        for (let i = 1; i < parameters.length; i++) {
            if (quoteCount(parameters[j]) % 2 === 0) {
                parameters[++j] = parameters[i];
            }
            else {
                parameters[j] += `;${parameters[i]}`;
            }
        }
        parameters.length = j + 1;
        return parameters.map((p) => p.trim());
    }
    function splitKeyValuePair(str) {
        const [key, value] = str.split("=");
        return [key.toLowerCase(), value];
    }
    function parseMediaType(str, i) {
        const match = simpleMediaTypeRegExp.exec(str);
        if (!match) {
            return;
        }
        const params = Object.create(null);
        let q = 1;
        const [, type, subtype, parameters] = match;
        if (parameters) {
            const kvps = splitParameters(parameters).map(splitKeyValuePair);
            for (const [key, val] of kvps) {
                const value = val && val[0] === `"` && val[val.length - 1] === `"`
                    ? val.substr(1, val.length - 2)
                    : val;
                if (key === "q" && value) {
                    q = parseFloat(value);
                    break;
                }
                params[key] = value;
            }
        }
        return { type, subtype, params, q, i };
    }
    function parseAccept(accept) {
        const accepts = splitMediaTypes(accept);
        const mediaTypes = [];
        for (let i = 0; i < accepts.length; i++) {
            const mediaType = parseMediaType(accepts[i].trim(), i);
            if (mediaType) {
                mediaTypes.push(mediaType);
            }
        }
        return mediaTypes;
    }
    function getFullType(spec) {
        return `${spec.type}/${spec.subtype}`;
    }
    function specify(type, spec, index) {
        const p = parseMediaType(type, index);
        if (!p) {
            return;
        }
        let s = 0;
        if (spec.type.toLowerCase() === p.type.toLowerCase()) {
            s |= 4;
        }
        else if (spec.type !== "*") {
            return;
        }
        if (spec.subtype.toLowerCase() === p.subtype.toLowerCase()) {
            s |= 2;
        }
        else if (spec.subtype !== "*") {
            return;
        }
        const keys = Object.keys(spec.params);
        if (keys.length) {
            if (keys.every((key) => (spec.params[key] || "").toLowerCase() ===
                (p.params[key] || "").toLowerCase())) {
                s |= 1;
            }
            else {
                return;
            }
        }
        return {
            i: index,
            o: spec.o,
            q: spec.q,
            s,
        };
    }
    function getMediaTypePriority(type, accepted, index) {
        let priority = { o: -1, q: 0, s: 0, i: index };
        for (const accepts of accepted) {
            const spec = specify(type, accepts, index);
            if (spec &&
                ((priority.s || 0) - (spec.s || 0) ||
                    (priority.q || 0) - (spec.q || 0) ||
                    (priority.o || 0) - (spec.o || 0)) < 0) {
                priority = spec;
            }
        }
        return priority;
    }
    function preferredMediaTypes(accept, provided) {
        const accepts = parseAccept(accept === undefined ? "*/*" : accept || "");
        if (!provided) {
            return accepts
                .filter(common_ts_6.isQuality)
                .sort(common_ts_6.compareSpecs)
                .map(getFullType);
        }
        const priorities = provided.map((type, index) => {
            return getMediaTypePriority(type, accepts, index);
        });
        return priorities
            .filter(common_ts_6.isQuality)
            .sort(common_ts_6.compareSpecs)
            .map((priority) => provided[priorities.indexOf(priority)]);
    }
    exports_79("preferredMediaTypes", preferredMediaTypes);
    return {
        setters: [
            function (common_ts_6_1) {
                common_ts_6 = common_ts_6_1;
            }
        ],
        execute: function () {
            simpleMediaTypeRegExp = /^\s*([^\s\/;]+)\/([^;\s]+)\s*(?:;(.*))?$/;
        }
    };
});
// Copyright 2018-2020 the oak authors. All rights reserved. MIT license.
System.register("https://deno.land/x/oak/request", ["https://deno.land/x/oak/httpError", "https://deno.land/x/oak/isMediaType", "https://deno.land/x/oak/multipart", "https://deno.land/x/oak/negotiation/charset", "https://deno.land/x/oak/negotiation/encoding", "https://deno.land/x/oak/negotiation/language", "https://deno.land/x/oak/negotiation/mediaType"], function (exports_80, context_80) {
    "use strict";
    var httpError_ts_4, isMediaType_ts_1, multipart_ts_1, charset_ts_1, encoding_ts_1, language_ts_1, mediaType_ts_1, decoder, defaultBodyContentTypes, Request;
    var __moduleName = context_80 && context_80.id;
    return {
        setters: [
            function (httpError_ts_4_1) {
                httpError_ts_4 = httpError_ts_4_1;
            },
            function (isMediaType_ts_1_1) {
                isMediaType_ts_1 = isMediaType_ts_1_1;
            },
            function (multipart_ts_1_1) {
                multipart_ts_1 = multipart_ts_1_1;
            },
            function (charset_ts_1_1) {
                charset_ts_1 = charset_ts_1_1;
            },
            function (encoding_ts_1_1) {
                encoding_ts_1 = encoding_ts_1_1;
            },
            function (language_ts_1_1) {
                language_ts_1 = language_ts_1_1;
            },
            function (mediaType_ts_1_1) {
                mediaType_ts_1 = mediaType_ts_1_1;
            }
        ],
        execute: function () {
            decoder = new TextDecoder();
            defaultBodyContentTypes = {
                json: ["json", "application/*+json", "application/csp-report"],
                form: ["urlencoded"],
                formData: ["multipart"],
                text: ["text"],
            };
            /** An interface which provides information about the current request. */
            Request = class Request {
                constructor(serverRequest, proxy = false, secure = false) {
                    this.#proxy = proxy;
                    this.#secure = secure;
                    this.#serverRequest = serverRequest;
                }
                #body;
                #proxy;
                #rawBodyPromise;
                #secure;
                #serverRequest;
                #url;
                /** Is `true` if the request has a body, otherwise `false`. */
                get hasBody() {
                    return (this.headers.get("transfer-encoding") !== null ||
                        !!parseInt(this.headers.get("content-length") ?? ""));
                }
                /** The `Headers` supplied in the request. */
                get headers() {
                    return this.#serverRequest.headers;
                }
                /** Request remote address. When the application's `.proxy` is true, the
                 * `X-Forwarded-For` will be used to determine the requesting remote address.
                 */
                get ip() {
                    return this.#proxy
                        ? this.ips[0]
                        : this.#serverRequest.conn.remoteAddr.hostname;
                }
                /** When the application's `.proxy` is `true`, this will be set to an array of
                 * IPs, ordered from upstream to downstream, based on the value of the header
                 * `X-Forwarded-For`.  When `false` an empty array is returned. */
                get ips() {
                    return this.#proxy
                        ? (this.#serverRequest.headers.get("x-forwarded-for") ??
                            this.#serverRequest.conn.remoteAddr.hostname).split(/\s*,\s*/)
                        : [];
                }
                /** The HTTP Method used by the request. */
                get method() {
                    return this.#serverRequest.method;
                }
                /** Shortcut to `request.url.protocol === "https:"`. */
                get secure() {
                    return this.#secure;
                }
                /** Set to the value of the _original_ Deno server request. */
                get serverRequest() {
                    return this.#serverRequest;
                }
                /** A parsed URL for the request which complies with the browser standards.
                 * When the application's `.proxy` is `true`, this value will be based off of
                 * the `X-Forwarded-Proto` and `X-Forwarded-Host` header values if present in
                 * the request. */
                get url() {
                    if (!this.#url) {
                        const serverRequest = this.#serverRequest;
                        let proto;
                        let host;
                        if (this.#proxy) {
                            proto = serverRequest
                                .headers.get("x-forwarded-proto")?.split(/\s*,\s*/, 1)[0] ??
                                "http";
                            host = serverRequest.headers.get("x-forwarded-host") ??
                                serverRequest.headers.get("host") ?? "";
                        }
                        else {
                            proto = this.#secure ? "https" : "http";
                            host = serverRequest.headers.get("host") ?? "";
                        }
                        this.#url = new URL(`${proto}://${host}${serverRequest.url}`);
                    }
                    return this.#url;
                }
                accepts(...types) {
                    const acceptValue = this.#serverRequest.headers.get("Accept");
                    if (!acceptValue) {
                        return;
                    }
                    if (types.length) {
                        return mediaType_ts_1.preferredMediaTypes(acceptValue, types)[0];
                    }
                    return mediaType_ts_1.preferredMediaTypes(acceptValue);
                }
                acceptsCharsets(...charsets) {
                    const acceptCharsetValue = this.#serverRequest.headers.get("Accept-Charset");
                    if (!acceptCharsetValue) {
                        return;
                    }
                    if (charsets.length) {
                        return charset_ts_1.preferredCharsets(acceptCharsetValue, charsets)[0];
                    }
                    return charset_ts_1.preferredCharsets(acceptCharsetValue);
                }
                acceptsEncodings(...encodings) {
                    const acceptEncodingValue = this.#serverRequest.headers.get("Accept-Encoding");
                    if (!acceptEncodingValue) {
                        return;
                    }
                    if (encodings.length) {
                        return encoding_ts_1.preferredEncodings(acceptEncodingValue, encodings)[0];
                    }
                    return encoding_ts_1.preferredEncodings(acceptEncodingValue);
                }
                acceptsLanguages(...langs) {
                    const acceptLanguageValue = this.#serverRequest.headers.get("Accept-Language");
                    if (!acceptLanguageValue) {
                        return;
                    }
                    if (langs.length) {
                        return language_ts_1.preferredLanguages(acceptLanguageValue, langs)[0];
                    }
                    return language_ts_1.preferredLanguages(acceptLanguageValue);
                }
                async body({ asReader, contentTypes = {} } = {}) {
                    if (this.#body) {
                        if (asReader && this.#body.type !== "reader") {
                            return Promise.reject(new TypeError(`Body already consumed as type: "${this.#body.type}".`));
                        }
                        else if (this.#body.type === "reader") {
                            return Promise.reject(new TypeError(`Body already consumed as type: "reader".`));
                        }
                        return this.#body;
                    }
                    const encoding = this.headers.get("content-encoding") || "identity";
                    if (encoding !== "identity") {
                        throw new httpError_ts_4.httpErrors.UnsupportedMediaType(`Unsupported content-encoding: ${encoding}`);
                    }
                    if (!this.hasBody) {
                        return (this.#body = { type: "undefined", value: undefined });
                    }
                    const contentType = this.headers.get("content-type");
                    if (contentType) {
                        if (asReader) {
                            return (this.#body = {
                                type: "reader",
                                value: this.#serverRequest.body,
                            });
                        }
                        const contentTypesFormData = [
                            ...defaultBodyContentTypes.formData,
                            ...(contentTypes.formData ?? []),
                        ];
                        if (isMediaType_ts_1.isMediaType(contentType, contentTypesFormData)) {
                            return (this.#body = {
                                type: "form-data",
                                value: new multipart_ts_1.FormDataReader(contentType, this.#serverRequest.body),
                            });
                        }
                        const rawBody = await (this.#rawBodyPromise ??
                            (this.#rawBodyPromise = Deno.readAll(this.#serverRequest.body)));
                        const value = decoder.decode(rawBody);
                        const contentTypesRaw = contentTypes.raw;
                        const contentTypesJson = [
                            ...defaultBodyContentTypes.json,
                            ...(contentTypes.json ?? []),
                        ];
                        const contentTypesForm = [
                            ...defaultBodyContentTypes.form,
                            ...(contentTypes.form ?? []),
                        ];
                        const contentTypesText = [
                            ...defaultBodyContentTypes.text,
                            ...(contentTypes.text ?? []),
                        ];
                        console.log("contentType", contentType);
                        if (contentTypesRaw && isMediaType_ts_1.isMediaType(contentType, contentTypesRaw)) {
                            return (this.#body = { type: "raw", value: rawBody });
                        }
                        else if (isMediaType_ts_1.isMediaType(contentType, contentTypesJson)) {
                            return (this.#body = { type: "json", value: JSON.parse(value) });
                        }
                        else if (isMediaType_ts_1.isMediaType(contentType, contentTypesForm)) {
                            return (this.#body = {
                                type: "form",
                                value: new URLSearchParams(value.replace(/\+/g, " ")),
                            });
                        }
                        else if (isMediaType_ts_1.isMediaType(contentType, contentTypesText)) {
                            return (this.#body = { type: "text", value });
                        }
                        else {
                            return (this.#body = { type: "raw", value: rawBody });
                        }
                    }
                    throw new httpError_ts_4.httpErrors.UnsupportedMediaType(contentType
                        ? `Unsupported content-type: ${contentType}`
                        : "Missing content-type");
                }
            };
            exports_80("Request", Request);
        }
    };
});
// Copyright 2018-2020 the oak authors. All rights reserved. MIT license.
System.register("https://deno.land/x/oak/response", ["https://deno.land/x/oak/deps", "https://deno.land/x/oak/util"], function (exports_81, context_81) {
    "use strict";
    var deps_ts_9, util_ts_7, REDIRECT_BACK, BODY_TYPES, encoder, Response;
    var __moduleName = context_81 && context_81.id;
    /** Guard for `Deno.Reader`. */
    function isReader(value) {
        return value && typeof value === "object" && "read" in value &&
            typeof value.read === "function";
    }
    function isPromiseLike(value) {
        return value && typeof value === "object" && "then" in value &&
            typeof value.then === "function";
    }
    async function convertBody(body, type) {
        let result;
        if (BODY_TYPES.includes(typeof body)) {
            const bodyText = String(body);
            result = encoder.encode(bodyText);
            type = type ?? (util_ts_7.isHtml(bodyText) ? "html" : "text/plain");
        }
        else if (body instanceof Uint8Array || isReader(body)) {
            result = body;
        }
        else if (body && typeof body === "object") {
            result = encoder.encode(JSON.stringify(body));
            type = type ?? "json";
        }
        else if (typeof body === "function") {
            const result = body.call(null);
            return convertBody(isPromiseLike(result) ? await result : result, type);
        }
        else if (body) {
            throw new TypeError("Response body was set but could not convert.");
        }
        return [result, type];
    }
    return {
        setters: [
            function (deps_ts_9_1) {
                deps_ts_9 = deps_ts_9_1;
            },
            function (util_ts_7_1) {
                util_ts_7 = util_ts_7_1;
            }
        ],
        execute: function () {
            /** A symbol that indicates to `response.redirect()` to attempt to redirect
             * back to the request referrer.  For example:
             *
             * ```ts
             * import { Application, REDIRECT_BACK } from "https://deno.land/x/oak/mod.ts";
             *
             * const app = new Application();
             *
             * app.use((ctx) => {
             *   if (ctx.request.url.pathName === "/back") {
             *     ctx.response.redirect(REDIRECT_BACK, "/");
             *   }
             * });
             *
             * await app.listen({ port: 80 });
             * ```
             */
            exports_81("REDIRECT_BACK", REDIRECT_BACK = Symbol("redirect backwards"));
            BODY_TYPES = ["string", "number", "bigint", "boolean", "symbol"];
            encoder = new TextEncoder();
            /** An interface to control what response will be sent when the middleware
             * finishes processing the request. */
            Response = class Response {
                constructor(request) {
                    this.#headers = new Headers();
                    this.#resources = [];
                    this.#writable = true;
                    this.#getBody = async () => {
                        const [body, type] = await convertBody(this.body, this.type);
                        this.type = type;
                        return body;
                    };
                    this.#setContentType = () => {
                        if (this.type) {
                            const contentTypeString = deps_ts_9.contentType(this.type);
                            if (contentTypeString && !this.headers.has("Content-Type")) {
                                this.headers.append("Content-Type", contentTypeString);
                            }
                        }
                    };
                    this.#request = request;
                }
                #body;
                #headers;
                #request;
                #resources;
                #serverResponse;
                #status;
                #type;
                #writable;
                #getBody;
                #setContentType;
                /** The body of the response.  The body will be automatically processed when
                 * the response is being sent and converted to a `Uint8Array` or a
                 * `Deno.Reader`. */
                get body() {
                    return this.#body;
                }
                /** The body of the response.  The body will be automatically processed when
                 * the response is being sent and converted to a `Uint8Array` or a
                 * `Deno.Reader`. */
                set body(value) {
                    if (!this.#writable) {
                        throw new Error("The response is not writable.");
                    }
                    this.#body = value;
                }
                /** Headers that will be returned in the response. */
                get headers() {
                    return this.#headers;
                }
                /** Headers that will be returned in the response. */
                set headers(value) {
                    if (!this.#writable) {
                        throw new Error("The response is not writable.");
                    }
                    this.#headers = value;
                }
                /** The HTTP status of the response.  If this has not been explicitly set,
                 * reading the value will return what would be the value of status if the
                 * response were sent at this point in processing the middleware.  If the body
                 * has been set, the status will be `200 OK`.  If a value for the body has
                 * not been set yet, the status will be `404 Not Found`. */
                get status() {
                    if (this.#status) {
                        return this.#status;
                    }
                    const typeofbody = typeof this.body;
                    return this.body &&
                        (BODY_TYPES.includes(typeofbody) || typeofbody === "object")
                        ? deps_ts_9.Status.OK
                        : deps_ts_9.Status.NotFound;
                }
                /** The HTTP status of the response.  If this has not been explicitly set,
                 * reading the value will return what would be the value of status if the
                 * response were sent at this point in processing the middleware.  If the body
                 * has been set, the status will be `200 OK`.  If a value for the body has
                 * not been set yet, the status will be `404 Not Found`. */
                set status(value) {
                    if (!this.#writable) {
                        throw new Error("The response is not writable.");
                    }
                    this.#status = value;
                }
                /** The media type, or extension of the response.  Setting this value will
                 * ensure an appropriate `Content-Type` header is added to the response. */
                get type() {
                    return this.#type;
                }
                /** The media type, or extension of the response.  Setting this value will
                 * ensure an appropriate `Content-Type` header is added to the response. */
                set type(value) {
                    if (!this.#writable) {
                        throw new Error("The response is not writable.");
                    }
                    this.#type = value;
                }
                /** A read-only property which determines if the response is writable or not.
                 * Once the response has been processed, this value is set to `false`. */
                get writable() {
                    return this.#writable;
                }
                /** Add a resource to the list of resources that will be closed when the
                 * request is destroyed. */
                addResource(rid) {
                    this.#resources.push(rid);
                }
                /** Release any resources that are being tracked by the response. */
                destroy() {
                    this.#writable = false;
                    this.#body = undefined;
                    this.#serverResponse = undefined;
                    for (const rid of this.#resources) {
                        Deno.close(rid);
                    }
                }
                redirect(url, alt = "/") {
                    if (url === REDIRECT_BACK) {
                        url = this.#request.headers.get("Referrer") ?? String(alt);
                    }
                    else if (typeof url === "object") {
                        url = String(url);
                    }
                    this.headers.set("Location", util_ts_7.encodeUrl(url));
                    if (!this.status || !util_ts_7.isRedirectStatus(this.status)) {
                        this.status = deps_ts_9.Status.Found;
                    }
                    if (this.#request.accepts("html")) {
                        url = encodeURI(url);
                        this.type = "text/html; charset=utf-8";
                        this.body = `Redirecting to <a href="${url}">${url}</a>.`;
                        return;
                    }
                    this.type = "text/plain; charset=utf-8";
                    this.body = `Redirecting to ${url}.`;
                }
                /** Take this response and convert it to the response used by the Deno net
                 * server.  Calling this will set the response to not be writable.
                 *
                 * Most users will have no need to call this method. */
                async toServerResponse() {
                    if (this.#serverResponse) {
                        return this.#serverResponse;
                    }
                    // Process the body
                    const body = await this.#getBody();
                    // If there is a response type, set the content type header
                    this.#setContentType();
                    const { headers } = this;
                    // If there is no body and no content type and no set length, then set the
                    // content length to 0
                    if (!(body ||
                        headers.has("Content-Type") ||
                        headers.has("Content-Length"))) {
                        headers.append("Content-Length", "0");
                    }
                    this.#writable = false;
                    return this.#serverResponse = {
                        status: this.#status ?? (body ? deps_ts_9.Status.OK : deps_ts_9.Status.NotFound),
                        body,
                        headers,
                    };
                }
            };
            exports_81("Response", Response);
        }
    };
});
// Copyright 2018-2020 the oak authors. All rights reserved. MIT license.
System.register("https://deno.land/x/oak/cookies", [], function (exports_82, context_82) {
    "use strict";
    var matchCache, FIELD_CONTENT_REGEXP, KEY_REGEXP, SAME_SITE_REGEXP, Cookie, Cookies;
    var __moduleName = context_82 && context_82.id;
    function getPattern(name) {
        if (name in matchCache) {
            return matchCache[name];
        }
        return matchCache[name] = new RegExp(`(?:^|;) *${name.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&")}=([^;]*)`);
    }
    function pushCookie(headers, cookie) {
        if (cookie.overwrite) {
            for (let i = headers.length - 1; i >= 0; i--) {
                if (headers[i].indexOf(`${cookie.name}=`) === 0) {
                    headers.splice(i, 1);
                }
            }
        }
        headers.push(cookie.toHeader());
    }
    function validateCookieProperty(key, value) {
        if (value && !FIELD_CONTENT_REGEXP.test(value)) {
            throw new TypeError(`The ${key} of the cookie (${value}) is invalid.`);
        }
    }
    return {
        setters: [],
        execute: function () {
            matchCache = {};
            FIELD_CONTENT_REGEXP = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
            KEY_REGEXP = /(?:^|;) *([^=]*)=[^;]*/g;
            SAME_SITE_REGEXP = /^(?:lax|none|strict)$/i;
            Cookie = class Cookie {
                /** A logical representation of a cookie, used to internally manage the
                 * cookie instances. */
                constructor(name, value, attributes) {
                    this.httpOnly = true;
                    this.overwrite = false;
                    this.path = "/";
                    this.sameSite = false;
                    this.secure = false;
                    validateCookieProperty("name", name);
                    validateCookieProperty("value", value);
                    this.name = name;
                    this.value = value ?? "";
                    Object.assign(this, attributes);
                    if (!this.value) {
                        this.expires = new Date(0);
                        this.maxAge = undefined;
                    }
                    validateCookieProperty("path", this.path);
                    validateCookieProperty("domain", this.domain);
                    if (this.sameSite && typeof this.sameSite === "string" &&
                        !SAME_SITE_REGEXP.test(this.sameSite)) {
                        throw new TypeError(`The sameSite of the cookie ("${this.sameSite}") is invalid.`);
                    }
                }
                toHeader() {
                    let header = this.toString();
                    if (this.maxAge) {
                        this.expires = new Date(Date.now() + this.maxAge);
                    }
                    if (this.path) {
                        header += `; path=${this.path}`;
                    }
                    if (this.expires) {
                        header += `; expires=${this.expires.toUTCString()}`;
                    }
                    if (this.domain) {
                        header += `; domain=${this.domain}`;
                    }
                    if (this.sameSite) {
                        header += `; samesite=${this.sameSite === true ? "strict" : this.sameSite.toLowerCase()}`;
                    }
                    if (this.secure) {
                        header += "; secure";
                    }
                    if (this.httpOnly) {
                        header += "; httponly";
                    }
                    return header;
                }
                toString() {
                    return `${this.name}=${this.value}`;
                }
            };
            /** An interface which allows setting and accessing cookies related to both the
             * current request and response. */
            Cookies = class Cookies {
                constructor(request, response, options = {}) {
                    this.#requestKeys = () => {
                        if (this.#cookieKeys) {
                            return this.#cookieKeys;
                        }
                        const result = this.#cookieKeys = [];
                        const header = this.#request.headers.get("cookie");
                        if (!header) {
                            return result;
                        }
                        let matches;
                        while ((matches = KEY_REGEXP.exec(header))) {
                            const [, key] = matches;
                            result.push(key);
                        }
                        return result;
                    };
                    const { keys, secure } = options;
                    this.#keys = keys;
                    this.#request = request;
                    this.#response = response;
                    this.#secure = secure;
                }
                #cookieKeys;
                #keys;
                #request;
                #response;
                #secure;
                #requestKeys;
                /** Set a cookie to be deleted in the response.  This is a "shortcut" to
                 * `.set(name, null, options?)`. */
                delete(name, options = {}) {
                    this.set(name, null, options);
                    return true;
                }
                /** Iterate over the request's cookies, yielding up a tuple containing the
                 * key and the value.
                 *
                 * If there are keys set on the application, only keys and values that are
                 * properly signed will be returned. */
                *entries() {
                    const keys = this.#requestKeys();
                    for (const key of keys) {
                        const value = this.get(key);
                        if (value) {
                            yield [key, value];
                        }
                    }
                }
                forEach(callback, thisArg = null) {
                    const keys = this.#requestKeys();
                    for (const key of keys) {
                        const value = this.get(key);
                        if (value) {
                            callback.call(thisArg, key, value, this);
                        }
                    }
                }
                /** Get the value of a cookie from the request.
                 *
                 * If the cookie is signed, and the signature is invalid, the cookie will
                 * be set to be deleted in the the response.  If the signature uses an "old"
                 * key, the cookie will be re-signed with the current key and be added to the
                 * response to be updated. */
                get(name, options = {}) {
                    const signed = options.signed ?? !!this.#keys;
                    const nameSig = `${name}.sig`;
                    const header = this.#request.headers.get("cookie");
                    if (!header) {
                        return;
                    }
                    const match = header.match(getPattern(name));
                    if (!match) {
                        return;
                    }
                    const [, value] = match;
                    if (!signed) {
                        return value;
                    }
                    const digest = this.get(nameSig, { signed: false });
                    if (!digest) {
                        return;
                    }
                    const data = `${name}=${value}`;
                    if (!this.#keys) {
                        throw new TypeError("keys required for signed cookies");
                    }
                    const index = this.#keys.indexOf(data, digest);
                    if (index < 0) {
                        this.delete(nameSig, { path: "/", signed: false });
                    }
                    else {
                        if (index) {
                            // the key has "aged" and needs to be re-signed
                            this.set(nameSig, this.#keys.sign(data), { signed: false });
                        }
                        return value;
                    }
                }
                /** Iterate over the request's cookies, yielding up the keys.
                 *
                 * If there are keys set on the application, only the keys that are properly
                 * signed will be returned. */
                *keys() {
                    const keys = this.#requestKeys();
                    for (const key of keys) {
                        const value = this.get(key);
                        if (value) {
                            yield key;
                        }
                    }
                }
                /** Set a cookie in the response.
                 *
                 * If there are keys set in the application, cookies will be automatically
                 * signed, unless overridden by the set options.  Cookies can be deleted by
                 * setting the value to `null`. */
                set(name, value, options = {}) {
                    const request = this.#request;
                    const response = this.#response;
                    let headers = response.headers.get("Set-Cookie") ?? [];
                    if (typeof headers === "string") {
                        headers = [headers];
                    }
                    const secure = this.#secure !== undefined ? this.#secure : request.secure;
                    const signed = options.signed ?? !!this.#keys;
                    if (!secure && options.secure) {
                        throw new TypeError("Cannot send secure cookie over unencrypted connection.");
                    }
                    const cookie = new Cookie(name, value, options);
                    cookie.secure = options.secure ?? secure;
                    pushCookie(headers, cookie);
                    if (signed) {
                        if (!this.#keys) {
                            throw new TypeError(".keys required for signed cookies.");
                        }
                        cookie.value = this.#keys.sign(cookie.toString());
                        cookie.name += ".sig";
                        pushCookie(headers, cookie);
                    }
                    for (const header of headers) {
                        response.headers.append("Set-Cookie", header);
                    }
                    return this;
                }
                /** Iterate over the request's cookies, yielding up each value.
                 *
                 * If there are keys set on the application, only the values that are
                 * properly signed will be returned. */
                *values() {
                    const keys = this.#requestKeys();
                    for (const key of keys) {
                        const value = this.get(key);
                        if (value) {
                            yield value;
                        }
                    }
                }
                /** Iterate over the request's cookies, yielding up a tuple containing the
                 * key and the value.
                 *
                 * If there are keys set on the application, only keys and values that are
                 * properly signed will be returned. */
                *[Symbol.iterator]() {
                    const keys = this.#requestKeys();
                    for (const key of keys) {
                        const value = this.get(key);
                        if (value) {
                            yield [key, value];
                        }
                    }
                }
            };
            exports_82("Cookies", Cookies);
        }
    };
});
/*!
 * Adapted from koa-send at https://github.com/koajs/send and which is licensed
 * with the MIT license.
 */
System.register("https://deno.land/x/oak/send", ["https://deno.land/x/oak/httpError", "https://deno.land/x/oak/deps", "https://deno.land/x/oak/util"], function (exports_83, context_83) {
    "use strict";
    var httpError_ts_5, deps_ts_10, util_ts_8;
    var __moduleName = context_83 && context_83.id;
    function isHidden(root, path) {
        const pathArr = path.substr(root.length).split(deps_ts_10.sep);
        for (const segment of pathArr) {
            if (segment[0] === ".") {
                return true;
            }
            return false;
        }
    }
    async function exists(path) {
        try {
            return (await Deno.stat(path)).isFile;
        }
        catch {
            return false;
        }
    }
    /** Asynchronously fulfill a response with a file from the local file
     * system.
     *
     * Requires Deno read permission. */
    async function send({ request, response }, path, options = { root: "" }) {
        const { brotli = true, extensions, format = true, gzip = true, hidden = false, immutable = false, index, maxage = 0, root, } = options;
        const trailingSlash = path[path.length - 1] === "/";
        path = util_ts_8.decodeComponent(path.substr(deps_ts_10.parse(path).root.length));
        if (index && trailingSlash) {
            path += index;
        }
        path = util_ts_8.resolvePath(root, path);
        if (!hidden && isHidden(root, path)) {
            return;
        }
        let encodingExt = "";
        if (brotli &&
            request.acceptsEncodings("br", "identity") === "br" &&
            (await exists(`${path}.br`))) {
            path = `${path}.br`;
            response.headers.set("Content-Encoding", "br");
            response.headers.delete("Content-Length");
            encodingExt = ".br";
        }
        else if (gzip &&
            request.acceptsEncodings("gzip", "identity") === "gzip" &&
            (await exists(`${path}.gz`))) {
            path = `${path}.gz`;
            response.headers.set("Content-Encoding", "gzip");
            response.headers.delete("Content-Length");
            encodingExt = ".gz";
        }
        if (extensions && !/\.[^/]*$/.exec(path)) {
            for (let ext of extensions) {
                if (!/^\./.exec(ext)) {
                    ext = `.${ext}`;
                }
                if (await exists(`${path}${ext}`)) {
                    path += ext;
                    break;
                }
            }
        }
        let stats;
        try {
            stats = await Deno.stat(path);
            if (stats.isDirectory) {
                if (format && index) {
                    path += `/${index}`;
                    stats = await Deno.stat(path);
                }
                else {
                    return;
                }
            }
        }
        catch (err) {
            if (err instanceof Deno.errors.NotFound) {
                throw httpError_ts_5.createHttpError(404, err.message);
            }
            throw httpError_ts_5.createHttpError(500, err.message);
        }
        response.headers.set("Content-Length", String(stats.size));
        if (!response.headers.has("Last-Modified") && stats.mtime) {
            response.headers.set("Last-Modified", stats.mtime.toUTCString());
        }
        if (!response.headers.has("Cache-Control")) {
            const directives = [`max-age=${(maxage / 1000) | 0}`];
            if (immutable) {
                directives.push("immutable");
            }
            response.headers.set("Cache-Control", directives.join(","));
        }
        if (!response.type) {
            response.type = encodingExt !== ""
                ? deps_ts_10.extname(deps_ts_10.basename(path, encodingExt))
                : deps_ts_10.extname(path);
        }
        const file = await Deno.open(path, { read: true });
        response.addResource(file.rid);
        response.body = file;
        return path;
    }
    exports_83("send", send);
    return {
        setters: [
            function (httpError_ts_5_1) {
                httpError_ts_5 = httpError_ts_5_1;
            },
            function (deps_ts_10_1) {
                deps_ts_10 = deps_ts_10_1;
            },
            function (util_ts_8_1) {
                util_ts_8 = util_ts_8_1;
            }
        ],
        execute: function () {
        }
    };
});
// Copyright 2018-2020 the oak authors. All rights reserved. MIT license.
System.register("https://deno.land/x/oak/server_sent_event", ["https://deno.land/x/oak/deps"], function (exports_84, context_84) {
    "use strict";
    var deps_ts_11, encoder, CloseEvent, ServerSentEvent, response, responseHeaders, ServerSentEventTarget;
    var __moduleName = context_84 && context_84.id;
    return {
        setters: [
            function (deps_ts_11_1) {
                deps_ts_11 = deps_ts_11_1;
            }
        ],
        execute: function () {
            encoder = new TextEncoder();
            CloseEvent = class CloseEvent extends Event {
                constructor(eventInit) {
                    super("close", eventInit);
                }
            };
            /** An event which contains information which will be sent to the remote
             * connection and be made available in an `EventSource` as an event. */
            ServerSentEvent = class ServerSentEvent extends Event {
                constructor(type, data, { replacer, space, ...eventInit } = {}) {
                    super(type, eventInit);
                    this.#type = type;
                    try {
                        this.#data = typeof data === "string"
                            ? data
                            : JSON.stringify(data, replacer, space);
                    }
                    catch (e) {
                        deps_ts_11.assert(e instanceof Error);
                        throw new TypeError(`data could not be coerced into a serialized string.\n  ${e.message}`);
                    }
                    const { id } = eventInit;
                    this.#id = id;
                }
                #data;
                #id;
                #type;
                /** The data associated with the event, which will be sent to the client and
                 * be made available in the `EventSource`. */
                get data() {
                    return this.#data;
                }
                /** The optional ID associated with the event that will be sent to the client
                 * and be made available in the `EventSource`. */
                get id() {
                    return this.#id;
                }
                toString() {
                    const data = `data: ${this.#data.split("\n").join("\ndata: ")}\n`;
                    return `${this.#type === "__message" ? "" : `event: ${this.#type}\n`}${this.#id ? `id: ${String(this.#id)}\n` : ""}${data}\n`;
                }
            };
            exports_84("ServerSentEvent", ServerSentEvent);
            response = `HTTP/1.1 200 OK\n`;
            responseHeaders = new Headers([
                ["Connection", "Keep-Alive"],
                ["Content-Type", "text/event-stream"],
                ["Cache-Control", "no-cache"],
                ["Keep-Alive", `timeout=${Number.MAX_SAFE_INTEGER}`],
            ]);
            ServerSentEventTarget = class ServerSentEventTarget extends EventTarget {
                constructor(app, serverRequest, { headers } = {}) {
                    super();
                    this.#closed = false;
                    this.#send = async (payload) => {
                        if (this.#closed) {
                            return;
                        }
                        if (this.#ready !== true) {
                            await this.#ready;
                            this.#ready = true;
                        }
                        try {
                            await (this.#writing = this.#writer.write(encoder.encode(payload)));
                            await (this.#writing = this.#writer.flush());
                        }
                        catch (error) {
                            this.#writing = undefined;
                            this.dispatchEvent(new CloseEvent({ cancelable: false }));
                            const errorEvent = new ErrorEvent("error", { error });
                            this.dispatchEvent(errorEvent);
                            this.#app.dispatchEvent(errorEvent);
                        }
                    };
                    this.#setup = async (overrideHeaders) => {
                        const headers = new Headers(responseHeaders);
                        if (overrideHeaders) {
                            for (const [key, value] of overrideHeaders) {
                                headers.set(key, value);
                            }
                        }
                        let payload = response;
                        for (const [key, value] of headers) {
                            payload += `${key}: ${value}\n`;
                        }
                        payload += `\n`;
                        try {
                            await this.#writer.write(encoder.encode(payload));
                            await this.#writer.flush();
                        }
                        catch (error) {
                            this.dispatchEvent(new CloseEvent({ cancelable: false }));
                            const errorEvent = new ErrorEvent("error", { error });
                            this.dispatchEvent(errorEvent);
                            this.#app.dispatchEvent(errorEvent);
                            throw error;
                        }
                    };
                    this.#app = app;
                    this.#serverRequest = serverRequest;
                    this.#writer = this.#serverRequest.w;
                    this.addEventListener("close", () => {
                        this.#closed = true;
                        try {
                            this.#serverRequest.conn.close();
                        }
                        catch (error) {
                            if (!(error instanceof Deno.errors.BadResource)) {
                                const errorEvent = new ErrorEvent("error", { error });
                                this.dispatchEvent(errorEvent);
                                this.#app.dispatchEvent(errorEvent);
                            }
                        }
                    });
                    this.#ready = this.#setup(headers);
                }
                #app;
                #closed;
                #ready;
                #serverRequest;
                #writer;
                #writing;
                #send;
                #setup;
                /** Is set to `true` if events cannot be sent to the remote connection.
                 * Otherwise it is set to `false`.
                 *
                 * *Note*: This flag is lazily set, and might not reflect a closed state until
                 * another event, comment or message is attempted to be processed. */
                get closed() {
                    return this.#closed;
                }
                /** Stop sending events to the remote connection and close the connection. */
                async close() {
                    if (this.#ready !== true) {
                        await this.#ready;
                    }
                    if (this.#writing) {
                        await this.#writing;
                    }
                    this.dispatchEvent(new CloseEvent({ cancelable: false }));
                }
                /** Send a comment to the remote connection.  Comments are not exposed to the
                 * client `EventSource` but are used for diagnostics and helping ensure a
                 * connection is kept alive.
                 *
                 * ```ts
                 * import { Application } from "https://deno.land/x/oak/mod.ts";
                 *
                 * const app = new Application();
                 *
                 * app.use((ctx) => {
                 *    const sse = ctx.getSSETarget();
                 *    sse.dispatchComment("this is a comment");
                 * });
                 *
                 * await app.listen();
                 * ```
                 */
                dispatchComment(comment) {
                    this.#send(`: ${comment.split("\n").join("\n: ")}\n\n`);
                    return true;
                }
                /** Dispatch a message to the client.  This message will contain `data: ` only
                 * and be available on the client `EventSource` on the `onmessage` or an event
                 * listener of type `"message"`. */
                dispatchMessage(data) {
                    const event = new ServerSentEvent("__message", data);
                    return this.dispatchEvent(event);
                }
                dispatchEvent(event) {
                    let dispatched = super.dispatchEvent(event);
                    if (dispatched) {
                        this.#send(String(event));
                    }
                    return dispatched;
                }
            };
            exports_84("ServerSentEventTarget", ServerSentEventTarget);
        }
    };
});
// Copyright 2018-2020 the oak authors. All rights reserved. MIT license.
System.register("https://deno.land/x/oak/context", ["https://deno.land/x/oak/cookies", "https://deno.land/x/oak/deps", "https://deno.land/x/oak/httpError", "https://deno.land/x/oak/request", "https://deno.land/x/oak/response", "https://deno.land/x/oak/send", "https://deno.land/x/oak/server_sent_event"], function (exports_85, context_85) {
    "use strict";
    var cookies_ts_1, deps_ts_12, httpError_ts_6, request_ts_1, response_ts_1, send_ts_1, server_sent_event_ts_1, Context;
    var __moduleName = context_85 && context_85.id;
    return {
        setters: [
            function (cookies_ts_1_1) {
                cookies_ts_1 = cookies_ts_1_1;
            },
            function (deps_ts_12_1) {
                deps_ts_12 = deps_ts_12_1;
            },
            function (httpError_ts_6_1) {
                httpError_ts_6 = httpError_ts_6_1;
            },
            function (request_ts_1_1) {
                request_ts_1 = request_ts_1_1;
            },
            function (response_ts_1_1) {
                response_ts_1 = response_ts_1_1;
            },
            function (send_ts_1_1) {
                send_ts_1 = send_ts_1_1;
            },
            function (server_sent_event_ts_1_1) {
                server_sent_event_ts_1 = server_sent_event_ts_1_1;
            }
        ],
        execute: function () {
            /** Provides context about the current request and response to middleware
             * functions. */
            Context = class Context {
                constructor(app, serverRequest, secure = false) {
                    this.app = app;
                    this.state = app.state;
                    this.request = new request_ts_1.Request(serverRequest, app.proxy, secure);
                    this.respond = true;
                    this.response = new response_ts_1.Response(this.request);
                    this.cookies = new cookies_ts_1.Cookies(this.request, this.response, {
                        keys: this.app.keys,
                        secure: this.request.secure,
                    });
                }
                #socket;
                #sse;
                /** Is `true` if the current connection is upgradeable to a web socket.
                 * Otherwise the value is `false`.  Use `.upgrade()` to upgrade the connection
                 * and return the web socket. */
                get isUpgradable() {
                    return deps_ts_12.acceptable(this.request);
                }
                /** If the the current context has been upgraded, then this will be set to
                 * with the web socket, otherwise it is `undefined`. */
                get socket() {
                    return this.#socket;
                }
                /** Asserts the condition and if the condition fails, creates an HTTP error
                 * with the provided status (which defaults to `500`).  The error status by
                 * default will be set on the `.response.status`.
                 */
                assert(condition, errorStatus = 500, message, props) {
                    if (condition) {
                        return;
                    }
                    const err = httpError_ts_6.createHttpError(errorStatus, message);
                    if (props) {
                        Object.assign(err, props);
                    }
                    throw err;
                }
                /** Asynchronously fulfill a response with a file from the local file
                 * system.
                 *
                 * If the `options.path` is not supplied, the file to be sent will default
                 * to this `.request.url.pathname`.
                 *
                 * Requires Deno read permission. */
                send(options) {
                    const { path = this.request.url.pathname, ...sendOptions } = options;
                    return send_ts_1.send(this, path, sendOptions);
                }
                /** Convert the connection to stream events, returning an event target for
                 * sending server sent events.  Events dispatched on the returned target will
                 * be sent to the client and be available in the client's `EventSource` that
                 * initiated the connection.
                 *
                 * This will set `.respond` to `false`. */
                sendEvents(options) {
                    if (this.#sse) {
                        return this.#sse;
                    }
                    this.respond = false;
                    return this.#sse = new server_sent_event_ts_1.ServerSentEventTarget(this.app, this.request.serverRequest, options);
                }
                /** Create and throw an HTTP Error, which can be used to pass status
                 * information which can be caught by other middleware to send more
                 * meaningful error messages back to the client.  The passed error status will
                 * be set on the `.response.status` by default as well.
                 */
                throw(errorStatus, message, props) {
                    const err = httpError_ts_6.createHttpError(errorStatus, message);
                    if (props) {
                        Object.assign(err, props);
                    }
                    throw err;
                }
                /** Take the current request and upgrade it to a web socket, resolving with
                 * the web socket object. This will set `.respond` to `false`. */
                async upgrade() {
                    if (this.#socket) {
                        return this.#socket;
                    }
                    const { conn, r: bufReader, w: bufWriter, headers } = this.request.serverRequest;
                    this.#socket = await deps_ts_12.acceptWebSocket({ conn, bufReader, bufWriter, headers });
                    this.respond = false;
                    return this.#socket;
                }
            };
            exports_85("Context", Context);
        }
    };
});
// Copyright 2018-2020 the oak authors. All rights reserved. MIT license.
System.register("https://deno.land/x/oak/middleware", [], function (exports_86, context_86) {
    "use strict";
    var __moduleName = context_86 && context_86.id;
    /** Compose multiple middleware functions into a single middleware function. */
    function compose(middleware) {
        return function composedMiddleware(context, next) {
            let index = -1;
            function dispatch(i) {
                if (i <= index) {
                    Promise.reject(new Error("next() called multiple times."));
                }
                index = i;
                let fn = middleware[i];
                if (i === middleware.length) {
                    fn = next;
                }
                if (!fn) {
                    return Promise.resolve();
                }
                try {
                    return Promise.resolve(fn(context, dispatch.bind(null, i + 1)));
                }
                catch (err) {
                    return Promise.reject(err);
                }
            }
            return dispatch(0);
        };
    }
    exports_86("compose", compose);
    return {
        setters: [],
        execute: function () {
        }
    };
});
// Copyright 2018-2020 the oak authors. All rights reserved. MIT license.
System.register("https://deno.land/x/oak/application", ["https://deno.land/x/oak/context", "https://deno.land/x/oak/deps", "https://deno.land/x/oak/keyStack", "https://deno.land/x/oak/middleware"], function (exports_87, context_87) {
    "use strict";
    var context_ts_1, deps_ts_13, keyStack_ts_1, middleware_ts_1, ADDR_REGEXP, ApplicationErrorEvent, ApplicationListenEvent, Application;
    var __moduleName = context_87 && context_87.id;
    function isOptionsTls(options) {
        return options.secure === true;
    }
    return {
        setters: [
            function (context_ts_1_1) {
                context_ts_1 = context_ts_1_1;
            },
            function (deps_ts_13_1) {
                deps_ts_13 = deps_ts_13_1;
            },
            function (keyStack_ts_1_1) {
                keyStack_ts_1 = keyStack_ts_1_1;
            },
            function (middleware_ts_1_1) {
                middleware_ts_1 = middleware_ts_1_1;
            }
        ],
        execute: function () {
            ADDR_REGEXP = /^\[?([^\]]*)\]?:([0-9]{1,5})$/;
            ApplicationErrorEvent = class ApplicationErrorEvent extends ErrorEvent {
                constructor(eventInitDict) {
                    super("error", eventInitDict);
                    this.context = eventInitDict.context;
                }
            };
            exports_87("ApplicationErrorEvent", ApplicationErrorEvent);
            ApplicationListenEvent = class ApplicationListenEvent extends Event {
                constructor(eventInitDict) {
                    super("listen", eventInitDict);
                    this.hostname = eventInitDict.hostname;
                    this.port = eventInitDict.port;
                    this.secure = eventInitDict.secure;
                }
            };
            exports_87("ApplicationListenEvent", ApplicationListenEvent);
            /** A class which registers middleware (via `.use()`) and then processes
             * inbound requests against that middleware (via `.listen()`).
             *
             * The `context.state` can be typed via passing a generic argument when
             * constructing an instance of `Application`.
             */
            Application = class Application extends EventTarget {
                constructor(options = {}) {
                    super();
                    this.#middleware = [];
                    /** Deal with uncaught errors in either the middleware or sending the
                     * response. */
                    this.#handleError = (context, error) => {
                        if (!(error instanceof Error)) {
                            error = new Error(`non-error thrown: ${JSON.stringify(error)}`);
                        }
                        const { message } = error;
                        this.dispatchEvent(new ApplicationErrorEvent({ context, message, error }));
                        if (!context.response.writable) {
                            return;
                        }
                        for (const key of context.response.headers.keys()) {
                            context.response.headers.delete(key);
                        }
                        if (error.headers && error.headers instanceof Headers) {
                            for (const [key, value] of error.headers) {
                                context.response.headers.set(key, value);
                            }
                        }
                        context.response.type = "text";
                        const status = context.response.status =
                            error instanceof Deno.errors.NotFound
                                ? 404
                                : error.status && typeof error.status === "number"
                                    ? error.status
                                    : 500;
                        context.response.body = error.expose
                            ? error.message
                            : deps_ts_13.STATUS_TEXT.get(status);
                    };
                    /** Processing registered middleware on each request. */
                    this.#handleRequest = async (request, secure, state) => {
                        const context = new context_ts_1.Context(this, request, secure);
                        if (!state.closing && !state.closed) {
                            state.handling = true;
                            try {
                                await state.middleware(context);
                            }
                            catch (err) {
                                this.#handleError(context, err);
                            }
                            finally {
                                state.handling = false;
                            }
                        }
                        if (context.respond === false) {
                            context.response.destroy();
                            return;
                        }
                        try {
                            await request.respond(await context.response.toServerResponse());
                            context.response.destroy();
                            if (state.closing) {
                                state.server.close();
                                state.closed = true;
                            }
                        }
                        catch (err) {
                            this.#handleError(context, err);
                        }
                    };
                    const { state, keys, proxy, serve = deps_ts_13.serve, serveTls = deps_ts_13.serveTLS, } = options;
                    this.proxy = proxy ?? false;
                    this.keys = keys;
                    this.state = state ?? {};
                    this.#serve = serve;
                    this.#serveTls = serveTls;
                }
                #keys;
                #middleware;
                #serve;
                #serveTls;
                /** A set of keys, or an instance of `KeyStack` which will be used to sign
                 * cookies read and set by the application to avoid tampering with the
                 * cookies. */
                get keys() {
                    return this.#keys;
                }
                set keys(keys) {
                    if (!keys) {
                        this.#keys = undefined;
                        return;
                    }
                    else if (Array.isArray(keys)) {
                        this.#keys = new keyStack_ts_1.KeyStack(keys);
                    }
                    else {
                        this.#keys = keys;
                    }
                }
                /** Deal with uncaught errors in either the middleware or sending the
                 * response. */
                #handleError;
                /** Processing registered middleware on each request. */
                #handleRequest;
                /** Add an event listener for an event.  Currently valid event types are
                 * `"error"` and `"listen"`. */
                addEventListener(type, listener, options) {
                    super.addEventListener(type, listener, options);
                }
                async listen(options) {
                    if (!this.#middleware.length) {
                        return Promise.reject(new TypeError("There is no middleware to process requests."));
                    }
                    if (typeof options === "string") {
                        const match = ADDR_REGEXP.exec(options);
                        if (!match) {
                            throw TypeError(`Invalid address passed: "${options}"`);
                        }
                        const [, hostname, portStr] = match;
                        options = { hostname, port: parseInt(portStr, 10) };
                    }
                    const middleware = middleware_ts_1.compose(this.#middleware);
                    const server = isOptionsTls(options)
                        ? this.#serveTls(options)
                        : this.#serve(options);
                    const { signal } = options;
                    const state = {
                        closed: false,
                        closing: false,
                        handling: false,
                        middleware,
                        server,
                    };
                    if (signal) {
                        signal.addEventListener("abort", () => {
                            if (!state.handling) {
                                server.close();
                                state.closed = true;
                            }
                            state.closing = true;
                        });
                    }
                    const { hostname, port, secure = false } = options;
                    this.dispatchEvent(new ApplicationListenEvent({ hostname, port, secure }));
                    try {
                        for await (const request of server) {
                            this.#handleRequest(request, secure, state);
                        }
                    }
                    catch (error) {
                        const message = error instanceof Error
                            ? error.message
                            : "Application Error";
                        this.dispatchEvent(new ApplicationErrorEvent({ message, error }));
                    }
                }
                /** Register middleware to be used with the application.  Middleware will
                 * be processed in the order it is added, but middleware can control the flow
                 * of execution via the use of the `next()` function that the middleware
                 * function will be called with.  The `context` object provides information
                 * about the current state of the application.
                 *
                 * Basic usage:
                 *
                 * ```ts
                 * const import { Application } from "https://deno.land/x/oak/mod.ts";
                 *
                 * const app = new Application();
                 *
                 * app.use((ctx, next) => {
                 *   ctx.request; // contains request information
                 *   ctx.response; // setups up information to use in the response;
                 *   await next(); // manages the flow control of the middleware execution
                 * });
                 *
                 * await app.listen({ port: 80 });
                 * ```
                 */
                use(...middleware) {
                    this.#middleware.push(...middleware);
                    return this;
                }
            };
            exports_87("Application", Application);
        }
    };
});
/**
 * Adapted directly from @koa/router at
 * https://github.com/koajs/router/ which is licensed as:
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Alexander C. Mingoia
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
System.register("https://deno.land/x/oak/router", ["https://deno.land/x/oak/deps", "https://deno.land/x/oak/httpError", "https://deno.land/x/oak/middleware", "https://deno.land/x/oak/util"], function (exports_88, context_88) {
    "use strict";
    var deps_ts_14, httpError_ts_7, middleware_ts_2, util_ts_9, Layer, Router;
    var __moduleName = context_88 && context_88.id;
    /** Generate a URL from a string, potentially replace route params with
     * values. */
    function toUrl(url, params = {}, options) {
        const tokens = deps_ts_14.pathParse(url);
        let replace = {};
        if (tokens.some((token) => typeof token === "object")) {
            replace = params;
        }
        else {
            options = params;
        }
        const toPath = deps_ts_14.compile(url, options);
        let replaced = toPath(replace);
        if (options && options.query) {
            const url = new URL(replaced, "http://oak");
            if (typeof options.query === "string") {
                url.search = options.query;
            }
            else {
                url.search = String(options.query instanceof URLSearchParams
                    ? options.query
                    : new URLSearchParams(options.query));
            }
            return `${url.pathname}${url.search}${url.hash}`;
        }
        return replaced;
    }
    return {
        setters: [
            function (deps_ts_14_1) {
                deps_ts_14 = deps_ts_14_1;
            },
            function (httpError_ts_7_1) {
                httpError_ts_7 = httpError_ts_7_1;
            },
            function (middleware_ts_2_1) {
                middleware_ts_2 = middleware_ts_2_1;
            },
            function (util_ts_9_1) {
                util_ts_9 = util_ts_9_1;
            }
        ],
        execute: function () {
            Layer = class Layer {
                constructor(path, methods, middleware, { name, ...opts } = {}) {
                    this.#paramNames = [];
                    this.#opts = opts;
                    this.name = name;
                    this.methods = [...methods];
                    if (this.methods.includes("GET")) {
                        this.methods.unshift("HEAD");
                    }
                    this.stack = Array.isArray(middleware) ? middleware : [middleware];
                    this.path = path;
                    this.#regexp = deps_ts_14.pathToRegexp(path, this.#paramNames, this.#opts);
                }
                #opts;
                #paramNames;
                #regexp;
                match(path) {
                    return this.#regexp.test(path);
                }
                params(captures, existingParams = {}) {
                    const params = existingParams;
                    for (let i = 0; i < captures.length; i++) {
                        if (this.#paramNames[i]) {
                            const c = captures[i];
                            params[this.#paramNames[i].name] = c ? util_ts_9.decodeComponent(c) : c;
                        }
                    }
                    return params;
                }
                captures(path) {
                    if (this.#opts.ignoreCaptures) {
                        return [];
                    }
                    return path.match(this.#regexp)?.slice(1) ?? [];
                }
                url(params = {}, options) {
                    const url = this.path.replace(/\(\.\*\)/g, "");
                    return toUrl(url, params, options);
                }
                param(param, fn) {
                    const stack = this.stack;
                    const params = this.#paramNames;
                    const middleware = function (ctx, next) {
                        const p = ctx.params[param];
                        deps_ts_14.assert(p);
                        return fn.call(this, p, ctx, next);
                    };
                    middleware.param = param;
                    const names = params.map((p) => p.name);
                    const x = names.indexOf(param);
                    if (x >= 0) {
                        for (let i = 0; i < stack.length; i++) {
                            const fn = stack[i];
                            if (!fn.param || names.indexOf(fn.param) > x) {
                                stack.splice(i, 0, middleware);
                                break;
                            }
                        }
                    }
                    return this;
                }
                setPrefix(prefix) {
                    if (this.path) {
                        this.path = this.path !== "/" || this.#opts.strict === true
                            ? `${prefix}${this.path}`
                            : prefix;
                        this.#paramNames = [];
                        this.#regexp = deps_ts_14.pathToRegexp(this.path, this.#paramNames, this.#opts);
                    }
                    return this;
                }
                toJSON() {
                    return {
                        methods: [...this.methods],
                        middleware: [...this.stack],
                        paramNames: this.#paramNames.map((key) => key.name),
                        path: this.path,
                        regexp: this.#regexp,
                        options: { ...this.#opts },
                    };
                }
            };
            /** An interface for registering middleware that will run when certain HTTP
             * methods and paths are requested, as well as provides a way to parameterize
             * parts of the requested path. */
            Router = class Router {
                constructor(opts = {}) {
                    this.#params = {};
                    this.#stack = [];
                    this.#match = (path, method) => {
                        const matches = {
                            path: [],
                            pathAndMethod: [],
                            route: false,
                        };
                        for (const route of this.#stack) {
                            if (route.match(path)) {
                                matches.path.push(route);
                                if (route.methods.length === 0 || route.methods.includes(method)) {
                                    matches.pathAndMethod.push(route);
                                    if (route.methods.length) {
                                        matches.route = true;
                                    }
                                }
                            }
                        }
                        return matches;
                    };
                    this.#register = (path, middleware, methods, options = {}) => {
                        if (Array.isArray(path)) {
                            for (const p of path) {
                                this.#register(p, middleware, methods, options);
                            }
                            return;
                        }
                        const { end, name, sensitive, strict, ignoreCaptures } = options;
                        const route = new Layer(path, methods, middleware, {
                            end: end === false ? end : true,
                            name,
                            sensitive: sensitive ?? this.#opts.sensitive ?? false,
                            strict: strict ?? this.#opts.strict ?? false,
                            ignoreCaptures,
                        });
                        if (this.#opts.prefix) {
                            route.setPrefix(this.#opts.prefix);
                        }
                        for (const [param, mw] of Object.entries(this.#params)) {
                            route.param(param, mw);
                        }
                        this.#stack.push(route);
                    };
                    this.#route = (name) => {
                        for (const route of this.#stack) {
                            if (route.name === name) {
                                return route;
                            }
                        }
                    };
                    this.#useVerb = (nameOrPath, pathOrMiddleware, middleware, methods) => {
                        let name = undefined;
                        let path;
                        if (typeof pathOrMiddleware === "string") {
                            name = nameOrPath;
                            path = pathOrMiddleware;
                        }
                        else {
                            path = nameOrPath;
                            middleware.unshift(pathOrMiddleware);
                        }
                        this.#register(path, middleware, methods, { name });
                    };
                    this.#opts = opts;
                    this.#methods = opts.methods ?? [
                        "DELETE",
                        "GET",
                        "HEAD",
                        "OPTIONS",
                        "PATCH",
                        "POST",
                        "PUT",
                    ];
                }
                #opts;
                #methods;
                #params;
                #stack;
                #match;
                #register;
                #route;
                #useVerb;
                all(nameOrPath, pathOrMiddleware, ...middleware) {
                    this.#useVerb(nameOrPath, pathOrMiddleware, middleware, ["DELETE", "GET", "POST", "PUT"]);
                    return this;
                }
                /** Middleware that handles requests for HTTP methods registered with the
                 * router.  If none of the routes handle a method, then "not allowed" logic
                 * will be used.  If a method is supported by some routes, but not the
                 * particular matched router, then "not implemented" will be returned.
                 *
                 * The middleware will also automatically handle the `OPTIONS` method,
                 * responding with a `200 OK` when the `Allowed` header sent to the allowed
                 * methods for a given route.
                 *
                 * By default, a "not allowed" request will respond with a `405 Not Allowed`
                 * and a "not implemented" will respond with a `501 Not Implemented`. Setting
                 * the option `.throw` to `true` will cause the middleware to throw an
                 * `HTTPError` instead of setting the response status.  The error can be
                 * overridden by providing a `.notImplemented` or `.notAllowed` method in the
                 * options, of which the value will be returned will be thrown instead of the
                 * HTTP error. */
                allowedMethods(options = {}) {
                    const implemented = this.#methods;
                    const allowedMethods = async (context, next) => {
                        const ctx = context;
                        await next();
                        if (!ctx.response.status || ctx.response.status === deps_ts_14.Status.NotFound) {
                            deps_ts_14.assert(ctx.matched);
                            const allowed = new Set();
                            for (const route of ctx.matched) {
                                for (const method of route.methods) {
                                    allowed.add(method);
                                }
                            }
                            const allowedStr = [...allowed].join(", ");
                            if (!implemented.includes(ctx.request.method)) {
                                if (options.throw) {
                                    throw options.notImplemented
                                        ? options.notImplemented()
                                        : new httpError_ts_7.httpErrors.NotImplemented();
                                }
                                else {
                                    ctx.response.status = deps_ts_14.Status.NotImplemented;
                                    ctx.response.headers.set("Allowed", allowedStr);
                                }
                            }
                            else if (allowed.size) {
                                if (ctx.request.method === "OPTIONS") {
                                    ctx.response.status = deps_ts_14.Status.OK;
                                    ctx.response.headers.set("Allowed", allowedStr);
                                }
                                else if (!allowed.has(ctx.request.method)) {
                                    if (options.throw) {
                                        throw options.methodNotAllowed
                                            ? options.methodNotAllowed()
                                            : new httpError_ts_7.httpErrors.MethodNotAllowed();
                                    }
                                    else {
                                        ctx.response.status = deps_ts_14.Status.MethodNotAllowed;
                                        ctx.response.headers.set("Allowed", allowedStr);
                                    }
                                }
                            }
                        }
                    };
                    return allowedMethods;
                }
                delete(nameOrPath, pathOrMiddleware, ...middleware) {
                    this.#useVerb(nameOrPath, pathOrMiddleware, middleware, ["DELETE"]);
                    return this;
                }
                /** Iterate over the routes currently added to the router.  To be compatible
                 * with the iterable interfaces, both the key and value are set to the value
                 * of the route. */
                *entries() {
                    for (const route of this.#stack) {
                        const value = route.toJSON();
                        yield [value, value];
                    }
                }
                /** Iterate over the routes currently added to the router, calling the
                 * `callback` function for each value. */
                forEach(callback, thisArg = null) {
                    for (const route of this.#stack) {
                        const value = route.toJSON();
                        callback.call(thisArg, value, value, this);
                    }
                }
                get(nameOrPath, pathOrMiddleware, ...middleware) {
                    this.#useVerb(nameOrPath, pathOrMiddleware, middleware, ["GET"]);
                    return this;
                }
                head(nameOrPath, pathOrMiddleware, ...middleware) {
                    this.#useVerb(nameOrPath, pathOrMiddleware, middleware, ["HEAD"]);
                    return this;
                }
                /** Iterate over the routes currently added to the router.  To be compatible
                 * with the iterable interfaces, the key is set to the value of the route. */
                *keys() {
                    for (const route of this.#stack) {
                        yield route.toJSON();
                    }
                }
                options(nameOrPath, pathOrMiddleware, ...middleware) {
                    this.#useVerb(nameOrPath, pathOrMiddleware, middleware, ["OPTIONS"]);
                    return this;
                }
                /** Register param middleware, which will be called when the particular param
                 * is parsed from the route. */
                param(param, middleware) {
                    this.#params[param] = middleware;
                    for (const route of this.#stack) {
                        route.param(param, middleware);
                    }
                    return this;
                }
                patch(nameOrPath, pathOrMiddleware, ...middleware) {
                    this.#useVerb(nameOrPath, pathOrMiddleware, middleware, ["PATCH"]);
                    return this;
                }
                post(nameOrPath, pathOrMiddleware, ...middleware) {
                    this.#useVerb(nameOrPath, pathOrMiddleware, middleware, ["POST"]);
                    return this;
                }
                /** Set the router prefix for this router. */
                prefix(prefix) {
                    prefix = prefix.replace(/\/$/, "");
                    this.#opts.prefix = prefix;
                    for (const route of this.#stack) {
                        route.setPrefix(prefix);
                    }
                    return this;
                }
                put(nameOrPath, pathOrMiddleware, ...middleware) {
                    this.#useVerb(nameOrPath, pathOrMiddleware, middleware, ["PUT"]);
                    return this;
                }
                /** Register a direction middleware, where when the `source` path is matched
                 * the router will redirect the request to the `destination` path.  A `status`
                 * of `302 Found` will be set by default.
                 *
                 * The `source` and `destination` can be named routes. */
                redirect(source, destination, status = deps_ts_14.Status.Found) {
                    if (source[0] !== "/") {
                        const s = this.url(source);
                        if (!s) {
                            throw new RangeError(`Could not resolve named route: "${source}"`);
                        }
                        source = s;
                    }
                    if (destination[0] !== "/") {
                        const d = this.url(destination);
                        if (!d) {
                            throw new RangeError(`Could not resolve named route: "${source}"`);
                        }
                        destination = d;
                    }
                    this.all(source, (ctx) => {
                        ctx.response.redirect(destination);
                        ctx.response.status = status;
                    });
                    return this;
                }
                /** Return middleware that will do all the route processing that the router
                 * has been configured to handle.  Typical usage would be something like this:
                 *
                 * ```ts
                 * import { Application, Router } from "https://deno.land/x/oak/mod.ts";
                 *
                 * const app = new Application();
                 * const router = new Router();
                 *
                 * // register routes
                 *
                 * app.use(router.routes());
                 * app.use(router.allowedMethods());
                 * await app.listen({ port: 80 });
                 * ```
                 */
                routes() {
                    const dispatch = (context, next) => {
                        const ctx = context;
                        const { url: { pathname }, method } = ctx.request;
                        const path = this.#opts.routerPath ?? ctx.routerPath ?? pathname;
                        const matches = this.#match(path, method);
                        if (ctx.matched) {
                            ctx.matched.push(...matches.path);
                        }
                        else {
                            ctx.matched = [...matches.path];
                        }
                        ctx.router = this;
                        if (!matches.route)
                            return next();
                        const { pathAndMethod: matchedRoutes } = matches;
                        const chain = matchedRoutes.reduce((prev, route) => [
                            ...prev,
                            (ctx, next) => {
                                ctx.captures = route.captures(path);
                                ctx.params = route.params(ctx.captures, ctx.params);
                                ctx.routeName = route.name;
                                return next();
                            },
                            ...route.stack,
                        ], []);
                        return middleware_ts_2.compose(chain)(ctx, next);
                    };
                    dispatch.router = this;
                    return dispatch;
                }
                /** Generate a URL pathname for a named route, interpolating the optional
                 * params provided.  Also accepts an optional set of options. */
                url(name, params, options) {
                    const route = this.#route(name);
                    if (route) {
                        return route.url(params, options);
                    }
                }
                use(pathOrMiddleware, ...middleware) {
                    let path;
                    if (typeof pathOrMiddleware === "string" || Array.isArray(pathOrMiddleware)) {
                        path = pathOrMiddleware;
                    }
                    else {
                        middleware.unshift(pathOrMiddleware);
                    }
                    this.#register(path ?? "(.*)", middleware, [], { end: false, ignoreCaptures: !path });
                    return this;
                }
                /** Iterate over the routes currently added to the router. */
                *values() {
                    for (const route of this.#stack) {
                        yield route.toJSON();
                    }
                }
                /** Provide an iterator interface that iterates over the routes registered
                 * with the router. */
                *[Symbol.iterator]() {
                    for (const route of this.#stack) {
                        yield route.toJSON();
                    }
                }
                /** Generate a URL pathname based on the provided path, interpolating the
                 * optional params provided.  Also accepts an optional set of options. */
                static url(path, params, options) {
                    return toUrl(path, params, options);
                }
            };
            exports_88("Router", Router);
        }
    };
});
// Copyright 2018-2020 the oak authors. All rights reserved. MIT license.
System.register("https://deno.land/x/oak/helpers", [], function (exports_89, context_89) {
    "use strict";
    var __moduleName = context_89 && context_89.id;
    function isRouterContext(value) {
        return "params" in value;
    }
    function getQuery(ctx, { mergeParams, asMap } = {}) {
        const result = {};
        if (mergeParams && isRouterContext(ctx)) {
            Object.assign(result, ctx.params);
        }
        for (const [key, value] of ctx.request.url.searchParams) {
            result[key] = value;
        }
        return asMap ? new Map(Object.entries(result)) : result;
    }
    exports_89("getQuery", getQuery);
    return {
        setters: [],
        execute: function () {
        }
    };
});
// Copyright 2018-2020 the oak authors. All rights reserved. MIT license.
System.register("https://deno.land/x/oak/mod", ["https://deno.land/x/oak/application", "https://deno.land/x/oak/context", "https://deno.land/x/oak/helpers", "https://deno.land/x/oak/cookies", "https://deno.land/x/oak/httpError", "https://deno.land/x/oak/middleware", "https://deno.land/x/oak/multipart", "https://deno.land/x/oak/request", "https://deno.land/x/oak/response", "https://deno.land/x/oak/router", "https://deno.land/x/oak/send", "https://deno.land/x/oak/server_sent_event", "https://deno.land/x/oak/util", "https://deno.land/x/oak/deps"], function (exports_90, context_90) {
    "use strict";
    var __moduleName = context_90 && context_90.id;
    return {
        setters: [
            function (application_ts_1_1) {
                exports_90({
                    "Application": application_ts_1_1["Application"]
                });
            },
            function (context_ts_2_1) {
                exports_90({
                    "Context": context_ts_2_1["Context"]
                });
            },
            function (helpers_1) {
                exports_90("helpers", helpers_1);
            },
            function (cookies_ts_2_1) {
                exports_90({
                    "Cookies": cookies_ts_2_1["Cookies"]
                });
            },
            function (httpError_ts_8_1) {
                exports_90({
                    "HttpError": httpError_ts_8_1["HttpError"],
                    "httpErrors": httpError_ts_8_1["httpErrors"],
                    "isHttpError": httpError_ts_8_1["isHttpError"]
                });
            },
            function (middleware_ts_3_1) {
                exports_90({
                    "composeMiddleware": middleware_ts_3_1["compose"]
                });
            },
            function (multipart_ts_2_1) {
                exports_90({
                    "FormDataReader": multipart_ts_2_1["FormDataReader"]
                });
            },
            function (request_ts_2_1) {
                exports_90({
                    "Request": request_ts_2_1["Request"]
                });
            },
            function (response_ts_2_1) {
                exports_90({
                    "Response": response_ts_2_1["Response"],
                    "REDIRECT_BACK": response_ts_2_1["REDIRECT_BACK"]
                });
            },
            function (router_ts_1_1) {
                exports_90({
                    "Router": router_ts_1_1["Router"]
                });
            },
            function (send_ts_2_1) {
                exports_90({
                    "send": send_ts_2_1["send"]
                });
            },
            function (server_sent_event_ts_2_1) {
                exports_90({
                    "ServerSentEvent": server_sent_event_ts_2_1["ServerSentEvent"],
                    "ServerSentEventTarget": server_sent_event_ts_2_1["ServerSentEventTarget"]
                });
            },
            function (util_ts_10_1) {
                exports_90({
                    "isErrorStatus": util_ts_10_1["isErrorStatus"],
                    "isRedirectStatus": util_ts_10_1["isRedirectStatus"]
                });
            },
            function (deps_ts_15_1) {
                exports_90({
                    "Status": deps_ts_15_1["Status"],
                    "STATUS_TEXT": deps_ts_15_1["STATUS_TEXT"]
                });
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@v0.51.0/fmt/colors", [], function (exports_91, context_91) {
    "use strict";
    var noColor, enabled;
    var __moduleName = context_91 && context_91.id;
    function setColorEnabled(value) {
        if (noColor) {
            return;
        }
        enabled = value;
    }
    exports_91("setColorEnabled", setColorEnabled);
    function getColorEnabled() {
        return enabled;
    }
    exports_91("getColorEnabled", getColorEnabled);
    function code(open, close) {
        return {
            open: `\x1b[${open.join(";")}m`,
            close: `\x1b[${close}m`,
            regexp: new RegExp(`\\x1b\\[${close}m`, "g"),
        };
    }
    function run(str, code) {
        return enabled
            ? `${code.open}${str.replace(code.regexp, code.open)}${code.close}`
            : str;
    }
    function reset(str) {
        return run(str, code([0], 0));
    }
    exports_91("reset", reset);
    function bold(str) {
        return run(str, code([1], 22));
    }
    exports_91("bold", bold);
    function dim(str) {
        return run(str, code([2], 22));
    }
    exports_91("dim", dim);
    function italic(str) {
        return run(str, code([3], 23));
    }
    exports_91("italic", italic);
    function underline(str) {
        return run(str, code([4], 24));
    }
    exports_91("underline", underline);
    function inverse(str) {
        return run(str, code([7], 27));
    }
    exports_91("inverse", inverse);
    function hidden(str) {
        return run(str, code([8], 28));
    }
    exports_91("hidden", hidden);
    function strikethrough(str) {
        return run(str, code([9], 29));
    }
    exports_91("strikethrough", strikethrough);
    function black(str) {
        return run(str, code([30], 39));
    }
    exports_91("black", black);
    function red(str) {
        return run(str, code([31], 39));
    }
    exports_91("red", red);
    function green(str) {
        return run(str, code([32], 39));
    }
    exports_91("green", green);
    function yellow(str) {
        return run(str, code([33], 39));
    }
    exports_91("yellow", yellow);
    function blue(str) {
        return run(str, code([34], 39));
    }
    exports_91("blue", blue);
    function magenta(str) {
        return run(str, code([35], 39));
    }
    exports_91("magenta", magenta);
    function cyan(str) {
        return run(str, code([36], 39));
    }
    exports_91("cyan", cyan);
    function white(str) {
        return run(str, code([37], 39));
    }
    exports_91("white", white);
    function gray(str) {
        return run(str, code([90], 39));
    }
    exports_91("gray", gray);
    function bgBlack(str) {
        return run(str, code([40], 49));
    }
    exports_91("bgBlack", bgBlack);
    function bgRed(str) {
        return run(str, code([41], 49));
    }
    exports_91("bgRed", bgRed);
    function bgGreen(str) {
        return run(str, code([42], 49));
    }
    exports_91("bgGreen", bgGreen);
    function bgYellow(str) {
        return run(str, code([43], 49));
    }
    exports_91("bgYellow", bgYellow);
    function bgBlue(str) {
        return run(str, code([44], 49));
    }
    exports_91("bgBlue", bgBlue);
    function bgMagenta(str) {
        return run(str, code([45], 49));
    }
    exports_91("bgMagenta", bgMagenta);
    function bgCyan(str) {
        return run(str, code([46], 49));
    }
    exports_91("bgCyan", bgCyan);
    function bgWhite(str) {
        return run(str, code([47], 49));
    }
    exports_91("bgWhite", bgWhite);
    /* Special Color Sequences */
    function clampAndTruncate(n, max = 255, min = 0) {
        return Math.trunc(Math.max(Math.min(n, max), min));
    }
    /** Set text color using paletted 8bit colors.
     * https://en.wikipedia.org/wiki/ANSI_escape_code#8-bit */
    function rgb8(str, color) {
        return run(str, code([38, 5, clampAndTruncate(color)], 39));
    }
    exports_91("rgb8", rgb8);
    /** Set background color using paletted 8bit colors.
     * https://en.wikipedia.org/wiki/ANSI_escape_code#8-bit */
    function bgRgb8(str, color) {
        return run(str, code([48, 5, clampAndTruncate(color)], 49));
    }
    exports_91("bgRgb8", bgRgb8);
    /** Set text color using 24bit rgb. */
    function rgb24(str, color) {
        return run(str, code([
            38,
            2,
            clampAndTruncate(color.r),
            clampAndTruncate(color.g),
            clampAndTruncate(color.b),
        ], 39));
    }
    exports_91("rgb24", rgb24);
    /** Set background color using 24bit rgb. */
    function bgRgb24(str, color) {
        return run(str, code([
            48,
            2,
            clampAndTruncate(color.r),
            clampAndTruncate(color.g),
            clampAndTruncate(color.b),
        ], 49));
    }
    exports_91("bgRgb24", bgRgb24);
    return {
        setters: [],
        execute: function () {
            // Copyright 2018-2020 the Deno authors. All rights reserved. MIT license.
            /**
             * A module to print ANSI terminal colors. Inspired by chalk, kleur, and colors
             * on npm.
             *
             * ```
             * import { bgBlue, red, bold } from "https://deno.land/std/fmt/colors.ts";
             * console.log(bgBlue(red(bold("Hello world!"))));
             * ```
             *
             * This module supports `NO_COLOR` environmental variable disabling any coloring
             * if `NO_COLOR` is set.
             */
            noColor = Deno.noColor;
            enabled = !noColor;
        }
    };
});
System.register("https://deno.land/std@v0.51.0/testing/diff", [], function (exports_92, context_92) {
    "use strict";
    var DiffType, REMOVED, COMMON, ADDED;
    var __moduleName = context_92 && context_92.id;
    function createCommon(A, B, reverse) {
        const common = [];
        if (A.length === 0 || B.length === 0)
            return [];
        for (let i = 0; i < Math.min(A.length, B.length); i += 1) {
            if (A[reverse ? A.length - i - 1 : i] === B[reverse ? B.length - i - 1 : i]) {
                common.push(A[reverse ? A.length - i - 1 : i]);
            }
            else {
                return common;
            }
        }
        return common;
    }
    function diff(A, B) {
        const prefixCommon = createCommon(A, B);
        const suffixCommon = createCommon(A.slice(prefixCommon.length), B.slice(prefixCommon.length), true).reverse();
        A = suffixCommon.length
            ? A.slice(prefixCommon.length, -suffixCommon.length)
            : A.slice(prefixCommon.length);
        B = suffixCommon.length
            ? B.slice(prefixCommon.length, -suffixCommon.length)
            : B.slice(prefixCommon.length);
        const swapped = B.length > A.length;
        [A, B] = swapped ? [B, A] : [A, B];
        const M = A.length;
        const N = B.length;
        if (!M && !N && !suffixCommon.length && !prefixCommon.length)
            return [];
        if (!N) {
            return [
                ...prefixCommon.map((c) => ({ type: DiffType.common, value: c })),
                ...A.map((a) => ({
                    type: swapped ? DiffType.added : DiffType.removed,
                    value: a,
                })),
                ...suffixCommon.map((c) => ({ type: DiffType.common, value: c })),
            ];
        }
        const offset = N;
        const delta = M - N;
        const size = M + N + 1;
        const fp = new Array(size).fill({ y: -1 });
        /**
         * INFO:
         * This buffer is used to save memory and improve performance.
         * The first half is used to save route and last half is used to save diff
         * type.
         * This is because, when I kept new uint8array area to save type,performance
         * worsened.
         */
        const routes = new Uint32Array((M * N + size + 1) * 2);
        const diffTypesPtrOffset = routes.length / 2;
        let ptr = 0;
        let p = -1;
        function backTrace(A, B, current, swapped) {
            const M = A.length;
            const N = B.length;
            const result = [];
            let a = M - 1;
            let b = N - 1;
            let j = routes[current.id];
            let type = routes[current.id + diffTypesPtrOffset];
            while (true) {
                if (!j && !type)
                    break;
                const prev = j;
                if (type === REMOVED) {
                    result.unshift({
                        type: swapped ? DiffType.removed : DiffType.added,
                        value: B[b],
                    });
                    b -= 1;
                }
                else if (type === ADDED) {
                    result.unshift({
                        type: swapped ? DiffType.added : DiffType.removed,
                        value: A[a],
                    });
                    a -= 1;
                }
                else {
                    result.unshift({ type: DiffType.common, value: A[a] });
                    a -= 1;
                    b -= 1;
                }
                j = routes[prev];
                type = routes[prev + diffTypesPtrOffset];
            }
            return result;
        }
        function createFP(slide, down, k, M) {
            if (slide && slide.y === -1 && down && down.y === -1) {
                return { y: 0, id: 0 };
            }
            if ((down && down.y === -1) ||
                k === M ||
                (slide && slide.y) > (down && down.y) + 1) {
                const prev = slide.id;
                ptr++;
                routes[ptr] = prev;
                routes[ptr + diffTypesPtrOffset] = ADDED;
                return { y: slide.y, id: ptr };
            }
            else {
                const prev = down.id;
                ptr++;
                routes[ptr] = prev;
                routes[ptr + diffTypesPtrOffset] = REMOVED;
                return { y: down.y + 1, id: ptr };
            }
        }
        function snake(k, slide, down, _offset, A, B) {
            const M = A.length;
            const N = B.length;
            if (k < -N || M < k)
                return { y: -1, id: -1 };
            const fp = createFP(slide, down, k, M);
            while (fp.y + k < M && fp.y < N && A[fp.y + k] === B[fp.y]) {
                const prev = fp.id;
                ptr++;
                fp.id = ptr;
                fp.y += 1;
                routes[ptr] = prev;
                routes[ptr + diffTypesPtrOffset] = COMMON;
            }
            return fp;
        }
        while (fp[delta + offset].y < N) {
            p = p + 1;
            for (let k = -p; k < delta; ++k) {
                fp[k + offset] = snake(k, fp[k - 1 + offset], fp[k + 1 + offset], offset, A, B);
            }
            for (let k = delta + p; k > delta; --k) {
                fp[k + offset] = snake(k, fp[k - 1 + offset], fp[k + 1 + offset], offset, A, B);
            }
            fp[delta + offset] = snake(delta, fp[delta - 1 + offset], fp[delta + 1 + offset], offset, A, B);
        }
        return [
            ...prefixCommon.map((c) => ({ type: DiffType.common, value: c })),
            ...backTrace(A, B, fp[delta + offset], swapped),
            ...suffixCommon.map((c) => ({ type: DiffType.common, value: c })),
        ];
    }
    exports_92("default", diff);
    return {
        setters: [],
        execute: function () {
            (function (DiffType) {
                DiffType["removed"] = "removed";
                DiffType["common"] = "common";
                DiffType["added"] = "added";
            })(DiffType || (DiffType = {}));
            exports_92("DiffType", DiffType);
            REMOVED = 1;
            COMMON = 2;
            ADDED = 3;
        }
    };
});
System.register("https://deno.land/std@v0.51.0/testing/asserts", ["https://deno.land/std@v0.51.0/fmt/colors", "https://deno.land/std@v0.51.0/testing/diff"], function (exports_93, context_93) {
    "use strict";
    var colors_ts_2, diff_ts_2, CAN_NOT_DISPLAY, AssertionError;
    var __moduleName = context_93 && context_93.id;
    function format(v) {
        let string = Deno.inspect(v);
        if (typeof v == "string") {
            string = `"${string.replace(/(?=["\\])/g, "\\")}"`;
        }
        return string;
    }
    function createColor(diffType) {
        switch (diffType) {
            case diff_ts_2.DiffType.added:
                return (s) => colors_ts_2.green(colors_ts_2.bold(s));
            case diff_ts_2.DiffType.removed:
                return (s) => colors_ts_2.red(colors_ts_2.bold(s));
            default:
                return colors_ts_2.white;
        }
    }
    function createSign(diffType) {
        switch (diffType) {
            case diff_ts_2.DiffType.added:
                return "+   ";
            case diff_ts_2.DiffType.removed:
                return "-   ";
            default:
                return "    ";
        }
    }
    function buildMessage(diffResult) {
        const messages = [];
        messages.push("");
        messages.push("");
        messages.push(`    ${colors_ts_2.gray(colors_ts_2.bold("[Diff]"))} ${colors_ts_2.red(colors_ts_2.bold("Actual"))} / ${colors_ts_2.green(colors_ts_2.bold("Expected"))}`);
        messages.push("");
        messages.push("");
        diffResult.forEach((result) => {
            const c = createColor(result.type);
            messages.push(c(`${createSign(result.type)}${result.value}`));
        });
        messages.push("");
        return messages;
    }
    function isKeyedCollection(x) {
        return [Symbol.iterator, "size"].every((k) => k in x);
    }
    function equal(c, d) {
        const seen = new Map();
        return (function compare(a, b) {
            // Have to render RegExp & Date for string comparison
            // unless it's mistreated as object
            if (a &&
                b &&
                ((a instanceof RegExp && b instanceof RegExp) ||
                    (a instanceof Date && b instanceof Date))) {
                return String(a) === String(b);
            }
            if (Object.is(a, b)) {
                return true;
            }
            if (a && typeof a === "object" && b && typeof b === "object") {
                if (seen.get(a) === b) {
                    return true;
                }
                if (Object.keys(a || {}).length !== Object.keys(b || {}).length) {
                    return false;
                }
                if (isKeyedCollection(a) && isKeyedCollection(b)) {
                    if (a.size !== b.size) {
                        return false;
                    }
                    let unmatchedEntries = a.size;
                    for (const [aKey, aValue] of a.entries()) {
                        for (const [bKey, bValue] of b.entries()) {
                            /* Given that Map keys can be references, we need
                             * to ensure that they are also deeply equal */
                            if ((aKey === aValue && bKey === bValue && compare(aKey, bKey)) ||
                                (compare(aKey, bKey) && compare(aValue, bValue))) {
                                unmatchedEntries--;
                            }
                        }
                    }
                    return unmatchedEntries === 0;
                }
                const merged = { ...a, ...b };
                for (const key in merged) {
                    if (!compare(a && a[key], b && b[key])) {
                        return false;
                    }
                }
                seen.set(a, b);
                return true;
            }
            return false;
        })(c, d);
    }
    exports_93("equal", equal);
    /** Make an assertion, if not `true`, then throw. */
    function assert(expr, msg = "") {
        if (!expr) {
            throw new AssertionError(msg);
        }
    }
    exports_93("assert", assert);
    /**
     * Make an assertion that `actual` and `expected` are equal, deeply. If not
     * deeply equal, then throw.
     */
    function assertEquals(actual, expected, msg) {
        if (equal(actual, expected)) {
            return;
        }
        let message = "";
        const actualString = format(actual);
        const expectedString = format(expected);
        try {
            const diffResult = diff_ts_2.default(actualString.split("\n"), expectedString.split("\n"));
            message = buildMessage(diffResult).join("\n");
        }
        catch (e) {
            message = `\n${colors_ts_2.red(CAN_NOT_DISPLAY)} + \n\n`;
        }
        if (msg) {
            message = msg;
        }
        throw new AssertionError(message);
    }
    exports_93("assertEquals", assertEquals);
    /**
     * Make an assertion that `actual` and `expected` are not equal, deeply.
     * If not then throw.
     */
    function assertNotEquals(actual, expected, msg) {
        if (!equal(actual, expected)) {
            return;
        }
        let actualString;
        let expectedString;
        try {
            actualString = String(actual);
        }
        catch (e) {
            actualString = "[Cannot display]";
        }
        try {
            expectedString = String(expected);
        }
        catch (e) {
            expectedString = "[Cannot display]";
        }
        if (!msg) {
            msg = `actual: ${actualString} expected: ${expectedString}`;
        }
        throw new AssertionError(msg);
    }
    exports_93("assertNotEquals", assertNotEquals);
    /**
     * Make an assertion that `actual` and `expected` are strictly equal.  If
     * not then throw.
     */
    function assertStrictEq(actual, expected, msg) {
        if (actual !== expected) {
            let actualString;
            let expectedString;
            try {
                actualString = String(actual);
            }
            catch (e) {
                actualString = "[Cannot display]";
            }
            try {
                expectedString = String(expected);
            }
            catch (e) {
                expectedString = "[Cannot display]";
            }
            if (!msg) {
                msg = `actual: ${actualString} expected: ${expectedString}`;
            }
            throw new AssertionError(msg);
        }
    }
    exports_93("assertStrictEq", assertStrictEq);
    /**
     * Make an assertion that actual contains expected. If not
     * then thrown.
     */
    function assertStrContains(actual, expected, msg) {
        if (!actual.includes(expected)) {
            if (!msg) {
                msg = `actual: "${actual}" expected to contains: "${expected}"`;
            }
            throw new AssertionError(msg);
        }
    }
    exports_93("assertStrContains", assertStrContains);
    /**
     * Make an assertion that `actual` contains the `expected` values
     * If not then thrown.
     */
    function assertArrayContains(actual, expected, msg) {
        const missing = [];
        for (let i = 0; i < expected.length; i++) {
            let found = false;
            for (let j = 0; j < actual.length; j++) {
                if (equal(expected[i], actual[j])) {
                    found = true;
                    break;
                }
            }
            if (!found) {
                missing.push(expected[i]);
            }
        }
        if (missing.length === 0) {
            return;
        }
        if (!msg) {
            msg = `actual: "${actual}" expected to contains: "${expected}"`;
            msg += "\n";
            msg += `missing: ${missing}`;
        }
        throw new AssertionError(msg);
    }
    exports_93("assertArrayContains", assertArrayContains);
    /**
     * Make an assertion that `actual` match RegExp `expected`. If not
     * then thrown
     */
    function assertMatch(actual, expected, msg) {
        if (!expected.test(actual)) {
            if (!msg) {
                msg = `actual: "${actual}" expected to match: "${expected}"`;
            }
            throw new AssertionError(msg);
        }
    }
    exports_93("assertMatch", assertMatch);
    /**
     * Forcefully throws a failed assertion
     */
    function fail(msg) {
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        assert(false, `Failed assertion${msg ? `: ${msg}` : "."}`);
    }
    exports_93("fail", fail);
    /** Executes a function, expecting it to throw.  If it does not, then it
     * throws.  An error class and a string that should be included in the
     * error message can also be asserted.
     */
    function assertThrows(fn, ErrorClass, msgIncludes = "", msg) {
        let doesThrow = false;
        let error = null;
        try {
            fn();
        }
        catch (e) {
            if (ErrorClass && !(Object.getPrototypeOf(e) === ErrorClass.prototype)) {
                msg = `Expected error to be instance of "${ErrorClass.name}", but was "${e.constructor.name}"${msg ? `: ${msg}` : "."}`;
                throw new AssertionError(msg);
            }
            if (msgIncludes && !e.message.includes(msgIncludes)) {
                msg = `Expected error message to include "${msgIncludes}", but got "${e.message}"${msg ? `: ${msg}` : "."}`;
                throw new AssertionError(msg);
            }
            doesThrow = true;
            error = e;
        }
        if (!doesThrow) {
            msg = `Expected function to throw${msg ? `: ${msg}` : "."}`;
            throw new AssertionError(msg);
        }
        return error;
    }
    exports_93("assertThrows", assertThrows);
    async function assertThrowsAsync(fn, ErrorClass, msgIncludes = "", msg) {
        let doesThrow = false;
        let error = null;
        try {
            await fn();
        }
        catch (e) {
            if (ErrorClass && !(Object.getPrototypeOf(e) === ErrorClass.prototype)) {
                msg = `Expected error to be instance of "${ErrorClass.name}", but got "${e.name}"${msg ? `: ${msg}` : "."}`;
                throw new AssertionError(msg);
            }
            if (msgIncludes && !e.message.includes(msgIncludes)) {
                msg = `Expected error message to include "${msgIncludes}", but got "${e.message}"${msg ? `: ${msg}` : "."}`;
                throw new AssertionError(msg);
            }
            doesThrow = true;
            error = e;
        }
        if (!doesThrow) {
            msg = `Expected function to throw${msg ? `: ${msg}` : "."}`;
            throw new AssertionError(msg);
        }
        return error;
    }
    exports_93("assertThrowsAsync", assertThrowsAsync);
    /** Use this to stub out methods that will throw when invoked. */
    function unimplemented(msg) {
        throw new AssertionError(msg || "unimplemented");
    }
    exports_93("unimplemented", unimplemented);
    /** Use this to assert unreachable code. */
    function unreachable() {
        throw new AssertionError("unreachable");
    }
    exports_93("unreachable", unreachable);
    return {
        setters: [
            function (colors_ts_2_1) {
                colors_ts_2 = colors_ts_2_1;
            },
            function (diff_ts_2_1) {
                diff_ts_2 = diff_ts_2_1;
            }
        ],
        execute: function () {
            CAN_NOT_DISPLAY = "[Cannot display]";
            AssertionError = class AssertionError extends Error {
                constructor(message) {
                    super(message);
                    this.name = "AssertionError";
                }
            };
            exports_93("AssertionError", AssertionError);
        }
    };
});
System.register("https://deno.land/std@v0.51.0/async/deferred", [], function (exports_94, context_94) {
    "use strict";
    var __moduleName = context_94 && context_94.id;
    /** Creates a Promise with the `reject` and `resolve` functions
     * placed as methods on the promise object itself. It allows you to do:
     *
     *     const p = deferred<number>();
     *     // ...
     *     p.resolve(42);
     */
    function deferred() {
        let methods;
        const promise = new Promise((resolve, reject) => {
            methods = { resolve, reject };
        });
        return Object.assign(promise, methods);
    }
    exports_94("deferred", deferred);
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@v0.51.0/async/delay", [], function (exports_95, context_95) {
    "use strict";
    var __moduleName = context_95 && context_95.id;
    // Copyright 2018-2020 the Deno authors. All rights reserved. MIT license.
    /* Resolves after the given number of milliseconds. */
    function delay(ms) {
        return new Promise((res) => setTimeout(() => {
            res();
        }, ms));
    }
    exports_95("delay", delay);
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@v0.51.0/async/mux_async_iterator", ["https://deno.land/std@v0.51.0/async/deferred"], function (exports_96, context_96) {
    "use strict";
    var deferred_ts_4, MuxAsyncIterator;
    var __moduleName = context_96 && context_96.id;
    return {
        setters: [
            function (deferred_ts_4_1) {
                deferred_ts_4 = deferred_ts_4_1;
            }
        ],
        execute: function () {
            /** The MuxAsyncIterator class multiplexes multiple async iterators into a
             * single stream. It currently makes a few assumptions:
             * - The iterators do not throw.
             * - The final result (the value returned and not yielded from the iterator)
             *   does not matter; if there is any, it is discarded.
             */
            MuxAsyncIterator = class MuxAsyncIterator {
                constructor() {
                    this.iteratorCount = 0;
                    this.yields = [];
                    this.signal = deferred_ts_4.deferred();
                }
                add(iterator) {
                    ++this.iteratorCount;
                    this.callIteratorNext(iterator);
                }
                async callIteratorNext(iterator) {
                    const { value, done } = await iterator.next();
                    if (done) {
                        --this.iteratorCount;
                    }
                    else {
                        this.yields.push({ iterator, value });
                    }
                    this.signal.resolve();
                }
                async *iterate() {
                    while (this.iteratorCount > 0) {
                        // Sleep until any of the wrapped iterators yields.
                        await this.signal;
                        // Note that while we're looping over `yields`, new items may be added.
                        for (let i = 0; i < this.yields.length; i++) {
                            const { iterator, value } = this.yields[i];
                            yield value;
                            this.callIteratorNext(iterator);
                        }
                        // Clear the `yields` list and reset the `signal` promise.
                        this.yields.length = 0;
                        this.signal = deferred_ts_4.deferred();
                    }
                }
                [Symbol.asyncIterator]() {
                    return this.iterate();
                }
            };
            exports_96("MuxAsyncIterator", MuxAsyncIterator);
        }
    };
});
System.register("https://deno.land/std@v0.51.0/async/mod", ["https://deno.land/std@v0.51.0/async/deferred", "https://deno.land/std@v0.51.0/async/delay", "https://deno.land/std@v0.51.0/async/mux_async_iterator"], function (exports_97, context_97) {
    "use strict";
    var __moduleName = context_97 && context_97.id;
    function exportStar_5(m) {
        var exports = {};
        for (var n in m) {
            if (n !== "default") exports[n] = m[n];
        }
        exports_97(exports);
    }
    return {
        setters: [
            function (deferred_ts_5_1) {
                exportStar_5(deferred_ts_5_1);
            },
            function (delay_ts_2_1) {
                exportStar_5(delay_ts_2_1);
            },
            function (mux_async_iterator_ts_2_1) {
                exportStar_5(mux_async_iterator_ts_2_1);
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@v0.51.0/encoding/utf8", [], function (exports_98, context_98) {
    "use strict";
    var encoder, decoder;
    var __moduleName = context_98 && context_98.id;
    /** Shorthand for new TextEncoder().encode() */
    function encode(input) {
        return encoder.encode(input);
    }
    exports_98("encode", encode);
    /** Shorthand for new TextDecoder().decode() */
    function decode(input) {
        return decoder.decode(input);
    }
    exports_98("decode", decode);
    return {
        setters: [],
        execute: function () {
            /** A default TextEncoder instance */
            exports_98("encoder", encoder = new TextEncoder());
            /** A default TextDecoder instance */
            exports_98("decoder", decoder = new TextDecoder());
        }
    };
});
System.register("https://deno.land/std@v0.50.0/fmt/colors", [], function (exports_99, context_99) {
    "use strict";
    var noColor, enabled;
    var __moduleName = context_99 && context_99.id;
    function setColorEnabled(value) {
        if (noColor) {
            return;
        }
        enabled = value;
    }
    exports_99("setColorEnabled", setColorEnabled);
    function getColorEnabled() {
        return enabled;
    }
    exports_99("getColorEnabled", getColorEnabled);
    function code(open, close) {
        return {
            open: `\x1b[${open.join(";")}m`,
            close: `\x1b[${close}m`,
            regexp: new RegExp(`\\x1b\\[${close}m`, "g"),
        };
    }
    function run(str, code) {
        return enabled
            ? `${code.open}${str.replace(code.regexp, code.open)}${code.close}`
            : str;
    }
    function reset(str) {
        return run(str, code([0], 0));
    }
    exports_99("reset", reset);
    function bold(str) {
        return run(str, code([1], 22));
    }
    exports_99("bold", bold);
    function dim(str) {
        return run(str, code([2], 22));
    }
    exports_99("dim", dim);
    function italic(str) {
        return run(str, code([3], 23));
    }
    exports_99("italic", italic);
    function underline(str) {
        return run(str, code([4], 24));
    }
    exports_99("underline", underline);
    function inverse(str) {
        return run(str, code([7], 27));
    }
    exports_99("inverse", inverse);
    function hidden(str) {
        return run(str, code([8], 28));
    }
    exports_99("hidden", hidden);
    function strikethrough(str) {
        return run(str, code([9], 29));
    }
    exports_99("strikethrough", strikethrough);
    function black(str) {
        return run(str, code([30], 39));
    }
    exports_99("black", black);
    function red(str) {
        return run(str, code([31], 39));
    }
    exports_99("red", red);
    function green(str) {
        return run(str, code([32], 39));
    }
    exports_99("green", green);
    function yellow(str) {
        return run(str, code([33], 39));
    }
    exports_99("yellow", yellow);
    function blue(str) {
        return run(str, code([34], 39));
    }
    exports_99("blue", blue);
    function magenta(str) {
        return run(str, code([35], 39));
    }
    exports_99("magenta", magenta);
    function cyan(str) {
        return run(str, code([36], 39));
    }
    exports_99("cyan", cyan);
    function white(str) {
        return run(str, code([37], 39));
    }
    exports_99("white", white);
    function gray(str) {
        return run(str, code([90], 39));
    }
    exports_99("gray", gray);
    function bgBlack(str) {
        return run(str, code([40], 49));
    }
    exports_99("bgBlack", bgBlack);
    function bgRed(str) {
        return run(str, code([41], 49));
    }
    exports_99("bgRed", bgRed);
    function bgGreen(str) {
        return run(str, code([42], 49));
    }
    exports_99("bgGreen", bgGreen);
    function bgYellow(str) {
        return run(str, code([43], 49));
    }
    exports_99("bgYellow", bgYellow);
    function bgBlue(str) {
        return run(str, code([44], 49));
    }
    exports_99("bgBlue", bgBlue);
    function bgMagenta(str) {
        return run(str, code([45], 49));
    }
    exports_99("bgMagenta", bgMagenta);
    function bgCyan(str) {
        return run(str, code([46], 49));
    }
    exports_99("bgCyan", bgCyan);
    function bgWhite(str) {
        return run(str, code([47], 49));
    }
    exports_99("bgWhite", bgWhite);
    /* Special Color Sequences */
    function clampAndTruncate(n, max = 255, min = 0) {
        return Math.trunc(Math.max(Math.min(n, max), min));
    }
    /** Set text color using paletted 8bit colors.
     * https://en.wikipedia.org/wiki/ANSI_escape_code#8-bit */
    function rgb8(str, color) {
        return run(str, code([38, 5, clampAndTruncate(color)], 39));
    }
    exports_99("rgb8", rgb8);
    /** Set background color using paletted 8bit colors.
     * https://en.wikipedia.org/wiki/ANSI_escape_code#8-bit */
    function bgRgb8(str, color) {
        return run(str, code([48, 5, clampAndTruncate(color)], 49));
    }
    exports_99("bgRgb8", bgRgb8);
    /** Set text color using 24bit rgb. */
    function rgb24(str, color) {
        return run(str, code([
            38,
            2,
            clampAndTruncate(color.r),
            clampAndTruncate(color.g),
            clampAndTruncate(color.b),
        ], 39));
    }
    exports_99("rgb24", rgb24);
    /** Set background color using 24bit rgb. */
    function bgRgb24(str, color) {
        return run(str, code([
            48,
            2,
            clampAndTruncate(color.r),
            clampAndTruncate(color.g),
            clampAndTruncate(color.b),
        ], 49));
    }
    exports_99("bgRgb24", bgRgb24);
    return {
        setters: [],
        execute: function () {
            // Copyright 2018-2020 the Deno authors. All rights reserved. MIT license.
            /**
             * A module to print ANSI terminal colors. Inspired by chalk, kleur, and colors
             * on npm.
             *
             * ```
             * import { bgBlue, red, bold } from "https://deno.land/std/fmt/colors.ts";
             * console.log(bgBlue(red(bold("Hello world!"))));
             * ```
             *
             * This module supports `NO_COLOR` environmental variable disabling any coloring
             * if `NO_COLOR` is set.
             */
            noColor = Deno.noColor;
            enabled = !noColor;
        }
    };
});
System.register("https://deno.land/x/bytes_formater@1.2.0/deps", ["https://deno.land/std@v0.50.0/fmt/colors"], function (exports_100, context_100) {
    "use strict";
    var __moduleName = context_100 && context_100.id;
    return {
        setters: [
            function (colors_ts_3_1) {
                exports_100({
                    "setColorEnabled": colors_ts_3_1["setColorEnabled"],
                    "green": colors_ts_3_1["green"]
                });
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/bytes_formater@1.2.0/format", ["https://deno.land/x/bytes_formater@1.2.0/deps"], function (exports_101, context_101) {
    "use strict";
    var deps_ts_16;
    var __moduleName = context_101 && context_101.id;
    function format(data) {
        const bytes = new Uint8Array(data.buffer);
        let out = "";
        out += "         +-------------------------------------------------+\n";
        out += `         |${deps_ts_16.green("  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f ")}|\n`;
        out += "+--------+-------------------------------------------------+----------------+\n";
        const lineCount = Math.ceil(bytes.length / 16);
        for (let line = 0; line < lineCount; line++) {
            const start = line * 16;
            const addr = start.toString(16).padStart(8, "0");
            const lineBytes = bytes.slice(start, start + 16);
            out += `|${deps_ts_16.green(addr)}| `;
            lineBytes.forEach(byte => (out += byte.toString(16).padStart(2, "0") + " "));
            if (lineBytes.length < 16) {
                out += "   ".repeat(16 - lineBytes.length);
            }
            out += "|";
            lineBytes.forEach(function (byte) {
                return (out += byte > 31 && byte < 127 ? deps_ts_16.green(String.fromCharCode(byte)) : ".");
            });
            if (lineBytes.length < 16) {
                out += " ".repeat(16 - lineBytes.length);
            }
            out += "|\n";
        }
        out += "+--------+-------------------------------------------------+----------------+";
        return out;
    }
    exports_101("format", format);
    return {
        setters: [
            function (deps_ts_16_1) {
                deps_ts_16 = deps_ts_16_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/bytes_formater@1.2.0/mod", ["https://deno.land/x/bytes_formater@1.2.0/format", "https://deno.land/x/bytes_formater@1.2.0/deps"], function (exports_102, context_102) {
    "use strict";
    var __moduleName = context_102 && context_102.id;
    return {
        setters: [
            function (format_ts_1_1) {
                exports_102({
                    "format": format_ts_1_1["format"]
                });
            },
            function (deps_ts_17_1) {
                exports_102({
                    "setColorEnabled": deps_ts_17_1["setColorEnabled"]
                });
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/checksum@1.4.0/sha1", [], function (exports_103, context_103) {
    "use strict";
    var Sha1Hash;
    var __moduleName = context_103 && context_103.id;
    /*
     * Calculate the SHA-1 of an array of big-endian words, and a bit length
     */
    function binb_sha1(x, len) {
        /* append padding */
        x[len >> 5] |= 0x80 << (24 - (len % 32));
        x[(((len + 64) >> 9) << 4) + 15] = len;
        const w = [];
        let a = 1732584193;
        let b = -271733879;
        let c = -1732584194;
        let d = 271733878;
        let e = -1009589776;
        for (let i = 0; i < x.length; i += 16) {
            const olda = a;
            const oldb = b;
            const oldc = c;
            const oldd = d;
            const olde = e;
            for (let j = 0; j < 80; j++) {
                if (j < 16)
                    w[j] = x[i + j];
                else
                    w[j] = bit_rol(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);
                var t = safe_add(safe_add(bit_rol(a, 5), sha1_ft(j, b, c, d)), safe_add(safe_add(e, w[j]), sha1_kt(j)));
                e = d;
                d = c;
                c = bit_rol(b, 30);
                b = a;
                a = t;
            }
            a = safe_add(a, olda);
            b = safe_add(b, oldb);
            c = safe_add(c, oldc);
            d = safe_add(d, oldd);
            e = safe_add(e, olde);
        }
        return [a, b, c, d, e];
    }
    /*
     * Perform the appropriate triplet combination function for the current
     * iteration
     */
    function sha1_ft(t, b, c, d) {
        if (t < 20)
            return (b & c) | (~b & d);
        if (t < 40)
            return b ^ c ^ d;
        if (t < 60)
            return (b & c) | (b & d) | (c & d);
        return b ^ c ^ d;
    }
    /*
     * Determine the appropriate additive constant for the current iteration
     */
    function sha1_kt(t) {
        return t < 20
            ? 1518500249
            : t < 40
                ? 1859775393
                : t < 60
                    ? -1894007588
                    : -899497514;
    }
    /*
     * Add integers, wrapping at 2^32. This uses 16-bit operations internally
     * to work around bugs in some JS interpreters.
     */
    function safe_add(x, y) {
        const lsw = (x & 0xffff) + (y & 0xffff);
        const msw = (x >> 16) + (y >> 16) + (lsw >> 16);
        return (msw << 16) | (lsw & 0xffff);
    }
    /*
     * Bitwise rotate a 32-bit number to the left.
     */
    function bit_rol(num, cnt) {
        return (num << cnt) | (num >>> (32 - cnt));
    }
    return {
        setters: [],
        execute: function () {
            Sha1Hash = class Sha1Hash {
                digest(bytes) {
                    let data = [];
                    for (var i = 0; i < bytes.length * 8; i += 8) {
                        data[i >> 5] |= (bytes[i / 8] & 0xff) << (24 - (i % 32));
                    }
                    data = binb_sha1(data, bytes.length * 8);
                    return this.toStrBytes(data);
                }
                /*
                 * Convert an array of big-endian words to a string
                 */
                toStrBytes(input) {
                    let pos = 0;
                    const data = new Uint8Array(input.length * 4);
                    for (let i = 0; i < input.length * 32; i += 8) {
                        data[pos++] = (input[i >> 5] >> (24 - (i % 32))) & 0xff;
                    }
                    return data;
                }
            };
            exports_103("Sha1Hash", Sha1Hash);
        }
    };
});
System.register("https://deno.land/x/checksum@1.4.0/md5", [], function (exports_104, context_104) {
    "use strict";
    var Md5Hash;
    var __moduleName = context_104 && context_104.id;
    /*
     * Add integers, wrapping at 2^32. This uses 16-bit operations internally
     * to work around bugs in some JS interpreters.
     */
    function safeAdd(x, y) {
        const lsw = (x & 0xffff) + (y & 0xffff);
        const msw = (x >> 16) + (y >> 16) + (lsw >> 16);
        return (msw << 16) | (lsw & 0xffff);
    }
    /*
     * Bitwise rotate a 32-bit number to the left.
     */
    function bitRotateLeft(num, cnt) {
        return (num << cnt) | (num >>> (32 - cnt));
    }
    /*
     * These functions implement the four basic operations the algorithm uses.
     */
    function md5cmn(q, a, b, x, s, t) {
        return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
    }
    function md5ff(a, b, c, d, x, s, t) {
        return md5cmn((b & c) | (~b & d), a, b, x, s, t);
    }
    function md5gg(a, b, c, d, x, s, t) {
        return md5cmn((b & d) | (c & ~d), a, b, x, s, t);
    }
    function md5hh(a, b, c, d, x, s, t) {
        return md5cmn(b ^ c ^ d, a, b, x, s, t);
    }
    function md5ii(a, b, c, d, x, s, t) {
        return md5cmn(c ^ (b | ~d), a, b, x, s, t);
    }
    /*
     * Calculate the MD5 of an array of little-endian words, and a bit length.
     */
    function binlMD5(x, len) {
        /* append padding */
        x[len >> 5] |= 0x80 << len % 32;
        x[(((len + 64) >>> 9) << 4) + 14] = len;
        let olda, oldb, oldc, oldd;
        let a = 1732584193, b = -271733879, c = -1732584194, d = 271733878;
        for (let i = 0; i < x.length; i += 16) {
            olda = a;
            oldb = b;
            oldc = c;
            oldd = d;
            a = md5ff(a, b, c, d, x[i], 7, -680876936);
            d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
            c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
            b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
            a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
            d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
            c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
            b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
            a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
            d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
            c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
            b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
            a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
            d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
            c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
            b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
            a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
            d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
            c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
            b = md5gg(b, c, d, a, x[i], 20, -373897302);
            a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
            d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
            c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
            b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
            a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
            d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
            c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
            b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
            a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
            d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
            c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
            b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
            a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
            d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
            c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
            b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
            a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
            d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
            c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
            b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
            a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
            d = md5hh(d, a, b, c, x[i], 11, -358537222);
            c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
            b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
            a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
            d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
            c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
            b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
            a = md5ii(a, b, c, d, x[i], 6, -198630844);
            d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
            c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
            b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
            a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
            d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
            c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
            b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
            a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
            d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
            c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
            b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
            a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
            d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
            c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
            b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
            a = safeAdd(a, olda);
            b = safeAdd(b, oldb);
            c = safeAdd(c, oldc);
            d = safeAdd(d, oldd);
        }
        return [a, b, c, d];
    }
    function md5(bytes) {
        let data = [];
        var length8 = bytes.length * 8;
        for (let i = 0; i < length8; i += 8) {
            data[i >> 5] |= (bytes[i / 8] & 0xff) << i % 32;
        }
        return binlMD5(data, bytes.length * 8);
    }
    return {
        setters: [],
        execute: function () {
            Md5Hash = class Md5Hash {
                digest(bytes) {
                    const data = md5(bytes);
                    return this.toStrBytes(data);
                }
                toStrBytes(input) {
                    const buffer = new ArrayBuffer(16);
                    new Uint32Array(buffer).set(input);
                    return new Uint8Array(buffer);
                }
            };
            exports_104("Md5Hash", Md5Hash);
        }
    };
});
System.register("https://deno.land/x/checksum@1.4.0/hash", ["https://deno.land/x/checksum@1.4.0/sha1", "https://deno.land/x/checksum@1.4.0/md5"], function (exports_105, context_105) {
    "use strict";
    var sha1_ts_3, md5_ts_1, encoder, Hash;
    var __moduleName = context_105 && context_105.id;
    function hex(bytes) {
        return Array.prototype.map
            .call(bytes, (x) => x.toString(16).padStart(2, "0"))
            .join("");
    }
    exports_105("hex", hex);
    function encode(str) {
        return encoder.encode(str);
    }
    exports_105("encode", encode);
    return {
        setters: [
            function (sha1_ts_3_1) {
                sha1_ts_3 = sha1_ts_3_1;
            },
            function (md5_ts_1_1) {
                md5_ts_1 = md5_ts_1_1;
            }
        ],
        execute: function () {
            encoder = new TextEncoder();
            Hash = class Hash {
                constructor(algorithm) {
                    this.algorithm = algorithm;
                    const algorithms = {
                        sha1: sha1_ts_3.Sha1Hash,
                        md5: md5_ts_1.Md5Hash,
                    };
                    this.instance = new algorithms[algorithm]();
                }
                digest(bytes) {
                    bytes = this.instance.digest(bytes);
                    return {
                        data: bytes,
                        hex: () => hex(bytes),
                    };
                }
                digestString(string) {
                    return this.digest(encode(string));
                }
            };
            exports_105("Hash", Hash);
        }
    };
});
System.register("https://deno.land/x/checksum@1.4.0/mod", ["https://deno.land/x/checksum@1.4.0/hash"], function (exports_106, context_106) {
    "use strict";
    var __moduleName = context_106 && context_106.id;
    return {
        setters: [
            function (hash_ts_1_1) {
                exports_106({
                    "Hash": hash_ts_1_1["Hash"],
                    "hex": hash_ts_1_1["hex"],
                    "encode": hash_ts_1_1["encode"]
                });
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/base64/base", [], function (exports_107, context_107) {
    "use strict";
    var __moduleName = context_107 && context_107.id;
    function getLengths(b64) {
        const len = b64.length;
        if (len % 4 > 0) {
            throw new TypeError("Invalid string. Length must be a multiple of 4");
        }
        // Trim off extra bytes after placeholder bytes are found
        // See: https://github.com/beatgammit/base64-js/issues/42
        let validLen = b64.indexOf("=");
        if (validLen === -1) {
            validLen = len;
        }
        const placeHoldersLen = validLen === len ? 0 : 4 - (validLen % 4);
        return [validLen, placeHoldersLen];
    }
    function init(lookup, revLookup) {
        function _byteLength(validLen, placeHoldersLen) {
            return ((validLen + placeHoldersLen) * 3) / 4 - placeHoldersLen;
        }
        function tripletToBase64(num) {
            return (lookup[(num >> 18) & 0x3f] +
                lookup[(num >> 12) & 0x3f] +
                lookup[(num >> 6) & 0x3f] +
                lookup[num & 0x3f]);
        }
        function encodeChunk(buf, start, end) {
            const out = new Array((end - start) / 3);
            for (let i = start, curTriplet = 0; i < end; i += 3) {
                out[curTriplet++] = tripletToBase64((buf[i] << 16) + (buf[i + 1] << 8) + buf[i + 2]);
            }
            return out.join("");
        }
        return {
            // base64 is 4/3 + up to two characters of the original data
            byteLength(b64) {
                return _byteLength.apply(null, getLengths(b64));
            },
            toUint8Array(b64) {
                const [validLen, placeHoldersLen] = getLengths(b64);
                const buf = new Uint8Array(_byteLength(validLen, placeHoldersLen));
                // If there are placeholders, only get up to the last complete 4 chars
                const len = placeHoldersLen ? validLen - 4 : validLen;
                let tmp;
                let curByte = 0;
                let i;
                for (i = 0; i < len; i += 4) {
                    tmp =
                        (revLookup[b64.charCodeAt(i)] << 18) |
                            (revLookup[b64.charCodeAt(i + 1)] << 12) |
                            (revLookup[b64.charCodeAt(i + 2)] << 6) |
                            revLookup[b64.charCodeAt(i + 3)];
                    buf[curByte++] = (tmp >> 16) & 0xff;
                    buf[curByte++] = (tmp >> 8) & 0xff;
                    buf[curByte++] = tmp & 0xff;
                }
                if (placeHoldersLen === 2) {
                    tmp =
                        (revLookup[b64.charCodeAt(i)] << 2) |
                            (revLookup[b64.charCodeAt(i + 1)] >> 4);
                    buf[curByte++] = tmp & 0xff;
                }
                else if (placeHoldersLen === 1) {
                    tmp =
                        (revLookup[b64.charCodeAt(i)] << 10) |
                            (revLookup[b64.charCodeAt(i + 1)] << 4) |
                            (revLookup[b64.charCodeAt(i + 2)] >> 2);
                    buf[curByte++] = (tmp >> 8) & 0xff;
                    buf[curByte++] = tmp & 0xff;
                }
                return buf;
            },
            fromUint8Array(buf) {
                const maxChunkLength = 16383; // Must be multiple of 3
                const len = buf.length;
                const extraBytes = len % 3; // If we have 1 byte left, pad 2 bytes
                const len2 = len - extraBytes;
                const parts = new Array(Math.ceil(len2 / maxChunkLength) + (extraBytes ? 1 : 0));
                let curChunk = 0;
                let chunkEnd;
                // Go through the array every three bytes, we'll deal with trailing stuff later
                for (let i = 0; i < len2; i += maxChunkLength) {
                    chunkEnd = i + maxChunkLength;
                    parts[curChunk++] = encodeChunk(buf, i, chunkEnd > len2 ? len2 : chunkEnd);
                }
                let tmp;
                // Pad the end with zeros, but make sure to not forget the extra bytes
                if (extraBytes === 1) {
                    tmp = buf[len2];
                    parts[curChunk] = lookup[tmp >> 2] + lookup[(tmp << 4) & 0x3f] + "==";
                }
                else if (extraBytes === 2) {
                    tmp = (buf[len2] << 8) | (buf[len2 + 1] & 0xff);
                    parts[curChunk] =
                        lookup[tmp >> 10] +
                            lookup[(tmp >> 4) & 0x3f] +
                            lookup[(tmp << 2) & 0x3f] +
                            "=";
                }
                return parts.join("");
            }
        };
    }
    exports_107("init", init);
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/base64/base64url", ["https://deno.land/x/base64/base"], function (exports_108, context_108) {
    "use strict";
    var base_ts_1, lookup, revLookup, code, mod, byteLength, toUint8Array, fromUint8Array;
    var __moduleName = context_108 && context_108.id;
    return {
        setters: [
            function (base_ts_1_1) {
                base_ts_1 = base_ts_1_1;
            }
        ],
        execute: function () {
            lookup = [];
            revLookup = [];
            code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
            for (let i = 0, l = code.length; i < l; ++i) {
                lookup[i] = code[i];
                revLookup[code.charCodeAt(i)] = i;
            }
            revLookup["-".charCodeAt(0)] = 62;
            revLookup["_".charCodeAt(0)] = 63;
            mod = base_ts_1.init(lookup, revLookup);
            exports_108("byteLength", byteLength = mod.byteLength);
            exports_108("toUint8Array", toUint8Array = mod.toUint8Array);
            exports_108("fromUint8Array", fromUint8Array = mod.fromUint8Array);
        }
    };
});
System.register("https://raw.githubusercontent.com/chiefbiiko/std-encoding/v1.0.0/mod", ["https://deno.land/x/base64/base64url"], function (exports_109, context_109) {
    "use strict";
    var base64url_ts_1, decoder, encoder;
    var __moduleName = context_109 && context_109.id;
    /** Serializes a Uint8Array to a hexadecimal string. */
    function toHexString(buf) {
        return buf.reduce((hex, byte) => `${hex}${byte < 16 ? "0" : ""}${byte.toString(16)}`, "");
    }
    /** Deserializes a Uint8Array from a hexadecimal string. */
    function fromHexString(hex) {
        const len = hex.length;
        if (len % 2 || !/^[0-9a-fA-F]+$/.test(hex)) {
            throw new TypeError("Invalid hex string.");
        }
        hex = hex.toLowerCase();
        const buf = new Uint8Array(Math.floor(len / 2));
        const end = len / 2;
        for (let i = 0; i < end; ++i) {
            buf[i] = parseInt(hex.substr(i * 2, 2), 16);
        }
        return buf;
    }
    /** Decodes a Uint8Array to utf8-, base64-, or hex-encoded string. */
    function decode(buf, encoding = "utf8") {
        if (/^utf-?8$/i.test(encoding)) {
            return decoder.decode(buf);
        }
        else if (/^base64$/i.test(encoding)) {
            return base64url_ts_1.fromUint8Array(buf);
        }
        else if (/^hex(?:adecimal)?$/i.test(encoding)) {
            return toHexString(buf);
        }
        else {
            throw new TypeError("Unsupported string encoding.");
        }
    }
    exports_109("decode", decode);
    function encode(str, encoding = "utf8") {
        if (/^utf-?8$/i.test(encoding)) {
            return encoder.encode(str);
        }
        else if (/^base64$/i.test(encoding)) {
            return base64url_ts_1.toUint8Array(str);
        }
        else if (/^hex(?:adecimal)?$/i.test(encoding)) {
            return fromHexString(str);
        }
        else {
            throw new TypeError("Unsupported string encoding.");
        }
    }
    exports_109("encode", encode);
    return {
        setters: [
            function (base64url_ts_1_1) {
                base64url_ts_1 = base64url_ts_1_1;
            }
        ],
        execute: function () {
            decoder = new TextDecoder();
            encoder = new TextEncoder();
        }
    };
});
System.register("https://deno.land/x/sha256@v1.0.2/deps", ["https://raw.githubusercontent.com/chiefbiiko/std-encoding/v1.0.0/mod"], function (exports_110, context_110) {
    "use strict";
    var __moduleName = context_110 && context_110.id;
    return {
        setters: [
            function (mod_ts_16_1) {
                exports_110({
                    "encode": mod_ts_16_1["encode"],
                    "decode": mod_ts_16_1["decode"]
                });
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/sha256@v1.0.2/mod", ["https://deno.land/x/sha256@v1.0.2/deps"], function (exports_111, context_111) {
    "use strict";
    var deps_ts_18, BYTES, SHA256;
    var __moduleName = context_111 && context_111.id;
    /** Generates a SHA256 hash of the input data. */
    function sha256(msg, inputEncoding, outputEncoding) {
        return new SHA256().update(msg, inputEncoding).digest(outputEncoding);
    }
    exports_111("sha256", sha256);
    return {
        setters: [
            function (deps_ts_18_1) {
                deps_ts_18 = deps_ts_18_1;
            }
        ],
        execute: function () {
            /** Byte length of a SHA256 hash. */
            exports_111("BYTES", BYTES = 32);
            /** A class representation of the SHA256 algorithm. */
            SHA256 = class SHA256 {
                /** Creates a SHA256 instance. */
                constructor() {
                    this.hashSize = BYTES;
                    this._buf = new Uint8Array(64);
                    // prettier-ignore
                    this._K = new Uint32Array([
                        0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
                        0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
                        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
                        0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
                        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
                        0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
                        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
                        0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
                        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
                        0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
                        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
                        0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
                        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
                        0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
                        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
                        0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
                    ]);
                    this.init();
                }
                /** Initializes a hash. */
                init() {
                    // prettier-ignore
                    this._H = new Uint32Array([
                        0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
                        0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
                    ]);
                    this._bufIdx = 0;
                    this._count = new Uint32Array(2);
                    this._buf.fill(0);
                    this._finalized = false;
                    return this;
                }
                /** Updates the hash with additional message data. */
                update(msg, inputEncoding) {
                    if (msg === null) {
                        throw new TypeError("msg must be a string or Uint8Array.");
                    }
                    else if (typeof msg === "string") {
                        msg = deps_ts_18.encode(msg, inputEncoding);
                    }
                    // process the msg as many times as possible, the rest is stored in the buffer
                    // message is processed in 512 bit (64 byte chunks)
                    for (let i = 0, len = msg.length; i < len; i++) {
                        this._buf[this._bufIdx++] = msg[i];
                        if (this._bufIdx === 64) {
                            this._transform();
                            this._bufIdx = 0;
                        }
                    }
                    // counter update (number of message bits)
                    const c = this._count;
                    if ((c[0] += msg.length << 3) < msg.length << 3) {
                        c[1]++;
                    }
                    c[1] += msg.length >>> 29;
                    return this;
                }
                /** Finalizes the hash with additional message data. */
                digest(outputEncoding) {
                    if (this._finalized) {
                        throw new Error("digest has already been called.");
                    }
                    this._finalized = true;
                    // append '1'
                    const b = this._buf;
                    let idx = this._bufIdx;
                    b[idx++] = 0x80;
                    // zeropad up to byte pos 56
                    while (idx !== 56) {
                        if (idx === 64) {
                            this._transform();
                            idx = 0;
                        }
                        b[idx++] = 0;
                    }
                    // append length in bits
                    const c = this._count;
                    b[56] = (c[1] >>> 24) & 0xff;
                    b[57] = (c[1] >>> 16) & 0xff;
                    b[58] = (c[1] >>> 8) & 0xff;
                    b[59] = (c[1] >>> 0) & 0xff;
                    b[60] = (c[0] >>> 24) & 0xff;
                    b[61] = (c[0] >>> 16) & 0xff;
                    b[62] = (c[0] >>> 8) & 0xff;
                    b[63] = (c[0] >>> 0) & 0xff;
                    this._transform();
                    // return the hash as byte array
                    const hash = new Uint8Array(BYTES);
                    // let i: number;
                    for (let i = 0; i < 8; i++) {
                        hash[(i << 2) + 0] = (this._H[i] >>> 24) & 0xff;
                        hash[(i << 2) + 1] = (this._H[i] >>> 16) & 0xff;
                        hash[(i << 2) + 2] = (this._H[i] >>> 8) & 0xff;
                        hash[(i << 2) + 3] = (this._H[i] >>> 0) & 0xff;
                    }
                    // clear internal states and prepare for new hash
                    this.init();
                    return outputEncoding ? deps_ts_18.decode(hash, outputEncoding) : hash;
                }
                /** Performs one transformation cycle. */
                _transform() {
                    const h = this._H;
                    let h0 = h[0];
                    let h1 = h[1];
                    let h2 = h[2];
                    let h3 = h[3];
                    let h4 = h[4];
                    let h5 = h[5];
                    let h6 = h[6];
                    let h7 = h[7];
                    // convert byte buffer into w[0..15]
                    const w = new Uint32Array(16);
                    let i;
                    for (i = 0; i < 16; i++) {
                        w[i] =
                            this._buf[(i << 2) + 3] |
                                (this._buf[(i << 2) + 2] << 8) |
                                (this._buf[(i << 2) + 1] << 16) |
                                (this._buf[i << 2] << 24);
                    }
                    for (i = 0; i < 64; i++) {
                        let tmp;
                        if (i < 16) {
                            tmp = w[i];
                        }
                        else {
                            let a = w[(i + 1) & 15];
                            let b = w[(i + 14) & 15];
                            tmp = w[i & 15] =
                                (((a >>> 7) ^ (a >>> 18) ^ (a >>> 3) ^ (a << 25) ^ (a << 14)) +
                                    ((b >>> 17) ^ (b >>> 19) ^ (b >>> 10) ^ (b << 15) ^ (b << 13)) +
                                    w[i & 15] +
                                    w[(i + 9) & 15]) |
                                    0;
                        }
                        tmp =
                            (tmp +
                                h7 +
                                ((h4 >>> 6) ^
                                    (h4 >>> 11) ^
                                    (h4 >>> 25) ^
                                    (h4 << 26) ^
                                    (h4 << 21) ^
                                    (h4 << 7)) +
                                (h6 ^ (h4 & (h5 ^ h6))) +
                                this._K[i]) |
                                0;
                        h7 = h6;
                        h6 = h5;
                        h5 = h4;
                        h4 = h3 + tmp;
                        h3 = h2;
                        h2 = h1;
                        h1 = h0;
                        h0 =
                            (tmp +
                                ((h1 & h2) ^ (h3 & (h1 ^ h2))) +
                                ((h1 >>> 2) ^
                                    (h1 >>> 13) ^
                                    (h1 >>> 22) ^
                                    (h1 << 30) ^
                                    (h1 << 19) ^
                                    (h1 << 10))) |
                                0;
                    }
                    h[0] = (h[0] + h0) | 0;
                    h[1] = (h[1] + h1) | 0;
                    h[2] = (h[2] + h2) | 0;
                    h[3] = (h[3] + h3) | 0;
                    h[4] = (h[4] + h4) | 0;
                    h[5] = (h[5] + h5) | 0;
                    h[6] = (h[6] + h6) | 0;
                    h[7] = (h[7] + h7) | 0;
                }
            };
            exports_111("SHA256", SHA256);
        }
    };
});
System.register("https://deno.land/x/sql_builder@1.3.5/util", [], function (exports_112, context_112) {
    "use strict";
    var __moduleName = context_112 && context_112.id;
    function replaceParams(sql, params) {
        if (!params)
            return sql;
        let paramIndex = 0;
        sql = sql.replace(/('.*')|(".*")|(\?\?)|(\?)/g, str => {
            if (paramIndex >= params.length)
                return str;
            // ignore
            if (/".*"/g.test(str) || /'.*'/g.test(str)) {
                return str;
            }
            // identifier
            if (str === "??") {
                const val = params[paramIndex++];
                if (val instanceof Array) {
                    return `(${val.map(item => replaceParams("??", [item])).join(",")})`;
                }
                else if (val === "*") {
                    return val;
                }
                else if (typeof val === "string" && val.indexOf(".") > -1) {
                    // a.b => `a`.`b`
                    const _arr = val.split(".");
                    return replaceParams(_arr.map(() => "??").join("."), _arr);
                }
                else if (typeof val === "string" &&
                    (val.toLowerCase().indexOf(" as ") > -1 ||
                        val.toLowerCase().indexOf(" AS ") > -1)) {
                    // a as b => `a` AS `b`
                    const newVal = val.replace(" as ", " AS ");
                    const _arr = newVal.split(" AS ");
                    return replaceParams(_arr.map(() => "??").join(" AS "), _arr);
                }
                else {
                    return ["`", val, "`"].join("");
                }
            }
            // value
            const val = params[paramIndex++];
            if (val === null)
                return "NULL";
            switch (typeof val) {
                case "object":
                    if (val instanceof Date)
                        return `"${formatDate(val)}"`;
                    if (val instanceof Array) {
                        return `(${val.map(item => replaceParams("?", [item])).join(",")})`;
                    }
                case "string":
                    return `"${escapeString(val)}"`;
                case "undefined":
                    return "NULL";
                case "number":
                case "boolean":
                default:
                    return val;
            }
        });
        return sql;
    }
    exports_112("replaceParams", replaceParams);
    function formatDate(date) {
        const year = date.getFullYear();
        const month = (date.getMonth() + 1).toString().padStart(2, "0");
        const days = date
            .getDate()
            .toString()
            .padStart(2, "0");
        const hours = date
            .getHours()
            .toString()
            .padStart(2, "0");
        const minutes = date
            .getMinutes()
            .toString()
            .padStart(2, "0");
        const seconds = date
            .getSeconds()
            .toString()
            .padStart(2, "0");
        return `${year}-${month}-${days} ${hours}:${minutes}:${seconds}`;
    }
    function escapeString(str) {
        return str.replace(/"/g, '\\"');
    }
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/std@v0.51.0/log/levels", [], function (exports_113, context_113) {
    "use strict";
    var LogLevels, LogLevelNames, byLevel;
    var __moduleName = context_113 && context_113.id;
    /** Returns the numeric log level associated with the passed,
     * stringy log level name.
     */
    function getLevelByName(name) {
        switch (name) {
            case "NOTSET":
                return LogLevels.NOTSET;
            case "DEBUG":
                return LogLevels.DEBUG;
            case "INFO":
                return LogLevels.INFO;
            case "WARNING":
                return LogLevels.WARNING;
            case "ERROR":
                return LogLevels.ERROR;
            case "CRITICAL":
                return LogLevels.CRITICAL;
            default:
                throw new Error(`no log level found for "${name}"`);
        }
    }
    exports_113("getLevelByName", getLevelByName);
    /** Returns the stringy log level name provided the numeric log level */
    function getLevelName(level) {
        const levelName = byLevel[level];
        if (levelName) {
            return levelName;
        }
        throw new Error(`no level name found for level: ${level}`);
    }
    exports_113("getLevelName", getLevelName);
    return {
        setters: [],
        execute: function () {
            // Copyright 2018-2020 the Deno authors. All rights reserved. MIT license.
            /** Get log level numeric values through enum constants
             */
            (function (LogLevels) {
                LogLevels[LogLevels["NOTSET"] = 0] = "NOTSET";
                LogLevels[LogLevels["DEBUG"] = 10] = "DEBUG";
                LogLevels[LogLevels["INFO"] = 20] = "INFO";
                LogLevels[LogLevels["WARNING"] = 30] = "WARNING";
                LogLevels[LogLevels["ERROR"] = 40] = "ERROR";
                LogLevels[LogLevels["CRITICAL"] = 50] = "CRITICAL";
            })(LogLevels || (LogLevels = {}));
            exports_113("LogLevels", LogLevels);
            /** Permitted log level names */
            exports_113("LogLevelNames", LogLevelNames = Object.keys(LogLevels).filter((key) => isNaN(Number(key))));
            byLevel = {
                [String(LogLevels.NOTSET)]: "NOTSET",
                [String(LogLevels.DEBUG)]: "DEBUG",
                [String(LogLevels.INFO)]: "INFO",
                [String(LogLevels.WARNING)]: "WARNING",
                [String(LogLevels.ERROR)]: "ERROR",
                [String(LogLevels.CRITICAL)]: "CRITICAL",
            };
        }
    };
});
System.register("https://deno.land/x/std@v0.51.0/fmt/colors", [], function (exports_114, context_114) {
    "use strict";
    var noColor, enabled;
    var __moduleName = context_114 && context_114.id;
    function setColorEnabled(value) {
        if (noColor) {
            return;
        }
        enabled = value;
    }
    exports_114("setColorEnabled", setColorEnabled);
    function getColorEnabled() {
        return enabled;
    }
    exports_114("getColorEnabled", getColorEnabled);
    function code(open, close) {
        return {
            open: `\x1b[${open.join(";")}m`,
            close: `\x1b[${close}m`,
            regexp: new RegExp(`\\x1b\\[${close}m`, "g"),
        };
    }
    function run(str, code) {
        return enabled
            ? `${code.open}${str.replace(code.regexp, code.open)}${code.close}`
            : str;
    }
    function reset(str) {
        return run(str, code([0], 0));
    }
    exports_114("reset", reset);
    function bold(str) {
        return run(str, code([1], 22));
    }
    exports_114("bold", bold);
    function dim(str) {
        return run(str, code([2], 22));
    }
    exports_114("dim", dim);
    function italic(str) {
        return run(str, code([3], 23));
    }
    exports_114("italic", italic);
    function underline(str) {
        return run(str, code([4], 24));
    }
    exports_114("underline", underline);
    function inverse(str) {
        return run(str, code([7], 27));
    }
    exports_114("inverse", inverse);
    function hidden(str) {
        return run(str, code([8], 28));
    }
    exports_114("hidden", hidden);
    function strikethrough(str) {
        return run(str, code([9], 29));
    }
    exports_114("strikethrough", strikethrough);
    function black(str) {
        return run(str, code([30], 39));
    }
    exports_114("black", black);
    function red(str) {
        return run(str, code([31], 39));
    }
    exports_114("red", red);
    function green(str) {
        return run(str, code([32], 39));
    }
    exports_114("green", green);
    function yellow(str) {
        return run(str, code([33], 39));
    }
    exports_114("yellow", yellow);
    function blue(str) {
        return run(str, code([34], 39));
    }
    exports_114("blue", blue);
    function magenta(str) {
        return run(str, code([35], 39));
    }
    exports_114("magenta", magenta);
    function cyan(str) {
        return run(str, code([36], 39));
    }
    exports_114("cyan", cyan);
    function white(str) {
        return run(str, code([37], 39));
    }
    exports_114("white", white);
    function gray(str) {
        return run(str, code([90], 39));
    }
    exports_114("gray", gray);
    function bgBlack(str) {
        return run(str, code([40], 49));
    }
    exports_114("bgBlack", bgBlack);
    function bgRed(str) {
        return run(str, code([41], 49));
    }
    exports_114("bgRed", bgRed);
    function bgGreen(str) {
        return run(str, code([42], 49));
    }
    exports_114("bgGreen", bgGreen);
    function bgYellow(str) {
        return run(str, code([43], 49));
    }
    exports_114("bgYellow", bgYellow);
    function bgBlue(str) {
        return run(str, code([44], 49));
    }
    exports_114("bgBlue", bgBlue);
    function bgMagenta(str) {
        return run(str, code([45], 49));
    }
    exports_114("bgMagenta", bgMagenta);
    function bgCyan(str) {
        return run(str, code([46], 49));
    }
    exports_114("bgCyan", bgCyan);
    function bgWhite(str) {
        return run(str, code([47], 49));
    }
    exports_114("bgWhite", bgWhite);
    /* Special Color Sequences */
    function clampAndTruncate(n, max = 255, min = 0) {
        return Math.trunc(Math.max(Math.min(n, max), min));
    }
    /** Set text color using paletted 8bit colors.
     * https://en.wikipedia.org/wiki/ANSI_escape_code#8-bit */
    function rgb8(str, color) {
        return run(str, code([38, 5, clampAndTruncate(color)], 39));
    }
    exports_114("rgb8", rgb8);
    /** Set background color using paletted 8bit colors.
     * https://en.wikipedia.org/wiki/ANSI_escape_code#8-bit */
    function bgRgb8(str, color) {
        return run(str, code([48, 5, clampAndTruncate(color)], 49));
    }
    exports_114("bgRgb8", bgRgb8);
    /** Set text color using 24bit rgb. */
    function rgb24(str, color) {
        return run(str, code([
            38,
            2,
            clampAndTruncate(color.r),
            clampAndTruncate(color.g),
            clampAndTruncate(color.b),
        ], 39));
    }
    exports_114("rgb24", rgb24);
    /** Set background color using 24bit rgb. */
    function bgRgb24(str, color) {
        return run(str, code([
            48,
            2,
            clampAndTruncate(color.r),
            clampAndTruncate(color.g),
            clampAndTruncate(color.b),
        ], 49));
    }
    exports_114("bgRgb24", bgRgb24);
    return {
        setters: [],
        execute: function () {
            // Copyright 2018-2020 the Deno authors. All rights reserved. MIT license.
            /**
             * A module to print ANSI terminal colors. Inspired by chalk, kleur, and colors
             * on npm.
             *
             * ```
             * import { bgBlue, red, bold } from "https://deno.land/std/fmt/colors.ts";
             * console.log(bgBlue(red(bold("Hello world!"))));
             * ```
             *
             * This module supports `NO_COLOR` environmental variable disabling any coloring
             * if `NO_COLOR` is set.
             */
            noColor = Deno.noColor;
            enabled = !noColor;
        }
    };
});
System.register("https://deno.land/x/std@v0.51.0/fs/exists", [], function (exports_115, context_115) {
    "use strict";
    var lstat, lstatSync;
    var __moduleName = context_115 && context_115.id;
    /**
     * Test whether or not the given path exists by checking with the file system
     */
    async function exists(filePath) {
        try {
            await lstat(filePath);
            return true;
        }
        catch (err) {
            if (err instanceof Deno.errors.NotFound) {
                return false;
            }
            throw err;
        }
    }
    exports_115("exists", exists);
    /**
     * Test whether or not the given path exists by checking with the file system
     */
    function existsSync(filePath) {
        try {
            lstatSync(filePath);
            return true;
        }
        catch (err) {
            if (err instanceof Deno.errors.NotFound) {
                return false;
            }
            throw err;
        }
    }
    exports_115("existsSync", existsSync);
    return {
        setters: [],
        execute: function () {
            // Copyright 2018-2020 the Deno authors. All rights reserved. MIT license.
            lstat = Deno.lstat, lstatSync = Deno.lstatSync;
        }
    };
});
System.register("https://deno.land/x/std@v0.51.0/log/handlers", ["https://deno.land/x/std@v0.51.0/log/levels", "https://deno.land/x/std@v0.51.0/fmt/colors", "https://deno.land/x/std@v0.51.0/fs/exists"], function (exports_116, context_116) {
    "use strict";
    var open, openSync, close, renameSync, statSync, levels_ts_1, colors_ts_4, exists_ts_5, DEFAULT_FORMATTER, BaseHandler, ConsoleHandler, WriterHandler, FileHandler, RotatingFileHandler;
    var __moduleName = context_116 && context_116.id;
    return {
        setters: [
            function (levels_ts_1_1) {
                levels_ts_1 = levels_ts_1_1;
            },
            function (colors_ts_4_1) {
                colors_ts_4 = colors_ts_4_1;
            },
            function (exists_ts_5_1) {
                exists_ts_5 = exists_ts_5_1;
            }
        ],
        execute: function () {
            // Copyright 2018-2020 the Deno authors. All rights reserved. MIT license.
            open = Deno.open, openSync = Deno.openSync, close = Deno.close, renameSync = Deno.renameSync, statSync = Deno.statSync;
            DEFAULT_FORMATTER = "{levelName} {msg}";
            BaseHandler = class BaseHandler {
                constructor(levelName, options = {}) {
                    this.level = levels_ts_1.getLevelByName(levelName);
                    this.levelName = levelName;
                    this.formatter = options.formatter || DEFAULT_FORMATTER;
                }
                handle(logRecord) {
                    if (this.level > logRecord.level)
                        return;
                    const msg = this.format(logRecord);
                    return this.log(msg);
                }
                format(logRecord) {
                    if (this.formatter instanceof Function) {
                        return this.formatter(logRecord);
                    }
                    return this.formatter.replace(/{(\S+)}/g, (match, p1) => {
                        const value = logRecord[p1];
                        // do not interpolate missing values
                        if (!value) {
                            return match;
                        }
                        return String(value);
                    });
                }
                log(_msg) { }
                async setup() { }
                async destroy() { }
            };
            exports_116("BaseHandler", BaseHandler);
            ConsoleHandler = class ConsoleHandler extends BaseHandler {
                format(logRecord) {
                    let msg = super.format(logRecord);
                    switch (logRecord.level) {
                        case levels_ts_1.LogLevels.INFO:
                            msg = colors_ts_4.blue(msg);
                            break;
                        case levels_ts_1.LogLevels.WARNING:
                            msg = colors_ts_4.yellow(msg);
                            break;
                        case levels_ts_1.LogLevels.ERROR:
                            msg = colors_ts_4.red(msg);
                            break;
                        case levels_ts_1.LogLevels.CRITICAL:
                            msg = colors_ts_4.bold(colors_ts_4.red(msg));
                            break;
                        default:
                            break;
                    }
                    return msg;
                }
                log(msg) {
                    console.log(msg);
                }
            };
            exports_116("ConsoleHandler", ConsoleHandler);
            WriterHandler = class WriterHandler extends BaseHandler {
                constructor() {
                    super(...arguments);
                    this.#encoder = new TextEncoder();
                }
                #encoder;
            };
            exports_116("WriterHandler", WriterHandler);
            FileHandler = class FileHandler extends WriterHandler {
                constructor(levelName, options) {
                    super(levelName, options);
                    this.#encoder = new TextEncoder();
                    this._filename = options.filename;
                    // default to append mode, write only
                    this._mode = options.mode ? options.mode : "a";
                    this._openOptions = {
                        createNew: this._mode === "x",
                        create: this._mode !== "x",
                        append: this._mode === "a",
                        truncate: this._mode !== "a",
                        write: true,
                    };
                }
                #encoder;
                async setup() {
                    this._file = await open(this._filename, this._openOptions);
                    this._writer = this._file;
                }
                log(msg) {
                    Deno.writeSync(this._file.rid, this.#encoder.encode(msg + "\n"));
                }
                destroy() {
                    this._file.close();
                    return Promise.resolve();
                }
            };
            exports_116("FileHandler", FileHandler);
            RotatingFileHandler = class RotatingFileHandler extends FileHandler {
                constructor(levelName, options) {
                    super(levelName, options);
                    this.#maxBytes = options.maxBytes;
                    this.#maxBackupCount = options.maxBackupCount;
                }
                #maxBytes;
                #maxBackupCount;
                async setup() {
                    if (this.#maxBytes < 1) {
                        throw new Error("maxBytes cannot be less than 1");
                    }
                    if (this.#maxBackupCount < 1) {
                        throw new Error("maxBackupCount cannot be less than 1");
                    }
                    await super.setup();
                    if (this._mode === "w") {
                        // Remove old backups too as it doesn't make sense to start with a clean
                        // log file, but old backups
                        for (let i = 1; i <= this.#maxBackupCount; i++) {
                            if (await exists_ts_5.exists(this._filename + "." + i)) {
                                await Deno.remove(this._filename + "." + i);
                            }
                        }
                    }
                    else if (this._mode === "x") {
                        // Throw if any backups also exist
                        for (let i = 1; i <= this.#maxBackupCount; i++) {
                            if (await exists_ts_5.exists(this._filename + "." + i)) {
                                Deno.close(this._file.rid);
                                throw new Deno.errors.AlreadyExists("Backup log file " + this._filename + "." + i + " already exists");
                            }
                        }
                    }
                }
                handle(logRecord) {
                    if (this.level > logRecord.level)
                        return;
                    const msg = this.format(logRecord);
                    const currentFileSize = statSync(this._filename).size;
                    if (currentFileSize + msg.length > this.#maxBytes) {
                        this.rotateLogFiles();
                    }
                    return this.log(msg);
                }
                rotateLogFiles() {
                    close(this._file.rid);
                    for (let i = this.#maxBackupCount - 1; i >= 0; i--) {
                        const source = this._filename + (i === 0 ? "" : "." + i);
                        const dest = this._filename + "." + (i + 1);
                        if (exists_ts_5.existsSync(source)) {
                            renameSync(source, dest);
                        }
                    }
                    this._file = openSync(this._filename, this._openOptions);
                    this._writer = this._file;
                }
            };
            exports_116("RotatingFileHandler", RotatingFileHandler);
        }
    };
});
System.register("https://deno.land/x/std@v0.51.0/log/logger", ["https://deno.land/x/std@v0.51.0/log/levels"], function (exports_117, context_117) {
    "use strict";
    var levels_ts_2, LogRecord, Logger;
    var __moduleName = context_117 && context_117.id;
    return {
        setters: [
            function (levels_ts_2_1) {
                levels_ts_2 = levels_ts_2_1;
            }
        ],
        execute: function () {
            LogRecord = class LogRecord {
                constructor(msg, args, level) {
                    this.msg = msg;
                    this.#args = [...args];
                    this.level = level;
                    this.#datetime = new Date();
                    this.levelName = levels_ts_2.getLevelName(level);
                }
                #args;
                #datetime;
                get args() {
                    return [...this.#args];
                }
                get datetime() {
                    return new Date(this.#datetime.getTime());
                }
            };
            exports_117("LogRecord", LogRecord);
            Logger = class Logger {
                constructor(levelName, handlers) {
                    this.level = levels_ts_2.getLevelByName(levelName);
                    this.levelName = levelName;
                    this.handlers = handlers || [];
                }
                _log(level, msg, ...args) {
                    if (this.level > level)
                        return;
                    const record = new LogRecord(msg, args, level);
                    this.handlers.forEach((handler) => {
                        handler.handle(record);
                    });
                }
                debug(msg, ...args) {
                    this._log(levels_ts_2.LogLevels.DEBUG, msg, ...args);
                }
                info(msg, ...args) {
                    this._log(levels_ts_2.LogLevels.INFO, msg, ...args);
                }
                warning(msg, ...args) {
                    this._log(levels_ts_2.LogLevels.WARNING, msg, ...args);
                }
                error(msg, ...args) {
                    this._log(levels_ts_2.LogLevels.ERROR, msg, ...args);
                }
                critical(msg, ...args) {
                    this._log(levels_ts_2.LogLevels.CRITICAL, msg, ...args);
                }
            };
            exports_117("Logger", Logger);
        }
    };
});
System.register("https://deno.land/x/std@v0.51.0/testing/diff", [], function (exports_118, context_118) {
    "use strict";
    var DiffType, REMOVED, COMMON, ADDED;
    var __moduleName = context_118 && context_118.id;
    function createCommon(A, B, reverse) {
        const common = [];
        if (A.length === 0 || B.length === 0)
            return [];
        for (let i = 0; i < Math.min(A.length, B.length); i += 1) {
            if (A[reverse ? A.length - i - 1 : i] === B[reverse ? B.length - i - 1 : i]) {
                common.push(A[reverse ? A.length - i - 1 : i]);
            }
            else {
                return common;
            }
        }
        return common;
    }
    function diff(A, B) {
        const prefixCommon = createCommon(A, B);
        const suffixCommon = createCommon(A.slice(prefixCommon.length), B.slice(prefixCommon.length), true).reverse();
        A = suffixCommon.length
            ? A.slice(prefixCommon.length, -suffixCommon.length)
            : A.slice(prefixCommon.length);
        B = suffixCommon.length
            ? B.slice(prefixCommon.length, -suffixCommon.length)
            : B.slice(prefixCommon.length);
        const swapped = B.length > A.length;
        [A, B] = swapped ? [B, A] : [A, B];
        const M = A.length;
        const N = B.length;
        if (!M && !N && !suffixCommon.length && !prefixCommon.length)
            return [];
        if (!N) {
            return [
                ...prefixCommon.map((c) => ({ type: DiffType.common, value: c })),
                ...A.map((a) => ({
                    type: swapped ? DiffType.added : DiffType.removed,
                    value: a,
                })),
                ...suffixCommon.map((c) => ({ type: DiffType.common, value: c })),
            ];
        }
        const offset = N;
        const delta = M - N;
        const size = M + N + 1;
        const fp = new Array(size).fill({ y: -1 });
        /**
         * INFO:
         * This buffer is used to save memory and improve performance.
         * The first half is used to save route and last half is used to save diff
         * type.
         * This is because, when I kept new uint8array area to save type,performance
         * worsened.
         */
        const routes = new Uint32Array((M * N + size + 1) * 2);
        const diffTypesPtrOffset = routes.length / 2;
        let ptr = 0;
        let p = -1;
        function backTrace(A, B, current, swapped) {
            const M = A.length;
            const N = B.length;
            const result = [];
            let a = M - 1;
            let b = N - 1;
            let j = routes[current.id];
            let type = routes[current.id + diffTypesPtrOffset];
            while (true) {
                if (!j && !type)
                    break;
                const prev = j;
                if (type === REMOVED) {
                    result.unshift({
                        type: swapped ? DiffType.removed : DiffType.added,
                        value: B[b],
                    });
                    b -= 1;
                }
                else if (type === ADDED) {
                    result.unshift({
                        type: swapped ? DiffType.added : DiffType.removed,
                        value: A[a],
                    });
                    a -= 1;
                }
                else {
                    result.unshift({ type: DiffType.common, value: A[a] });
                    a -= 1;
                    b -= 1;
                }
                j = routes[prev];
                type = routes[prev + diffTypesPtrOffset];
            }
            return result;
        }
        function createFP(slide, down, k, M) {
            if (slide && slide.y === -1 && down && down.y === -1) {
                return { y: 0, id: 0 };
            }
            if ((down && down.y === -1) ||
                k === M ||
                (slide && slide.y) > (down && down.y) + 1) {
                const prev = slide.id;
                ptr++;
                routes[ptr] = prev;
                routes[ptr + diffTypesPtrOffset] = ADDED;
                return { y: slide.y, id: ptr };
            }
            else {
                const prev = down.id;
                ptr++;
                routes[ptr] = prev;
                routes[ptr + diffTypesPtrOffset] = REMOVED;
                return { y: down.y + 1, id: ptr };
            }
        }
        function snake(k, slide, down, _offset, A, B) {
            const M = A.length;
            const N = B.length;
            if (k < -N || M < k)
                return { y: -1, id: -1 };
            const fp = createFP(slide, down, k, M);
            while (fp.y + k < M && fp.y < N && A[fp.y + k] === B[fp.y]) {
                const prev = fp.id;
                ptr++;
                fp.id = ptr;
                fp.y += 1;
                routes[ptr] = prev;
                routes[ptr + diffTypesPtrOffset] = COMMON;
            }
            return fp;
        }
        while (fp[delta + offset].y < N) {
            p = p + 1;
            for (let k = -p; k < delta; ++k) {
                fp[k + offset] = snake(k, fp[k - 1 + offset], fp[k + 1 + offset], offset, A, B);
            }
            for (let k = delta + p; k > delta; --k) {
                fp[k + offset] = snake(k, fp[k - 1 + offset], fp[k + 1 + offset], offset, A, B);
            }
            fp[delta + offset] = snake(delta, fp[delta - 1 + offset], fp[delta + 1 + offset], offset, A, B);
        }
        return [
            ...prefixCommon.map((c) => ({ type: DiffType.common, value: c })),
            ...backTrace(A, B, fp[delta + offset], swapped),
            ...suffixCommon.map((c) => ({ type: DiffType.common, value: c })),
        ];
    }
    exports_118("default", diff);
    return {
        setters: [],
        execute: function () {
            (function (DiffType) {
                DiffType["removed"] = "removed";
                DiffType["common"] = "common";
                DiffType["added"] = "added";
            })(DiffType || (DiffType = {}));
            exports_118("DiffType", DiffType);
            REMOVED = 1;
            COMMON = 2;
            ADDED = 3;
        }
    };
});
System.register("https://deno.land/x/std@v0.51.0/testing/asserts", ["https://deno.land/x/std@v0.51.0/fmt/colors", "https://deno.land/x/std@v0.51.0/testing/diff"], function (exports_119, context_119) {
    "use strict";
    var colors_ts_5, diff_ts_3, CAN_NOT_DISPLAY, AssertionError;
    var __moduleName = context_119 && context_119.id;
    function format(v) {
        let string = Deno.inspect(v);
        if (typeof v == "string") {
            string = `"${string.replace(/(?=["\\])/g, "\\")}"`;
        }
        return string;
    }
    function createColor(diffType) {
        switch (diffType) {
            case diff_ts_3.DiffType.added:
                return (s) => colors_ts_5.green(colors_ts_5.bold(s));
            case diff_ts_3.DiffType.removed:
                return (s) => colors_ts_5.red(colors_ts_5.bold(s));
            default:
                return colors_ts_5.white;
        }
    }
    function createSign(diffType) {
        switch (diffType) {
            case diff_ts_3.DiffType.added:
                return "+   ";
            case diff_ts_3.DiffType.removed:
                return "-   ";
            default:
                return "    ";
        }
    }
    function buildMessage(diffResult) {
        const messages = [];
        messages.push("");
        messages.push("");
        messages.push(`    ${colors_ts_5.gray(colors_ts_5.bold("[Diff]"))} ${colors_ts_5.red(colors_ts_5.bold("Actual"))} / ${colors_ts_5.green(colors_ts_5.bold("Expected"))}`);
        messages.push("");
        messages.push("");
        diffResult.forEach((result) => {
            const c = createColor(result.type);
            messages.push(c(`${createSign(result.type)}${result.value}`));
        });
        messages.push("");
        return messages;
    }
    function isKeyedCollection(x) {
        return [Symbol.iterator, "size"].every((k) => k in x);
    }
    function equal(c, d) {
        const seen = new Map();
        return (function compare(a, b) {
            // Have to render RegExp & Date for string comparison
            // unless it's mistreated as object
            if (a &&
                b &&
                ((a instanceof RegExp && b instanceof RegExp) ||
                    (a instanceof Date && b instanceof Date))) {
                return String(a) === String(b);
            }
            if (Object.is(a, b)) {
                return true;
            }
            if (a && typeof a === "object" && b && typeof b === "object") {
                if (seen.get(a) === b) {
                    return true;
                }
                if (Object.keys(a || {}).length !== Object.keys(b || {}).length) {
                    return false;
                }
                if (isKeyedCollection(a) && isKeyedCollection(b)) {
                    if (a.size !== b.size) {
                        return false;
                    }
                    let unmatchedEntries = a.size;
                    for (const [aKey, aValue] of a.entries()) {
                        for (const [bKey, bValue] of b.entries()) {
                            /* Given that Map keys can be references, we need
                             * to ensure that they are also deeply equal */
                            if ((aKey === aValue && bKey === bValue && compare(aKey, bKey)) ||
                                (compare(aKey, bKey) && compare(aValue, bValue))) {
                                unmatchedEntries--;
                            }
                        }
                    }
                    return unmatchedEntries === 0;
                }
                const merged = { ...a, ...b };
                for (const key in merged) {
                    if (!compare(a && a[key], b && b[key])) {
                        return false;
                    }
                }
                seen.set(a, b);
                return true;
            }
            return false;
        })(c, d);
    }
    exports_119("equal", equal);
    /** Make an assertion, if not `true`, then throw. */
    function assert(expr, msg = "") {
        if (!expr) {
            throw new AssertionError(msg);
        }
    }
    exports_119("assert", assert);
    /**
     * Make an assertion that `actual` and `expected` are equal, deeply. If not
     * deeply equal, then throw.
     */
    function assertEquals(actual, expected, msg) {
        if (equal(actual, expected)) {
            return;
        }
        let message = "";
        const actualString = format(actual);
        const expectedString = format(expected);
        try {
            const diffResult = diff_ts_3.default(actualString.split("\n"), expectedString.split("\n"));
            message = buildMessage(diffResult).join("\n");
        }
        catch (e) {
            message = `\n${colors_ts_5.red(CAN_NOT_DISPLAY)} + \n\n`;
        }
        if (msg) {
            message = msg;
        }
        throw new AssertionError(message);
    }
    exports_119("assertEquals", assertEquals);
    /**
     * Make an assertion that `actual` and `expected` are not equal, deeply.
     * If not then throw.
     */
    function assertNotEquals(actual, expected, msg) {
        if (!equal(actual, expected)) {
            return;
        }
        let actualString;
        let expectedString;
        try {
            actualString = String(actual);
        }
        catch (e) {
            actualString = "[Cannot display]";
        }
        try {
            expectedString = String(expected);
        }
        catch (e) {
            expectedString = "[Cannot display]";
        }
        if (!msg) {
            msg = `actual: ${actualString} expected: ${expectedString}`;
        }
        throw new AssertionError(msg);
    }
    exports_119("assertNotEquals", assertNotEquals);
    /**
     * Make an assertion that `actual` and `expected` are strictly equal.  If
     * not then throw.
     */
    function assertStrictEq(actual, expected, msg) {
        if (actual !== expected) {
            let actualString;
            let expectedString;
            try {
                actualString = String(actual);
            }
            catch (e) {
                actualString = "[Cannot display]";
            }
            try {
                expectedString = String(expected);
            }
            catch (e) {
                expectedString = "[Cannot display]";
            }
            if (!msg) {
                msg = `actual: ${actualString} expected: ${expectedString}`;
            }
            throw new AssertionError(msg);
        }
    }
    exports_119("assertStrictEq", assertStrictEq);
    /**
     * Make an assertion that actual contains expected. If not
     * then thrown.
     */
    function assertStrContains(actual, expected, msg) {
        if (!actual.includes(expected)) {
            if (!msg) {
                msg = `actual: "${actual}" expected to contains: "${expected}"`;
            }
            throw new AssertionError(msg);
        }
    }
    exports_119("assertStrContains", assertStrContains);
    /**
     * Make an assertion that `actual` contains the `expected` values
     * If not then thrown.
     */
    function assertArrayContains(actual, expected, msg) {
        const missing = [];
        for (let i = 0; i < expected.length; i++) {
            let found = false;
            for (let j = 0; j < actual.length; j++) {
                if (equal(expected[i], actual[j])) {
                    found = true;
                    break;
                }
            }
            if (!found) {
                missing.push(expected[i]);
            }
        }
        if (missing.length === 0) {
            return;
        }
        if (!msg) {
            msg = `actual: "${actual}" expected to contains: "${expected}"`;
            msg += "\n";
            msg += `missing: ${missing}`;
        }
        throw new AssertionError(msg);
    }
    exports_119("assertArrayContains", assertArrayContains);
    /**
     * Make an assertion that `actual` match RegExp `expected`. If not
     * then thrown
     */
    function assertMatch(actual, expected, msg) {
        if (!expected.test(actual)) {
            if (!msg) {
                msg = `actual: "${actual}" expected to match: "${expected}"`;
            }
            throw new AssertionError(msg);
        }
    }
    exports_119("assertMatch", assertMatch);
    /**
     * Forcefully throws a failed assertion
     */
    function fail(msg) {
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        assert(false, `Failed assertion${msg ? `: ${msg}` : "."}`);
    }
    exports_119("fail", fail);
    /** Executes a function, expecting it to throw.  If it does not, then it
     * throws.  An error class and a string that should be included in the
     * error message can also be asserted.
     */
    function assertThrows(fn, ErrorClass, msgIncludes = "", msg) {
        let doesThrow = false;
        let error = null;
        try {
            fn();
        }
        catch (e) {
            if (ErrorClass && !(Object.getPrototypeOf(e) === ErrorClass.prototype)) {
                msg = `Expected error to be instance of "${ErrorClass.name}", but was "${e.constructor.name}"${msg ? `: ${msg}` : "."}`;
                throw new AssertionError(msg);
            }
            if (msgIncludes && !e.message.includes(msgIncludes)) {
                msg = `Expected error message to include "${msgIncludes}", but got "${e.message}"${msg ? `: ${msg}` : "."}`;
                throw new AssertionError(msg);
            }
            doesThrow = true;
            error = e;
        }
        if (!doesThrow) {
            msg = `Expected function to throw${msg ? `: ${msg}` : "."}`;
            throw new AssertionError(msg);
        }
        return error;
    }
    exports_119("assertThrows", assertThrows);
    async function assertThrowsAsync(fn, ErrorClass, msgIncludes = "", msg) {
        let doesThrow = false;
        let error = null;
        try {
            await fn();
        }
        catch (e) {
            if (ErrorClass && !(Object.getPrototypeOf(e) === ErrorClass.prototype)) {
                msg = `Expected error to be instance of "${ErrorClass.name}", but got "${e.name}"${msg ? `: ${msg}` : "."}`;
                throw new AssertionError(msg);
            }
            if (msgIncludes && !e.message.includes(msgIncludes)) {
                msg = `Expected error message to include "${msgIncludes}", but got "${e.message}"${msg ? `: ${msg}` : "."}`;
                throw new AssertionError(msg);
            }
            doesThrow = true;
            error = e;
        }
        if (!doesThrow) {
            msg = `Expected function to throw${msg ? `: ${msg}` : "."}`;
            throw new AssertionError(msg);
        }
        return error;
    }
    exports_119("assertThrowsAsync", assertThrowsAsync);
    /** Use this to stub out methods that will throw when invoked. */
    function unimplemented(msg) {
        throw new AssertionError(msg || "unimplemented");
    }
    exports_119("unimplemented", unimplemented);
    /** Use this to assert unreachable code. */
    function unreachable() {
        throw new AssertionError("unreachable");
    }
    exports_119("unreachable", unreachable);
    return {
        setters: [
            function (colors_ts_5_1) {
                colors_ts_5 = colors_ts_5_1;
            },
            function (diff_ts_3_1) {
                diff_ts_3 = diff_ts_3_1;
            }
        ],
        execute: function () {
            CAN_NOT_DISPLAY = "[Cannot display]";
            AssertionError = class AssertionError extends Error {
                constructor(message) {
                    super(message);
                    this.name = "AssertionError";
                }
            };
            exports_119("AssertionError", AssertionError);
        }
    };
});
System.register("https://deno.land/x/std@v0.51.0/log/mod", ["https://deno.land/x/std@v0.51.0/log/logger", "https://deno.land/x/std@v0.51.0/log/handlers", "https://deno.land/x/std@v0.51.0/testing/asserts", "https://deno.land/x/std@v0.51.0/log/levels"], function (exports_120, context_120) {
    "use strict";
    var logger_ts_1, handlers_ts_1, asserts_ts_2, LoggerConfig, DEFAULT_LEVEL, DEFAULT_CONFIG, state, handlers, debug, info, warning, error, critical;
    var __moduleName = context_120 && context_120.id;
    function getLogger(name) {
        if (!name) {
            const d = state.loggers.get("default");
            asserts_ts_2.assert(d != null, `"default" logger must be set for getting logger without name`);
            return d;
        }
        const result = state.loggers.get(name);
        if (!result) {
            const logger = new logger_ts_1.Logger("NOTSET", []);
            state.loggers.set(name, logger);
            return logger;
        }
        return result;
    }
    exports_120("getLogger", getLogger);
    async function setup(config) {
        state.config = {
            handlers: { ...DEFAULT_CONFIG.handlers, ...config.handlers },
            loggers: { ...DEFAULT_CONFIG.loggers, ...config.loggers },
        };
        // tear down existing handlers
        state.handlers.forEach((handler) => {
            handler.destroy();
        });
        state.handlers.clear();
        // setup handlers
        const handlers = state.config.handlers || {};
        for (const handlerName in handlers) {
            const handler = handlers[handlerName];
            await handler.setup();
            state.handlers.set(handlerName, handler);
        }
        // remove existing loggers
        state.loggers.clear();
        // setup loggers
        const loggers = state.config.loggers || {};
        for (const loggerName in loggers) {
            const loggerConfig = loggers[loggerName];
            const handlerNames = loggerConfig.handlers || [];
            const handlers = [];
            handlerNames.forEach((handlerName) => {
                const handler = state.handlers.get(handlerName);
                if (handler) {
                    handlers.push(handler);
                }
            });
            const levelName = loggerConfig.level || DEFAULT_LEVEL;
            const logger = new logger_ts_1.Logger(levelName, handlers);
            state.loggers.set(loggerName, logger);
        }
    }
    exports_120("setup", setup);
    return {
        setters: [
            function (logger_ts_1_1) {
                logger_ts_1 = logger_ts_1_1;
            },
            function (handlers_ts_1_1) {
                handlers_ts_1 = handlers_ts_1_1;
            },
            function (asserts_ts_2_1) {
                asserts_ts_2 = asserts_ts_2_1;
            },
            function (levels_ts_3_1) {
                exports_120({
                    "LogLevels": levels_ts_3_1["LogLevels"]
                });
            }
        ],
        execute: function () {
            LoggerConfig = class LoggerConfig {
            };
            exports_120("LoggerConfig", LoggerConfig);
            DEFAULT_LEVEL = "INFO";
            DEFAULT_CONFIG = {
                handlers: {
                    default: new handlers_ts_1.ConsoleHandler(DEFAULT_LEVEL),
                },
                loggers: {
                    default: {
                        level: DEFAULT_LEVEL,
                        handlers: ["default"],
                    },
                },
            };
            state = {
                handlers: new Map(),
                loggers: new Map(),
                config: DEFAULT_CONFIG,
            };
            exports_120("handlers", handlers = {
                BaseHandler: handlers_ts_1.BaseHandler,
                ConsoleHandler: handlers_ts_1.ConsoleHandler,
                WriterHandler: handlers_ts_1.WriterHandler,
                FileHandler: handlers_ts_1.FileHandler,
                RotatingFileHandler: handlers_ts_1.RotatingFileHandler,
            });
            exports_120("debug", debug = (msg, ...args) => getLogger("default").debug(msg, ...args));
            exports_120("info", info = (msg, ...args) => getLogger("default").info(msg, ...args));
            exports_120("warning", warning = (msg, ...args) => getLogger("default").warning(msg, ...args));
            exports_120("error", error = (msg, ...args) => getLogger("default").error(msg, ...args));
            exports_120("critical", critical = (msg, ...args) => getLogger("default").critical(msg, ...args));
            setup(DEFAULT_CONFIG);
        }
    };
});
System.register("https://deno.land/x/mysql@2.1.0/deps", ["https://deno.land/std@v0.51.0/async/mod", "https://deno.land/std@v0.51.0/encoding/utf8", "https://deno.land/std@v0.51.0/testing/asserts", "https://deno.land/x/bytes_formater@1.2.0/mod", "https://deno.land/x/checksum@1.4.0/mod", "https://deno.land/x/sha256@v1.0.2/mod", "https://deno.land/x/sql_builder@1.3.5/util", "https://deno.land/x/std@v0.51.0/log/mod"], function (exports_121, context_121) {
    "use strict";
    var __moduleName = context_121 && context_121.id;
    return {
        setters: [
            function (mod_ts_17_1) {
                exports_121({
                    "deferred": mod_ts_17_1["deferred"],
                    "delay": mod_ts_17_1["delay"]
                });
            },
            function (utf8_ts_5_1) {
                exports_121({
                    "decode": utf8_ts_5_1["decode"],
                    "encode": utf8_ts_5_1["encode"]
                });
            },
            function (asserts_ts_3_1) {
                exports_121({
                    "assertEquals": asserts_ts_3_1["assertEquals"],
                    "assertThrowsAsync": asserts_ts_3_1["assertThrowsAsync"]
                });
            },
            function (mod_ts_18_1) {
                exports_121({
                    "byteFormat": mod_ts_18_1["format"]
                });
            },
            function (mod_ts_19_1) {
                exports_121({
                    "Hash": mod_ts_19_1["Hash"]
                });
            },
            function (mod_ts_20_1) {
                exports_121({
                    "sha256": mod_ts_20_1["sha256"]
                });
            },
            function (util_ts_11_1) {
                exports_121({
                    "replaceParams": util_ts_11_1["replaceParams"]
                });
            },
            function (log_1) {
                exports_121("log", log_1);
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/mysql@2.1.0/src/constant/errors", [], function (exports_122, context_122) {
    "use strict";
    var WriteError, ResponseTimeoutError;
    var __moduleName = context_122 && context_122.id;
    return {
        setters: [],
        execute: function () {
            WriteError = class WriteError extends Error {
                constructor(msg) {
                    super(msg);
                }
            };
            exports_122("WriteError", WriteError);
            ResponseTimeoutError = class ResponseTimeoutError extends Error {
                constructor(msg) {
                    super(msg);
                }
            };
            exports_122("ResponseTimeoutError", ResponseTimeoutError);
        }
    };
});
System.register("https://deno.land/x/mysql@2.1.0/src/logger", ["https://deno.land/x/mysql@2.1.0/deps"], function (exports_123, context_123) {
    "use strict";
    var deps_ts_19, isDebug;
    var __moduleName = context_123 && context_123.id;
    /** @ignore */
    function debug(func) {
        if (isDebug) {
            func();
        }
    }
    exports_123("debug", debug);
    /** @ignore */
    async function config(config) {
        isDebug = config.debug;
        await deps_ts_19.log.setup({
            handlers: {
                console: new deps_ts_19.log.handlers.ConsoleHandler(config.debug ? "DEBUG" : "INFO"),
                file: new deps_ts_19.log.handlers.FileHandler("WARNING", {
                    filename: config.logFile,
                    formatter: "{levelName} {msg}",
                }),
            },
            loggers: {
                default: {
                    level: "DEBUG",
                    handlers: ["console", "file"],
                },
            },
        });
    }
    exports_123("config", config);
    return {
        setters: [
            function (deps_ts_19_1) {
                deps_ts_19 = deps_ts_19_1;
            }
        ],
        execute: function () {
            exports_123("log", deps_ts_19.log);
            isDebug = false;
        }
    };
});
System.register("https://deno.land/x/mysql@2.1.0/src/auth", ["https://deno.land/x/mysql@2.1.0/deps"], function (exports_124, context_124) {
    "use strict";
    var deps_ts_20;
    var __moduleName = context_124 && context_124.id;
    function xor(a, b) {
        return a.map((byte, index) => {
            return byte ^ b[index];
        });
    }
    function mysqlNativePassword(password, seed) {
        const hash = new deps_ts_20.Hash("sha1");
        const pwd1 = hash.digest(deps_ts_20.encode(password)).data;
        const pwd2 = hash.digest(pwd1).data;
        let seedAndPwd2 = new Uint8Array(seed.length + pwd2.length);
        seedAndPwd2.set(seed);
        seedAndPwd2.set(pwd2, seed.length);
        seedAndPwd2 = hash.digest(seedAndPwd2).data;
        return xor(seedAndPwd2, pwd1);
    }
    function cachingSha2Password(password, seed) {
        const stage1 = deps_ts_20.sha256(password, "utf8");
        const stage2 = deps_ts_20.sha256(stage1);
        const stage3 = deps_ts_20.sha256(Uint8Array.from([...stage2, ...seed]));
        return xor(stage1, stage3);
    }
    function auth(authPluginName, password, seed) {
        switch (authPluginName) {
            case "mysql_native_password":
                return mysqlNativePassword(password, seed);
            case "caching_sha2_password":
            // TODO
            // return cachingSha2Password(password, seed);
            default:
                throw new Error("Not supported");
        }
    }
    exports_124("default", auth);
    return {
        setters: [
            function (deps_ts_20_1) {
                deps_ts_20 = deps_ts_20_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/mysql@2.1.0/src/buffer", ["https://deno.land/x/mysql@2.1.0/deps"], function (exports_125, context_125) {
    "use strict";
    var deps_ts_21, BufferReader, BufferWriter;
    var __moduleName = context_125 && context_125.id;
    return {
        setters: [
            function (deps_ts_21_1) {
                deps_ts_21 = deps_ts_21_1;
            }
        ],
        execute: function () {
            /** @ignore */
            BufferReader = class BufferReader {
                constructor(buffer) {
                    this.buffer = buffer;
                    this.pos = 0;
                }
                get finished() {
                    return this.pos >= this.buffer.length;
                }
                skip(len) {
                    this.pos += len;
                    return this;
                }
                readBuffer(len) {
                    const buffer = this.buffer.slice(this.pos, this.pos + len);
                    this.pos += len;
                    return buffer;
                }
                readUints(len) {
                    let num = 0;
                    for (let n = 0; n < len; n++) {
                        num += this.buffer[this.pos++] << (8 * n);
                    }
                    return num;
                }
                readUint8() {
                    return this.buffer[this.pos++];
                }
                readUint16() {
                    return this.readUints(2);
                }
                readUint32() {
                    return this.readUints(4);
                }
                readUint64() {
                    return this.readUints(8);
                }
                readNullTerminatedString() {
                    let end = this.buffer.indexOf(0x00, this.pos);
                    if (end === -1)
                        end = this.buffer.length;
                    const buf = this.buffer.slice(this.pos, end);
                    this.pos += buf.length + 1;
                    return deps_ts_21.decode(buf);
                }
                readString(len) {
                    const str = deps_ts_21.decode(this.buffer.slice(this.pos, this.pos + len));
                    this.pos += len;
                    return str;
                }
                readEncodedLen() {
                    const first = this.readUint8();
                    if (first < 251) {
                        return first;
                    }
                    else {
                        if (first == 0xfc) {
                            return this.readUint16();
                        }
                        else if (first == 0xfd) {
                            return this.readUints(3);
                        }
                        else if (first == 0xfe) {
                            return this.readUints(8);
                        }
                    }
                    return -1;
                }
                readLenCodeString() {
                    const len = this.readEncodedLen();
                    if (len == -1)
                        return null;
                    return this.readString(len);
                }
            };
            exports_125("BufferReader", BufferReader);
            /** @ignore */
            BufferWriter = class BufferWriter {
                constructor(buffer) {
                    this.buffer = buffer;
                    this.pos = 0;
                }
                get wroteData() {
                    return this.buffer.slice(0, this.pos);
                }
                get length() {
                    return this.pos;
                }
                get capacity() {
                    return this.buffer.length - this.pos;
                }
                skip(len) {
                    this.pos += len;
                    return this;
                }
                writeBuffer(buffer) {
                    if (buffer.length > this.capacity) {
                        buffer = buffer.slice(0, this.capacity);
                    }
                    this.buffer.set(buffer, this.pos);
                    this.pos += buffer.length;
                    return this;
                }
                write(byte) {
                    this.buffer[this.pos++] = byte;
                    return this;
                }
                writeInt16LE(num) { }
                writeIntLE(num, len) {
                    const int = new Int32Array(1);
                    int[0] = 40;
                    console.log(int);
                }
                writeUint16(num) {
                    return this.writeUints(2, num);
                }
                writeUint32(num) {
                    return this.writeUints(4, num);
                }
                writeUint64(num) {
                    return this.writeUints(8, num);
                }
                writeUints(len, num) {
                    for (let n = 0; n < len; n++) {
                        this.buffer[this.pos++] = (num >> (n * 8)) & 0xff;
                    }
                    return this;
                }
                writeNullTerminatedString(str) {
                    return this.writeString(str).write(0x00);
                }
                writeString(str) {
                    const buf = deps_ts_21.encode(str);
                    this.buffer.set(buf, this.pos);
                    this.pos += buf.length;
                    return this;
                }
            };
            exports_125("BufferWriter", BufferWriter);
        }
    };
});
System.register("https://deno.land/x/mysql@2.1.0/src/constant/capabilities", [], function (exports_126, context_126) {
    "use strict";
    var ServerCapabilities;
    var __moduleName = context_126 && context_126.id;
    return {
        setters: [],
        execute: function () {
            (function (ServerCapabilities) {
                ServerCapabilities[ServerCapabilities["CLIENT_PROTOCOL_41"] = 512] = "CLIENT_PROTOCOL_41";
                ServerCapabilities[ServerCapabilities["CLIENT_CONNECT_WITH_DB"] = 8] = "CLIENT_CONNECT_WITH_DB";
                ServerCapabilities[ServerCapabilities["CLIENT_LONG_FLAG"] = 4] = "CLIENT_LONG_FLAG";
                ServerCapabilities[ServerCapabilities["CLIENT_DEPRECATE_EOF"] = 16777216] = "CLIENT_DEPRECATE_EOF";
                ServerCapabilities[ServerCapabilities["CLIENT_LONG_PASSWORD"] = 1] = "CLIENT_LONG_PASSWORD";
                ServerCapabilities[ServerCapabilities["CLIENT_TRANSACTIONS"] = 8192] = "CLIENT_TRANSACTIONS";
                ServerCapabilities[ServerCapabilities["CLIENT_MULTI_RESULTS"] = 131072] = "CLIENT_MULTI_RESULTS";
                ServerCapabilities[ServerCapabilities["CLIENT_PLUGIN_AUTH_LENENC_CLIENT_DATA"] = 2097152] = "CLIENT_PLUGIN_AUTH_LENENC_CLIENT_DATA";
                ServerCapabilities[ServerCapabilities["CLIENT_PLUGIN_AUTH"] = 524288] = "CLIENT_PLUGIN_AUTH";
                ServerCapabilities[ServerCapabilities["CLIENT_SECURE_CONNECTION"] = 32768] = "CLIENT_SECURE_CONNECTION";
                ServerCapabilities[ServerCapabilities["CLIENT_FOUND_ROWS"] = 2] = "CLIENT_FOUND_ROWS";
                ServerCapabilities[ServerCapabilities["CLIENT_CONNECT_ATTRS"] = 1048576] = "CLIENT_CONNECT_ATTRS";
            })(ServerCapabilities || (ServerCapabilities = {}));
            exports_126("default", ServerCapabilities);
        }
    };
});
System.register("https://deno.land/x/mysql@2.1.0/src/constant/charset", [], function (exports_127, context_127) {
    "use strict";
    var Charset;
    var __moduleName = context_127 && context_127.id;
    return {
        setters: [],
        execute: function () {
            (function (Charset) {
                Charset[Charset["BIG5_CHINESE_CI"] = 1] = "BIG5_CHINESE_CI";
                Charset[Charset["LATIN2_CZECH_CS"] = 2] = "LATIN2_CZECH_CS";
                Charset[Charset["DEC8_SWEDISH_CI"] = 3] = "DEC8_SWEDISH_CI";
                Charset[Charset["CP850_GENERAL_CI"] = 4] = "CP850_GENERAL_CI";
                Charset[Charset["LATIN1_GERMAN1_CI"] = 5] = "LATIN1_GERMAN1_CI";
                Charset[Charset["HP8_ENGLISH_CI"] = 6] = "HP8_ENGLISH_CI";
                Charset[Charset["KOI8R_GENERAL_CI"] = 7] = "KOI8R_GENERAL_CI";
                Charset[Charset["LATIN1_SWEDISH_CI"] = 8] = "LATIN1_SWEDISH_CI";
                Charset[Charset["LATIN2_GENERAL_CI"] = 9] = "LATIN2_GENERAL_CI";
                Charset[Charset["SWE7_SWEDISH_CI"] = 10] = "SWE7_SWEDISH_CI";
                Charset[Charset["ASCII_GENERAL_CI"] = 11] = "ASCII_GENERAL_CI";
                Charset[Charset["UJIS_JAPANESE_CI"] = 12] = "UJIS_JAPANESE_CI";
                Charset[Charset["SJIS_JAPANESE_CI"] = 13] = "SJIS_JAPANESE_CI";
                Charset[Charset["CP1251_BULGARIAN_CI"] = 14] = "CP1251_BULGARIAN_CI";
                Charset[Charset["LATIN1_DANISH_CI"] = 15] = "LATIN1_DANISH_CI";
                Charset[Charset["HEBREW_GENERAL_CI"] = 16] = "HEBREW_GENERAL_CI";
                Charset[Charset["TIS620_THAI_CI"] = 18] = "TIS620_THAI_CI";
                Charset[Charset["EUCKR_KOREAN_CI"] = 19] = "EUCKR_KOREAN_CI";
                Charset[Charset["LATIN7_ESTONIAN_CS"] = 20] = "LATIN7_ESTONIAN_CS";
                Charset[Charset["LATIN2_HUNGARIAN_CI"] = 21] = "LATIN2_HUNGARIAN_CI";
                Charset[Charset["KOI8U_GENERAL_CI"] = 22] = "KOI8U_GENERAL_CI";
                Charset[Charset["CP1251_UKRAINIAN_CI"] = 23] = "CP1251_UKRAINIAN_CI";
                Charset[Charset["GB2312_CHINESE_CI"] = 24] = "GB2312_CHINESE_CI";
                Charset[Charset["GREEK_GENERAL_CI"] = 25] = "GREEK_GENERAL_CI";
                Charset[Charset["CP1250_GENERAL_CI"] = 26] = "CP1250_GENERAL_CI";
                Charset[Charset["LATIN2_CROATIAN_CI"] = 27] = "LATIN2_CROATIAN_CI";
                Charset[Charset["GBK_CHINESE_CI"] = 28] = "GBK_CHINESE_CI";
                Charset[Charset["CP1257_LITHUANIAN_CI"] = 29] = "CP1257_LITHUANIAN_CI";
                Charset[Charset["LATIN5_TURKISH_CI"] = 30] = "LATIN5_TURKISH_CI";
                Charset[Charset["LATIN1_GERMAN2_CI"] = 31] = "LATIN1_GERMAN2_CI";
                Charset[Charset["ARMSCII8_GENERAL_CI"] = 32] = "ARMSCII8_GENERAL_CI";
                Charset[Charset["UTF8_GENERAL_CI"] = 33] = "UTF8_GENERAL_CI";
                Charset[Charset["CP1250_CZECH_CS"] = 34] = "CP1250_CZECH_CS";
                Charset[Charset["UCS2_GENERAL_CI"] = 35] = "UCS2_GENERAL_CI";
                Charset[Charset["CP866_GENERAL_CI"] = 36] = "CP866_GENERAL_CI";
                Charset[Charset["KEYBCS2_GENERAL_CI"] = 37] = "KEYBCS2_GENERAL_CI";
                Charset[Charset["MACCE_GENERAL_CI"] = 38] = "MACCE_GENERAL_CI";
                Charset[Charset["MACROMAN_GENERAL_CI"] = 39] = "MACROMAN_GENERAL_CI";
                Charset[Charset["CP852_GENERAL_CI"] = 40] = "CP852_GENERAL_CI";
                Charset[Charset["LATIN7_GENERAL_CI"] = 41] = "LATIN7_GENERAL_CI";
                Charset[Charset["LATIN7_GENERAL_CS"] = 42] = "LATIN7_GENERAL_CS";
                Charset[Charset["MACCE_BIN"] = 43] = "MACCE_BIN";
                Charset[Charset["CP1250_CROATIAN_CI"] = 44] = "CP1250_CROATIAN_CI";
                Charset[Charset["UTF8MB4_GENERAL_CI"] = 45] = "UTF8MB4_GENERAL_CI";
                Charset[Charset["UTF8MB4_BIN"] = 46] = "UTF8MB4_BIN";
                Charset[Charset["LATIN1_BIN"] = 47] = "LATIN1_BIN";
                Charset[Charset["LATIN1_GENERAL_CI"] = 48] = "LATIN1_GENERAL_CI";
                Charset[Charset["LATIN1_GENERAL_CS"] = 49] = "LATIN1_GENERAL_CS";
                Charset[Charset["CP1251_BIN"] = 50] = "CP1251_BIN";
                Charset[Charset["CP1251_GENERAL_CI"] = 51] = "CP1251_GENERAL_CI";
                Charset[Charset["CP1251_GENERAL_CS"] = 52] = "CP1251_GENERAL_CS";
                Charset[Charset["MACROMAN_BIN"] = 53] = "MACROMAN_BIN";
                Charset[Charset["UTF16_GENERAL_CI"] = 54] = "UTF16_GENERAL_CI";
                Charset[Charset["UTF16_BIN"] = 55] = "UTF16_BIN";
                Charset[Charset["UTF16LE_GENERAL_CI"] = 56] = "UTF16LE_GENERAL_CI";
                Charset[Charset["CP1256_GENERAL_CI"] = 57] = "CP1256_GENERAL_CI";
                Charset[Charset["CP1257_BIN"] = 58] = "CP1257_BIN";
                Charset[Charset["CP1257_GENERAL_CI"] = 59] = "CP1257_GENERAL_CI";
                Charset[Charset["UTF32_GENERAL_CI"] = 60] = "UTF32_GENERAL_CI";
                Charset[Charset["UTF32_BIN"] = 61] = "UTF32_BIN";
                Charset[Charset["UTF16LE_BIN"] = 62] = "UTF16LE_BIN";
                Charset[Charset["BINARY"] = 63] = "BINARY";
                Charset[Charset["ARMSCII8_BIN"] = 64] = "ARMSCII8_BIN";
                Charset[Charset["ASCII_BIN"] = 65] = "ASCII_BIN";
                Charset[Charset["CP1250_BIN"] = 66] = "CP1250_BIN";
                Charset[Charset["CP1256_BIN"] = 67] = "CP1256_BIN";
                Charset[Charset["CP866_BIN"] = 68] = "CP866_BIN";
                Charset[Charset["DEC8_BIN"] = 69] = "DEC8_BIN";
                Charset[Charset["GREEK_BIN"] = 70] = "GREEK_BIN";
                Charset[Charset["HEBREW_BIN"] = 71] = "HEBREW_BIN";
                Charset[Charset["HP8_BIN"] = 72] = "HP8_BIN";
                Charset[Charset["KEYBCS2_BIN"] = 73] = "KEYBCS2_BIN";
                Charset[Charset["KOI8R_BIN"] = 74] = "KOI8R_BIN";
                Charset[Charset["KOI8U_BIN"] = 75] = "KOI8U_BIN";
                Charset[Charset["LATIN2_BIN"] = 77] = "LATIN2_BIN";
                Charset[Charset["LATIN5_BIN"] = 78] = "LATIN5_BIN";
                Charset[Charset["LATIN7_BIN"] = 79] = "LATIN7_BIN";
                Charset[Charset["CP850_BIN"] = 80] = "CP850_BIN";
                Charset[Charset["CP852_BIN"] = 81] = "CP852_BIN";
                Charset[Charset["SWE7_BIN"] = 82] = "SWE7_BIN";
                Charset[Charset["UTF8_BIN"] = 83] = "UTF8_BIN";
                Charset[Charset["BIG5_BIN"] = 84] = "BIG5_BIN";
                Charset[Charset["EUCKR_BIN"] = 85] = "EUCKR_BIN";
                Charset[Charset["GB2312_BIN"] = 86] = "GB2312_BIN";
                Charset[Charset["GBK_BIN"] = 87] = "GBK_BIN";
                Charset[Charset["SJIS_BIN"] = 88] = "SJIS_BIN";
                Charset[Charset["TIS620_BIN"] = 89] = "TIS620_BIN";
                Charset[Charset["UCS2_BIN"] = 90] = "UCS2_BIN";
                Charset[Charset["UJIS_BIN"] = 91] = "UJIS_BIN";
                Charset[Charset["GEOSTD8_GENERAL_CI"] = 92] = "GEOSTD8_GENERAL_CI";
                Charset[Charset["GEOSTD8_BIN"] = 93] = "GEOSTD8_BIN";
                Charset[Charset["LATIN1_SPANISH_CI"] = 94] = "LATIN1_SPANISH_CI";
                Charset[Charset["CP932_JAPANESE_CI"] = 95] = "CP932_JAPANESE_CI";
                Charset[Charset["CP932_BIN"] = 96] = "CP932_BIN";
                Charset[Charset["EUCJPMS_JAPANESE_CI"] = 97] = "EUCJPMS_JAPANESE_CI";
                Charset[Charset["EUCJPMS_BIN"] = 98] = "EUCJPMS_BIN";
                Charset[Charset["CP1250_POLISH_CI"] = 99] = "CP1250_POLISH_CI";
                Charset[Charset["UTF16_UNICODE_CI"] = 101] = "UTF16_UNICODE_CI";
                Charset[Charset["UTF16_ICELANDIC_CI"] = 102] = "UTF16_ICELANDIC_CI";
                Charset[Charset["UTF16_LATVIAN_CI"] = 103] = "UTF16_LATVIAN_CI";
                Charset[Charset["UTF16_ROMANIAN_CI"] = 104] = "UTF16_ROMANIAN_CI";
                Charset[Charset["UTF16_SLOVENIAN_CI"] = 105] = "UTF16_SLOVENIAN_CI";
                Charset[Charset["UTF16_POLISH_CI"] = 106] = "UTF16_POLISH_CI";
                Charset[Charset["UTF16_ESTONIAN_CI"] = 107] = "UTF16_ESTONIAN_CI";
                Charset[Charset["UTF16_SPANISH_CI"] = 108] = "UTF16_SPANISH_CI";
                Charset[Charset["UTF16_SWEDISH_CI"] = 109] = "UTF16_SWEDISH_CI";
                Charset[Charset["UTF16_TURKISH_CI"] = 110] = "UTF16_TURKISH_CI";
                Charset[Charset["UTF16_CZECH_CI"] = 111] = "UTF16_CZECH_CI";
                Charset[Charset["UTF16_DANISH_CI"] = 112] = "UTF16_DANISH_CI";
                Charset[Charset["UTF16_LITHUANIAN_CI"] = 113] = "UTF16_LITHUANIAN_CI";
                Charset[Charset["UTF16_SLOVAK_CI"] = 114] = "UTF16_SLOVAK_CI";
                Charset[Charset["UTF16_SPANISH2_CI"] = 115] = "UTF16_SPANISH2_CI";
                Charset[Charset["UTF16_ROMAN_CI"] = 116] = "UTF16_ROMAN_CI";
                Charset[Charset["UTF16_PERSIAN_CI"] = 117] = "UTF16_PERSIAN_CI";
                Charset[Charset["UTF16_ESPERANTO_CI"] = 118] = "UTF16_ESPERANTO_CI";
                Charset[Charset["UTF16_HUNGARIAN_CI"] = 119] = "UTF16_HUNGARIAN_CI";
                Charset[Charset["UTF16_SINHALA_CI"] = 120] = "UTF16_SINHALA_CI";
                Charset[Charset["UTF16_GERMAN2_CI"] = 121] = "UTF16_GERMAN2_CI";
                Charset[Charset["UTF16_CROATIAN_MYSQL561_CI"] = 122] = "UTF16_CROATIAN_MYSQL561_CI";
                Charset[Charset["UTF16_UNICODE_520_CI"] = 123] = "UTF16_UNICODE_520_CI";
                Charset[Charset["UTF16_VIETNAMESE_CI"] = 124] = "UTF16_VIETNAMESE_CI";
                Charset[Charset["UCS2_UNICODE_CI"] = 128] = "UCS2_UNICODE_CI";
                Charset[Charset["UCS2_ICELANDIC_CI"] = 129] = "UCS2_ICELANDIC_CI";
                Charset[Charset["UCS2_LATVIAN_CI"] = 130] = "UCS2_LATVIAN_CI";
                Charset[Charset["UCS2_ROMANIAN_CI"] = 131] = "UCS2_ROMANIAN_CI";
                Charset[Charset["UCS2_SLOVENIAN_CI"] = 132] = "UCS2_SLOVENIAN_CI";
                Charset[Charset["UCS2_POLISH_CI"] = 133] = "UCS2_POLISH_CI";
                Charset[Charset["UCS2_ESTONIAN_CI"] = 134] = "UCS2_ESTONIAN_CI";
                Charset[Charset["UCS2_SPANISH_CI"] = 135] = "UCS2_SPANISH_CI";
                Charset[Charset["UCS2_SWEDISH_CI"] = 136] = "UCS2_SWEDISH_CI";
                Charset[Charset["UCS2_TURKISH_CI"] = 137] = "UCS2_TURKISH_CI";
                Charset[Charset["UCS2_CZECH_CI"] = 138] = "UCS2_CZECH_CI";
                Charset[Charset["UCS2_DANISH_CI"] = 139] = "UCS2_DANISH_CI";
                Charset[Charset["UCS2_LITHUANIAN_CI"] = 140] = "UCS2_LITHUANIAN_CI";
                Charset[Charset["UCS2_SLOVAK_CI"] = 141] = "UCS2_SLOVAK_CI";
                Charset[Charset["UCS2_SPANISH2_CI"] = 142] = "UCS2_SPANISH2_CI";
                Charset[Charset["UCS2_ROMAN_CI"] = 143] = "UCS2_ROMAN_CI";
                Charset[Charset["UCS2_PERSIAN_CI"] = 144] = "UCS2_PERSIAN_CI";
                Charset[Charset["UCS2_ESPERANTO_CI"] = 145] = "UCS2_ESPERANTO_CI";
                Charset[Charset["UCS2_HUNGARIAN_CI"] = 146] = "UCS2_HUNGARIAN_CI";
                Charset[Charset["UCS2_SINHALA_CI"] = 147] = "UCS2_SINHALA_CI";
                Charset[Charset["UCS2_GERMAN2_CI"] = 148] = "UCS2_GERMAN2_CI";
                Charset[Charset["UCS2_CROATIAN_MYSQL561_CI"] = 149] = "UCS2_CROATIAN_MYSQL561_CI";
                Charset[Charset["UCS2_UNICODE_520_CI"] = 150] = "UCS2_UNICODE_520_CI";
                Charset[Charset["UCS2_VIETNAMESE_CI"] = 151] = "UCS2_VIETNAMESE_CI";
                Charset[Charset["UCS2_GENERAL_MYSQL500_CI"] = 159] = "UCS2_GENERAL_MYSQL500_CI";
                Charset[Charset["UTF32_UNICODE_CI"] = 160] = "UTF32_UNICODE_CI";
                Charset[Charset["UTF32_ICELANDIC_CI"] = 161] = "UTF32_ICELANDIC_CI";
                Charset[Charset["UTF32_LATVIAN_CI"] = 162] = "UTF32_LATVIAN_CI";
                Charset[Charset["UTF32_ROMANIAN_CI"] = 163] = "UTF32_ROMANIAN_CI";
                Charset[Charset["UTF32_SLOVENIAN_CI"] = 164] = "UTF32_SLOVENIAN_CI";
                Charset[Charset["UTF32_POLISH_CI"] = 165] = "UTF32_POLISH_CI";
                Charset[Charset["UTF32_ESTONIAN_CI"] = 166] = "UTF32_ESTONIAN_CI";
                Charset[Charset["UTF32_SPANISH_CI"] = 167] = "UTF32_SPANISH_CI";
                Charset[Charset["UTF32_SWEDISH_CI"] = 168] = "UTF32_SWEDISH_CI";
                Charset[Charset["UTF32_TURKISH_CI"] = 169] = "UTF32_TURKISH_CI";
                Charset[Charset["UTF32_CZECH_CI"] = 170] = "UTF32_CZECH_CI";
                Charset[Charset["UTF32_DANISH_CI"] = 171] = "UTF32_DANISH_CI";
                Charset[Charset["UTF32_LITHUANIAN_CI"] = 172] = "UTF32_LITHUANIAN_CI";
                Charset[Charset["UTF32_SLOVAK_CI"] = 173] = "UTF32_SLOVAK_CI";
                Charset[Charset["UTF32_SPANISH2_CI"] = 174] = "UTF32_SPANISH2_CI";
                Charset[Charset["UTF32_ROMAN_CI"] = 175] = "UTF32_ROMAN_CI";
                Charset[Charset["UTF32_PERSIAN_CI"] = 176] = "UTF32_PERSIAN_CI";
                Charset[Charset["UTF32_ESPERANTO_CI"] = 177] = "UTF32_ESPERANTO_CI";
                Charset[Charset["UTF32_HUNGARIAN_CI"] = 178] = "UTF32_HUNGARIAN_CI";
                Charset[Charset["UTF32_SINHALA_CI"] = 179] = "UTF32_SINHALA_CI";
                Charset[Charset["UTF32_GERMAN2_CI"] = 180] = "UTF32_GERMAN2_CI";
                Charset[Charset["UTF32_CROATIAN_MYSQL561_CI"] = 181] = "UTF32_CROATIAN_MYSQL561_CI";
                Charset[Charset["UTF32_UNICODE_520_CI"] = 182] = "UTF32_UNICODE_520_CI";
                Charset[Charset["UTF32_VIETNAMESE_CI"] = 183] = "UTF32_VIETNAMESE_CI";
                Charset[Charset["UTF8_UNICODE_CI"] = 192] = "UTF8_UNICODE_CI";
                Charset[Charset["UTF8_ICELANDIC_CI"] = 193] = "UTF8_ICELANDIC_CI";
                Charset[Charset["UTF8_LATVIAN_CI"] = 194] = "UTF8_LATVIAN_CI";
                Charset[Charset["UTF8_ROMANIAN_CI"] = 195] = "UTF8_ROMANIAN_CI";
                Charset[Charset["UTF8_SLOVENIAN_CI"] = 196] = "UTF8_SLOVENIAN_CI";
                Charset[Charset["UTF8_POLISH_CI"] = 197] = "UTF8_POLISH_CI";
                Charset[Charset["UTF8_ESTONIAN_CI"] = 198] = "UTF8_ESTONIAN_CI";
                Charset[Charset["UTF8_SPANISH_CI"] = 199] = "UTF8_SPANISH_CI";
                Charset[Charset["UTF8_SWEDISH_CI"] = 200] = "UTF8_SWEDISH_CI";
                Charset[Charset["UTF8_TURKISH_CI"] = 201] = "UTF8_TURKISH_CI";
                Charset[Charset["UTF8_CZECH_CI"] = 202] = "UTF8_CZECH_CI";
                Charset[Charset["UTF8_DANISH_CI"] = 203] = "UTF8_DANISH_CI";
                Charset[Charset["UTF8_LITHUANIAN_CI"] = 204] = "UTF8_LITHUANIAN_CI";
                Charset[Charset["UTF8_SLOVAK_CI"] = 205] = "UTF8_SLOVAK_CI";
                Charset[Charset["UTF8_SPANISH2_CI"] = 206] = "UTF8_SPANISH2_CI";
                Charset[Charset["UTF8_ROMAN_CI"] = 207] = "UTF8_ROMAN_CI";
                Charset[Charset["UTF8_PERSIAN_CI"] = 208] = "UTF8_PERSIAN_CI";
                Charset[Charset["UTF8_ESPERANTO_CI"] = 209] = "UTF8_ESPERANTO_CI";
                Charset[Charset["UTF8_HUNGARIAN_CI"] = 210] = "UTF8_HUNGARIAN_CI";
                Charset[Charset["UTF8_SINHALA_CI"] = 211] = "UTF8_SINHALA_CI";
                Charset[Charset["UTF8_GERMAN2_CI"] = 212] = "UTF8_GERMAN2_CI";
                Charset[Charset["UTF8_CROATIAN_MYSQL561_CI"] = 213] = "UTF8_CROATIAN_MYSQL561_CI";
                Charset[Charset["UTF8_UNICODE_520_CI"] = 214] = "UTF8_UNICODE_520_CI";
                Charset[Charset["UTF8_VIETNAMESE_CI"] = 215] = "UTF8_VIETNAMESE_CI";
                Charset[Charset["UTF8_GENERAL_MYSQL500_CI"] = 223] = "UTF8_GENERAL_MYSQL500_CI";
                Charset[Charset["UTF8MB4_UNICODE_CI"] = 224] = "UTF8MB4_UNICODE_CI";
                Charset[Charset["UTF8MB4_ICELANDIC_CI"] = 225] = "UTF8MB4_ICELANDIC_CI";
                Charset[Charset["UTF8MB4_LATVIAN_CI"] = 226] = "UTF8MB4_LATVIAN_CI";
                Charset[Charset["UTF8MB4_ROMANIAN_CI"] = 227] = "UTF8MB4_ROMANIAN_CI";
                Charset[Charset["UTF8MB4_SLOVENIAN_CI"] = 228] = "UTF8MB4_SLOVENIAN_CI";
                Charset[Charset["UTF8MB4_POLISH_CI"] = 229] = "UTF8MB4_POLISH_CI";
                Charset[Charset["UTF8MB4_ESTONIAN_CI"] = 230] = "UTF8MB4_ESTONIAN_CI";
                Charset[Charset["UTF8MB4_SPANISH_CI"] = 231] = "UTF8MB4_SPANISH_CI";
                Charset[Charset["UTF8MB4_SWEDISH_CI"] = 232] = "UTF8MB4_SWEDISH_CI";
                Charset[Charset["UTF8MB4_TURKISH_CI"] = 233] = "UTF8MB4_TURKISH_CI";
                Charset[Charset["UTF8MB4_CZECH_CI"] = 234] = "UTF8MB4_CZECH_CI";
                Charset[Charset["UTF8MB4_DANISH_CI"] = 235] = "UTF8MB4_DANISH_CI";
                Charset[Charset["UTF8MB4_LITHUANIAN_CI"] = 236] = "UTF8MB4_LITHUANIAN_CI";
                Charset[Charset["UTF8MB4_SLOVAK_CI"] = 237] = "UTF8MB4_SLOVAK_CI";
                Charset[Charset["UTF8MB4_SPANISH2_CI"] = 238] = "UTF8MB4_SPANISH2_CI";
                Charset[Charset["UTF8MB4_ROMAN_CI"] = 239] = "UTF8MB4_ROMAN_CI";
                Charset[Charset["UTF8MB4_PERSIAN_CI"] = 240] = "UTF8MB4_PERSIAN_CI";
                Charset[Charset["UTF8MB4_ESPERANTO_CI"] = 241] = "UTF8MB4_ESPERANTO_CI";
                Charset[Charset["UTF8MB4_HUNGARIAN_CI"] = 242] = "UTF8MB4_HUNGARIAN_CI";
                Charset[Charset["UTF8MB4_SINHALA_CI"] = 243] = "UTF8MB4_SINHALA_CI";
                Charset[Charset["UTF8MB4_GERMAN2_CI"] = 244] = "UTF8MB4_GERMAN2_CI";
                Charset[Charset["UTF8MB4_CROATIAN_MYSQL561_CI"] = 245] = "UTF8MB4_CROATIAN_MYSQL561_CI";
                Charset[Charset["UTF8MB4_UNICODE_520_CI"] = 246] = "UTF8MB4_UNICODE_520_CI";
                Charset[Charset["UTF8MB4_VIETNAMESE_CI"] = 247] = "UTF8MB4_VIETNAMESE_CI";
                Charset[Charset["UTF8_GENERAL50_CI"] = 253] = "UTF8_GENERAL50_CI";
                Charset[Charset["ARMSCII8"] = 32] = "ARMSCII8";
                Charset[Charset["ASCII"] = 11] = "ASCII";
                Charset[Charset["BIG5"] = 1] = "BIG5";
                Charset[Charset["CP1250"] = 26] = "CP1250";
                Charset[Charset["CP1251"] = 51] = "CP1251";
                Charset[Charset["CP1256"] = 57] = "CP1256";
                Charset[Charset["CP1257"] = 59] = "CP1257";
                Charset[Charset["CP866"] = 36] = "CP866";
                Charset[Charset["CP850"] = 4] = "CP850";
                Charset[Charset["CP852"] = 40] = "CP852";
                Charset[Charset["CP932"] = 95] = "CP932";
                Charset[Charset["DEC8"] = 3] = "DEC8";
                Charset[Charset["EUCJPMS"] = 97] = "EUCJPMS";
                Charset[Charset["EUCKR"] = 19] = "EUCKR";
                Charset[Charset["GB2312"] = 24] = "GB2312";
                Charset[Charset["GBK"] = 28] = "GBK";
                Charset[Charset["GEOSTD8"] = 92] = "GEOSTD8";
                Charset[Charset["GREEK"] = 25] = "GREEK";
                Charset[Charset["HEBREW"] = 16] = "HEBREW";
                Charset[Charset["HP8"] = 6] = "HP8";
                Charset[Charset["KEYBCS2"] = 37] = "KEYBCS2";
                Charset[Charset["KOI8R"] = 7] = "KOI8R";
                Charset[Charset["KOI8U"] = 22] = "KOI8U";
                Charset[Charset["LATIN1"] = 8] = "LATIN1";
                Charset[Charset["LATIN2"] = 9] = "LATIN2";
                Charset[Charset["LATIN5"] = 30] = "LATIN5";
                Charset[Charset["LATIN7"] = 41] = "LATIN7";
                Charset[Charset["MACCE"] = 38] = "MACCE";
                Charset[Charset["MACROMAN"] = 39] = "MACROMAN";
                Charset[Charset["SJIS"] = 13] = "SJIS";
                Charset[Charset["SWE7"] = 10] = "SWE7";
                Charset[Charset["TIS620"] = 18] = "TIS620";
                Charset[Charset["UCS2"] = 35] = "UCS2";
                Charset[Charset["UJIS"] = 12] = "UJIS";
                Charset[Charset["UTF16"] = 54] = "UTF16";
                Charset[Charset["UTF16LE"] = 56] = "UTF16LE";
                Charset[Charset["UTF8"] = 33] = "UTF8";
                Charset[Charset["UTF8MB4"] = 45] = "UTF8MB4";
                Charset[Charset["UTF32"] = 60] = "UTF32";
            })(Charset || (Charset = {}));
            exports_127("Charset", Charset);
        }
    };
});
System.register("https://deno.land/x/mysql@2.1.0/src/packets/parsers/handshake", ["https://deno.land/x/mysql@2.1.0/src/buffer", "https://deno.land/x/mysql@2.1.0/src/constant/capabilities"], function (exports_128, context_128) {
    "use strict";
    var buffer_ts_1, capabilities_ts_1;
    var __moduleName = context_128 && context_128.id;
    /** @ignore */
    function parseHandshake(reader) {
        const protocolVersion = reader.readUint8();
        const serverVersion = reader.readNullTerminatedString();
        const threadId = reader.readUint32();
        const seedWriter = new buffer_ts_1.BufferWriter(new Uint8Array(20));
        seedWriter.writeBuffer(reader.readBuffer(8));
        reader.skip(1);
        let serverCapabilities = reader.readUint16();
        let characterSet = 0, statusFlags = 0, authPluginDataLength = 0, authPluginName = "";
        if (!reader.finished) {
            characterSet = reader.readUint8();
            statusFlags = reader.readUint16();
            serverCapabilities |= reader.readUint16() << 16;
            if ((serverCapabilities & capabilities_ts_1.default.CLIENT_PLUGIN_AUTH) != 0) {
                authPluginDataLength = reader.readUint8();
            }
            else {
                reader.skip(1);
            }
            reader.skip(10);
            if ((serverCapabilities & capabilities_ts_1.default.CLIENT_SECURE_CONNECTION) !=
                0) {
                seedWriter.writeBuffer(reader.readBuffer(Math.max(13, authPluginDataLength - 8)));
            }
            if ((serverCapabilities & capabilities_ts_1.default.CLIENT_PLUGIN_AUTH) != 0) {
                authPluginName = reader.readNullTerminatedString();
            }
        }
        return {
            protocolVersion,
            serverVersion,
            threadId,
            seed: seedWriter.buffer,
            serverCapabilities,
            characterSet,
            statusFlags,
            authPluginName,
        };
    }
    exports_128("parseHandshake", parseHandshake);
    return {
        setters: [
            function (buffer_ts_1_1) {
                buffer_ts_1 = buffer_ts_1_1;
            },
            function (capabilities_ts_1_1) {
                capabilities_ts_1 = capabilities_ts_1_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/mysql@2.1.0/src/packets/builders/auth", ["https://deno.land/x/mysql@2.1.0/src/auth", "https://deno.land/x/mysql@2.1.0/src/buffer", "https://deno.land/x/mysql@2.1.0/src/constant/capabilities", "https://deno.land/x/mysql@2.1.0/src/constant/charset"], function (exports_129, context_129) {
    "use strict";
    var auth_ts_1, buffer_ts_2, capabilities_ts_2, charset_ts_2;
    var __moduleName = context_129 && context_129.id;
    /** @ignore */
    function buildAuth(packet, params) {
        let clientParam = (params.db ? capabilities_ts_2.default.CLIENT_CONNECT_WITH_DB : 0) |
            capabilities_ts_2.default.CLIENT_PLUGIN_AUTH |
            capabilities_ts_2.default.CLIENT_LONG_PASSWORD |
            capabilities_ts_2.default.CLIENT_PROTOCOL_41 |
            capabilities_ts_2.default.CLIENT_TRANSACTIONS |
            capabilities_ts_2.default.CLIENT_MULTI_RESULTS |
            capabilities_ts_2.default.CLIENT_SECURE_CONNECTION;
        if (packet.serverCapabilities & capabilities_ts_2.default.CLIENT_LONG_FLAG) {
            clientParam |= capabilities_ts_2.default.CLIENT_LONG_FLAG;
        }
        if (packet.serverCapabilities &
            capabilities_ts_2.default.CLIENT_PLUGIN_AUTH_LENENC_CLIENT_DATA) {
            clientParam |= capabilities_ts_2.default.CLIENT_PLUGIN_AUTH_LENENC_CLIENT_DATA;
        }
        if (packet.serverCapabilities & capabilities_ts_2.default.CLIENT_DEPRECATE_EOF) {
            clientParam |= capabilities_ts_2.default.CLIENT_DEPRECATE_EOF;
        }
        if (packet.serverCapabilities & capabilities_ts_2.default.CLIENT_PLUGIN_AUTH) {
            const writer = new buffer_ts_2.BufferWriter(new Uint8Array(1000));
            writer
                .writeUint32(clientParam)
                .writeUint32(2 ** 24 - 1)
                .write(charset_ts_2.Charset.UTF8_GENERAL_CI)
                .skip(23)
                .writeNullTerminatedString(params.username);
            if (params.password) {
                const authData = auth_ts_1.default(packet.authPluginName, params.password, packet.seed);
                if (clientParam &
                    capabilities_ts_2.default.CLIENT_PLUGIN_AUTH_LENENC_CLIENT_DATA ||
                    clientParam & capabilities_ts_2.default.CLIENT_SECURE_CONNECTION) {
                    // request lenenc-int length of auth-response and string[n] auth-response
                    writer.write(authData.length);
                    writer.writeBuffer(authData);
                }
                else {
                    writer.writeBuffer(authData);
                    writer.write(0);
                }
            }
            else {
                writer.write(0);
            }
            if (clientParam & capabilities_ts_2.default.CLIENT_CONNECT_WITH_DB && params.db) {
                writer.writeNullTerminatedString(params.db);
            }
            if (clientParam & capabilities_ts_2.default.CLIENT_PLUGIN_AUTH) {
                writer.writeNullTerminatedString(packet.authPluginName);
            }
            return writer.wroteData;
        }
        return Uint8Array.from([]);
    }
    exports_129("buildAuth", buildAuth);
    return {
        setters: [
            function (auth_ts_1_1) {
                auth_ts_1 = auth_ts_1_1;
            },
            function (buffer_ts_2_1) {
                buffer_ts_2 = buffer_ts_2_1;
            },
            function (capabilities_ts_2_1) {
                capabilities_ts_2 = capabilities_ts_2_1;
            },
            function (charset_ts_2_1) {
                charset_ts_2 = charset_ts_2_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/mysql@2.1.0/src/packets/builders/query", ["https://deno.land/x/mysql@2.1.0/deps", "https://deno.land/x/mysql@2.1.0/src/buffer"], function (exports_130, context_130) {
    "use strict";
    var deps_ts_22, buffer_ts_3;
    var __moduleName = context_130 && context_130.id;
    /** @ignore */
    function buildQuery(sql, params = []) {
        const data = deps_ts_22.encode(deps_ts_22.replaceParams(sql, params));
        const writer = new buffer_ts_3.BufferWriter(new Uint8Array(data.length + 1));
        writer.write(0x03);
        writer.writeBuffer(data);
        return writer.buffer;
    }
    exports_130("buildQuery", buildQuery);
    return {
        setters: [
            function (deps_ts_22_1) {
                deps_ts_22 = deps_ts_22_1;
            },
            function (buffer_ts_3_1) {
                buffer_ts_3 = buffer_ts_3_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/mysql@2.1.0/src/packets/packet", ["https://deno.land/x/mysql@2.1.0/deps", "https://deno.land/x/mysql@2.1.0/src/buffer", "https://deno.land/x/mysql@2.1.0/src/constant/errors", "https://deno.land/x/mysql@2.1.0/src/logger"], function (exports_131, context_131) {
    "use strict";
    var deps_ts_23, buffer_ts_4, errors_ts_1, logger_ts_2, SendPacket, ReceivePacket;
    var __moduleName = context_131 && context_131.id;
    return {
        setters: [
            function (deps_ts_23_1) {
                deps_ts_23 = deps_ts_23_1;
            },
            function (buffer_ts_4_1) {
                buffer_ts_4 = buffer_ts_4_1;
            },
            function (errors_ts_1_1) {
                errors_ts_1 = errors_ts_1_1;
            },
            function (logger_ts_2_1) {
                logger_ts_2 = logger_ts_2_1;
            }
        ],
        execute: function () {
            /** @ignore */
            SendPacket = class SendPacket {
                constructor(body, no) {
                    this.body = body;
                    this.header = { size: body.length, no };
                }
                async send(conn) {
                    const body = this.body;
                    const data = new buffer_ts_4.BufferWriter(new Uint8Array(4 + body.length));
                    data.writeUints(3, this.header.size);
                    data.write(this.header.no);
                    data.writeBuffer(body);
                    logger_ts_2.log.debug(`send: ${data.length}B \n${deps_ts_23.byteFormat(data.buffer)}\n`);
                    try {
                        await conn.write(data.buffer);
                    }
                    catch (error) {
                        throw new errors_ts_1.WriteError(error.message);
                    }
                }
            };
            exports_131("SendPacket", SendPacket);
            /** @ignore */
            ReceivePacket = class ReceivePacket {
                async parse(reader) {
                    const header = new buffer_ts_4.BufferReader(new Uint8Array(4));
                    let readCount = 0;
                    let nread = await reader.read(header.buffer);
                    if (nread === null)
                        return null;
                    readCount = nread;
                    this.header = {
                        size: header.readUints(3),
                        no: header.readUint8(),
                    };
                    this.body = new buffer_ts_4.BufferReader(new Uint8Array(this.header.size));
                    nread = await reader.read(this.body.buffer);
                    if (nread === null)
                        return null;
                    readCount += nread;
                    switch (this.body.buffer[0]) {
                        case 0x00:
                            this.type = "OK";
                            break;
                        case 0xff:
                            this.type = "ERR";
                            break;
                        case 0xfe:
                            this.type = "EOF";
                            break;
                        default:
                            this.type = "RESULT";
                            break;
                    }
                    logger_ts_2.debug(() => {
                        const data = new Uint8Array(readCount);
                        data.set(header.buffer);
                        data.set(this.body.buffer, 4);
                        logger_ts_2.log.debug(`receive: ${readCount}B, size = ${this.header.size}, no = ${this.header.no} \n${deps_ts_23.byteFormat(data)}\n`);
                    });
                    return this;
                }
            };
            exports_131("ReceivePacket", ReceivePacket);
        }
    };
});
System.register("https://deno.land/x/mysql@2.1.0/src/packets/parsers/err", ["https://deno.land/x/mysql@2.1.0/src/constant/capabilities"], function (exports_132, context_132) {
    "use strict";
    var capabilities_ts_3;
    var __moduleName = context_132 && context_132.id;
    /** @ignore */
    function parseError(reader, conn) {
        const code = reader.readUint16();
        const packet = {
            code,
            message: "",
        };
        if (conn.capabilities & capabilities_ts_3.default.CLIENT_PROTOCOL_41) {
            packet.sqlStateMarker = reader.readUint8();
            packet.sqlState = reader.readUints(5);
        }
        packet.message = reader.readNullTerminatedString();
        return packet;
    }
    exports_132("parseError", parseError);
    return {
        setters: [
            function (capabilities_ts_3_1) {
                capabilities_ts_3 = capabilities_ts_3_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/mysql@2.1.0/src/constant/mysql_types", [], function (exports_133, context_133) {
    "use strict";
    var MYSQL_TYPE_DECIMAL, MYSQL_TYPE_TINY, MYSQL_TYPE_SHORT, MYSQL_TYPE_LONG, MYSQL_TYPE_FLOAT, MYSQL_TYPE_DOUBLE, MYSQL_TYPE_NULL, MYSQL_TYPE_TIMESTAMP, MYSQL_TYPE_LONGLONG, MYSQL_TYPE_INT24, MYSQL_TYPE_DATE, MYSQL_TYPE_TIME, MYSQL_TYPE_DATETIME, MYSQL_TYPE_YEAR, MYSQL_TYPE_NEWDATE, MYSQL_TYPE_VARCHAR, MYSQL_TYPE_BIT, MYSQL_TYPE_TIMESTAMP2, MYSQL_TYPE_DATETIME2, MYSQL_TYPE_TIME2, MYSQL_TYPE_NEWDECIMAL, MYSQL_TYPE_ENUM, MYSQL_TYPE_SET, MYSQL_TYPE_TINY_BLOB, MYSQL_TYPE_MEDIUM_BLOB, MYSQL_TYPE_LONG_BLOB, MYSQL_TYPE_BLOB, MYSQL_TYPE_VAR_STRING, MYSQL_TYPE_STRING, MYSQL_TYPE_GEOMETRY;
    var __moduleName = context_133 && context_133.id;
    return {
        setters: [],
        execute: function () {
            /** @ignore */
            exports_133("MYSQL_TYPE_DECIMAL", MYSQL_TYPE_DECIMAL = 0x00);
            /** @ignore */
            exports_133("MYSQL_TYPE_TINY", MYSQL_TYPE_TINY = 0x01);
            /** @ignore */
            exports_133("MYSQL_TYPE_SHORT", MYSQL_TYPE_SHORT = 0x02);
            /** @ignore */
            exports_133("MYSQL_TYPE_LONG", MYSQL_TYPE_LONG = 0x03);
            /** @ignore */
            exports_133("MYSQL_TYPE_FLOAT", MYSQL_TYPE_FLOAT = 0x04);
            /** @ignore */
            exports_133("MYSQL_TYPE_DOUBLE", MYSQL_TYPE_DOUBLE = 0x05);
            /** @ignore */
            exports_133("MYSQL_TYPE_NULL", MYSQL_TYPE_NULL = 0x06);
            /** @ignore */
            exports_133("MYSQL_TYPE_TIMESTAMP", MYSQL_TYPE_TIMESTAMP = 0x07);
            /** @ignore */
            exports_133("MYSQL_TYPE_LONGLONG", MYSQL_TYPE_LONGLONG = 0x08);
            /** @ignore */
            exports_133("MYSQL_TYPE_INT24", MYSQL_TYPE_INT24 = 0x09);
            /** @ignore */
            exports_133("MYSQL_TYPE_DATE", MYSQL_TYPE_DATE = 0x0a);
            /** @ignore */
            exports_133("MYSQL_TYPE_TIME", MYSQL_TYPE_TIME = 0x0b);
            /** @ignore */
            exports_133("MYSQL_TYPE_DATETIME", MYSQL_TYPE_DATETIME = 0x0c);
            /** @ignore */
            exports_133("MYSQL_TYPE_YEAR", MYSQL_TYPE_YEAR = 0x0d);
            /** @ignore */
            exports_133("MYSQL_TYPE_NEWDATE", MYSQL_TYPE_NEWDATE = 0x0e);
            /** @ignore */
            exports_133("MYSQL_TYPE_VARCHAR", MYSQL_TYPE_VARCHAR = 0x0f);
            /** @ignore */
            exports_133("MYSQL_TYPE_BIT", MYSQL_TYPE_BIT = 0x10);
            /** @ignore */
            exports_133("MYSQL_TYPE_TIMESTAMP2", MYSQL_TYPE_TIMESTAMP2 = 0x11);
            /** @ignore */
            exports_133("MYSQL_TYPE_DATETIME2", MYSQL_TYPE_DATETIME2 = 0x12);
            /** @ignore */
            exports_133("MYSQL_TYPE_TIME2", MYSQL_TYPE_TIME2 = 0x13);
            /** @ignore */
            exports_133("MYSQL_TYPE_NEWDECIMAL", MYSQL_TYPE_NEWDECIMAL = 0xf6);
            /** @ignore */
            exports_133("MYSQL_TYPE_ENUM", MYSQL_TYPE_ENUM = 0xf7);
            /** @ignore */
            exports_133("MYSQL_TYPE_SET", MYSQL_TYPE_SET = 0xf8);
            /** @ignore */
            exports_133("MYSQL_TYPE_TINY_BLOB", MYSQL_TYPE_TINY_BLOB = 0xf9);
            /** @ignore */
            exports_133("MYSQL_TYPE_MEDIUM_BLOB", MYSQL_TYPE_MEDIUM_BLOB = 0xfa);
            /** @ignore */
            exports_133("MYSQL_TYPE_LONG_BLOB", MYSQL_TYPE_LONG_BLOB = 0xfb);
            /** @ignore */
            exports_133("MYSQL_TYPE_BLOB", MYSQL_TYPE_BLOB = 0xfc);
            /** @ignore */
            exports_133("MYSQL_TYPE_VAR_STRING", MYSQL_TYPE_VAR_STRING = 0xfd);
            /** @ignore */
            exports_133("MYSQL_TYPE_STRING", MYSQL_TYPE_STRING = 0xfe);
            /** @ignore */
            exports_133("MYSQL_TYPE_GEOMETRY", MYSQL_TYPE_GEOMETRY = 0xff);
        }
    };
});
System.register("https://deno.land/x/mysql@2.1.0/src/packets/parsers/result", ["https://deno.land/x/mysql@2.1.0/src/constant/mysql_types"], function (exports_134, context_134) {
    "use strict";
    var mysql_types_ts_1;
    var __moduleName = context_134 && context_134.id;
    /** @ignore */
    function parseField(reader) {
        const catalog = reader.readLenCodeString();
        const schema = reader.readLenCodeString();
        const table = reader.readLenCodeString();
        const originTable = reader.readLenCodeString();
        const name = reader.readLenCodeString();
        const originName = reader.readLenCodeString();
        reader.skip(1);
        const encoding = reader.readUint16();
        const fieldLen = reader.readUint32();
        const fieldType = reader.readUint8();
        const fieldFlag = reader.readUint16();
        const decimals = reader.readUint8();
        reader.skip(1);
        const defaultVal = reader.readLenCodeString();
        return {
            catalog,
            schema,
            table,
            originName,
            fieldFlag,
            originTable,
            fieldLen,
            name,
            fieldType,
            encoding,
            decimals,
            defaultVal,
        };
    }
    exports_134("parseField", parseField);
    /** @ignore */
    function parseRow(reader, fileds) {
        const row = {};
        for (let i = 0; i < fileds.length; i++) {
            const name = fileds[i].name;
            const val = reader.readLenCodeString();
            row[name] = val === null ? null : convertType(fileds[i], val);
        }
        return row;
    }
    exports_134("parseRow", parseRow);
    /** @ignore */
    function convertType(field, val) {
        const { fieldType, fieldLen } = field;
        if (fieldType === mysql_types_ts_1.MYSQL_TYPE_TINY && fieldLen === 1) {
            return !!parseInt(val);
        }
        switch (fieldType) {
            case mysql_types_ts_1.MYSQL_TYPE_DECIMAL:
            case mysql_types_ts_1.MYSQL_TYPE_DOUBLE:
            case mysql_types_ts_1.MYSQL_TYPE_FLOAT:
            case mysql_types_ts_1.MYSQL_TYPE_DATETIME2:
            case mysql_types_ts_1.MYSQL_TYPE_NEWDECIMAL:
                return parseFloat(val);
            case mysql_types_ts_1.MYSQL_TYPE_TINY:
            case mysql_types_ts_1.MYSQL_TYPE_SHORT:
            case mysql_types_ts_1.MYSQL_TYPE_LONG:
            case mysql_types_ts_1.MYSQL_TYPE_LONGLONG:
            case mysql_types_ts_1.MYSQL_TYPE_INT24:
                return parseInt(val);
            case mysql_types_ts_1.MYSQL_TYPE_VARCHAR:
            case mysql_types_ts_1.MYSQL_TYPE_VAR_STRING:
            case mysql_types_ts_1.MYSQL_TYPE_STRING:
            case mysql_types_ts_1.MYSQL_TYPE_TIME:
            case mysql_types_ts_1.MYSQL_TYPE_TIME2:
                return val;
            case mysql_types_ts_1.MYSQL_TYPE_DATE:
            case mysql_types_ts_1.MYSQL_TYPE_TIMESTAMP:
            case mysql_types_ts_1.MYSQL_TYPE_DATETIME:
            case mysql_types_ts_1.MYSQL_TYPE_NEWDATE:
            case mysql_types_ts_1.MYSQL_TYPE_TIMESTAMP2:
            case mysql_types_ts_1.MYSQL_TYPE_DATETIME2:
                return new Date(val);
            default:
                return val;
        }
    }
    return {
        setters: [
            function (mysql_types_ts_1_1) {
                mysql_types_ts_1 = mysql_types_ts_1_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/mysql@2.1.0/src/connection", ["https://deno.land/x/mysql@2.1.0/deps", "https://deno.land/x/mysql@2.1.0/src/constant/errors", "https://deno.land/x/mysql@2.1.0/src/logger", "https://deno.land/x/mysql@2.1.0/src/packets/builders/auth", "https://deno.land/x/mysql@2.1.0/src/packets/builders/query", "https://deno.land/x/mysql@2.1.0/src/packets/packet", "https://deno.land/x/mysql@2.1.0/src/packets/parsers/err", "https://deno.land/x/mysql@2.1.0/src/packets/parsers/handshake", "https://deno.land/x/mysql@2.1.0/src/packets/parsers/result"], function (exports_135, context_135) {
    "use strict";
    var deps_ts_24, errors_ts_2, logger_ts_3, auth_ts_2, query_ts_1, packet_ts_1, err_ts_1, handshake_ts_1, result_ts_1, ConnectionState, Connection;
    var __moduleName = context_135 && context_135.id;
    return {
        setters: [
            function (deps_ts_24_1) {
                deps_ts_24 = deps_ts_24_1;
            },
            function (errors_ts_2_1) {
                errors_ts_2 = errors_ts_2_1;
            },
            function (logger_ts_3_1) {
                logger_ts_3 = logger_ts_3_1;
            },
            function (auth_ts_2_1) {
                auth_ts_2 = auth_ts_2_1;
            },
            function (query_ts_1_1) {
                query_ts_1 = query_ts_1_1;
            },
            function (packet_ts_1_1) {
                packet_ts_1 = packet_ts_1_1;
            },
            function (err_ts_1_1) {
                err_ts_1 = err_ts_1_1;
            },
            function (handshake_ts_1_1) {
                handshake_ts_1 = handshake_ts_1_1;
            },
            function (result_ts_1_1) {
                result_ts_1 = result_ts_1_1;
            }
        ],
        execute: function () {
            /**
             * Connection state
             */
            (function (ConnectionState) {
                ConnectionState[ConnectionState["CONNECTING"] = 0] = "CONNECTING";
                ConnectionState[ConnectionState["CONNECTED"] = 1] = "CONNECTED";
                ConnectionState[ConnectionState["COLSING"] = 2] = "COLSING";
                ConnectionState[ConnectionState["CLOSED"] = 3] = "CLOSED";
            })(ConnectionState || (ConnectionState = {}));
            exports_135("ConnectionState", ConnectionState);
            /** Connection for mysql */
            Connection = class Connection {
                constructor(client) {
                    this.client = client;
                    this.state = ConnectionState.CONNECTING;
                    this.capabilities = 0;
                    this.serverVersion = "";
                }
                async _connect() {
                    const { hostname, port = 3306 } = this.client.config;
                    logger_ts_3.log.info(`connecting ${hostname}:${port}`);
                    this.conn = await Deno.connect({
                        hostname,
                        port,
                        transport: "tcp",
                    });
                    let receive = await this.nextPacket();
                    const handshakePacket = handshake_ts_1.parseHandshake(receive.body);
                    const data = auth_ts_2.buildAuth(handshakePacket, {
                        username: this.client.config.username ?? "",
                        password: this.client.config.password,
                        db: this.client.config.db,
                    });
                    await new packet_ts_1.SendPacket(data, 0x1).send(this.conn);
                    this.state = ConnectionState.CONNECTING;
                    this.serverVersion = handshakePacket.serverVersion;
                    this.capabilities = handshakePacket.serverCapabilities;
                    receive = await this.nextPacket();
                    const header = receive.body.readUint8();
                    if (header === 0xff) {
                        const error = err_ts_1.parseError(receive.body, this);
                        logger_ts_3.log.error(`connect error(${error.code}): ${error.message}`);
                        this.close();
                        throw new Error(error.message);
                    }
                    else {
                        logger_ts_3.log.info(`connected to ${this.client.config.hostname}`);
                        this.state = ConnectionState.CONNECTED;
                    }
                    if (this.client.config.charset) {
                        await this.execute(`SET NAMES ${this.client.config.charset}`);
                    }
                }
                /** Connect to database */
                async connect() {
                    await this._connect();
                }
                async nextPacket() {
                    let eofCount = 0;
                    const timeout = this.client.config.timeout || 1000;
                    while (this.conn) {
                        const packet = await new packet_ts_1.ReceivePacket().parse(this.conn);
                        if (packet) {
                            if (packet.type === "ERR") {
                                packet.body.skip(1);
                                const error = err_ts_1.parseError(packet.body, this);
                                throw new Error(error.message);
                            }
                            return packet;
                        }
                        else {
                            await deps_ts_24.delay(100);
                            if (eofCount++ * 100 >= timeout) {
                                throw new errors_ts_2.ResponseTimeoutError("Read packet timeout");
                            }
                        }
                    }
                    throw new Error("Not connected");
                }
                /**
                 * Check if database server version is less than 5.7.0
                 *
                 * MySQL version is "x.y.z"
                 *   eg "5.5.62"
                 *
                 * MariaDB version is "5.5.5-x.y.z-MariaDB[-build-infos]" for versions after 5 (10.0 etc)
                 *   eg "5.5.5-10.4.10-MariaDB-1:10.4.10+maria~bionic"
                 * and "x.y.z-MariaDB-[build-infos]" for 5.x versions
                 *   eg "5.5.64-MariaDB-1~trusty"
                 */
                lessThan57() {
                    const version = this.serverVersion;
                    if (!version.includes("MariaDB"))
                        return version < "5.7.0";
                    const segments = version.split("-");
                    // MariaDB v5.x
                    if (segments[1] === "MariaDB")
                        return segments[0] < "5.7.0";
                    // MariaDB v10+
                    return false;
                }
                /** Close database connection */
                close() {
                    logger_ts_3.log.info("close connection");
                    this.state = ConnectionState.COLSING;
                    this.conn && this.conn.close();
                    this.state = ConnectionState.CLOSED;
                }
                /**
                 * excute query sql
                 * @param sql query sql string
                 * @param params query params
                 */
                async query(sql, params) {
                    const result = await this.execute(sql, params);
                    if (result && result.rows) {
                        return result.rows;
                    }
                    else {
                        return result;
                    }
                }
                /**
                 * excute sql
                 * @param sql sql string
                 * @param params query params
                 */
                async execute(sql, params) {
                    if (!this.conn) {
                        throw new Error("Must be connected first");
                    }
                    const data = query_ts_1.buildQuery(sql, params);
                    await new packet_ts_1.SendPacket(data, 0).send(this.conn);
                    let receive = await this.nextPacket();
                    if (receive.type === "OK") {
                        receive.body.skip(1);
                        return {
                            affectedRows: receive.body.readEncodedLen(),
                            lastInsertId: receive.body.readEncodedLen(),
                        };
                    }
                    let fieldCount = receive.body.readEncodedLen();
                    const fields = [];
                    while (fieldCount--) {
                        const packet = await this.nextPacket();
                        if (packet) {
                            const field = result_ts_1.parseField(packet.body);
                            fields.push(field);
                        }
                    }
                    const rows = [];
                    if (this.lessThan57()) {
                        // EOF(less than 5.7)
                        receive = await this.nextPacket();
                    }
                    while (true) {
                        receive = await this.nextPacket();
                        if (receive.type === "EOF") {
                            break;
                        }
                        else {
                            const row = result_ts_1.parseRow(receive.body, fields);
                            rows.push(row);
                        }
                    }
                    return { rows, fields };
                }
            };
            exports_135("Connection", Connection);
        }
    };
});
System.register("https://deno.land/x/mysql@2.1.0/src/deferred", ["https://deno.land/x/mysql@2.1.0/deps"], function (exports_136, context_136) {
    "use strict";
    var deps_ts_25, DeferredStack;
    var __moduleName = context_136 && context_136.id;
    return {
        setters: [
            function (deps_ts_25_1) {
                deps_ts_25 = deps_ts_25_1;
            }
        ],
        execute: function () {
            /** @ignore */
            DeferredStack = class DeferredStack {
                constructor(_maxSize, _array = [], creator) {
                    this._maxSize = _maxSize;
                    this._array = _array;
                    this.creator = creator;
                    this._queue = [];
                    this._size = 0;
                    this._size = _array.length;
                }
                get size() {
                    return this._size;
                }
                get maxSize() {
                    return this._maxSize;
                }
                get available() {
                    return this._array.length;
                }
                async pop() {
                    if (this._array.length) {
                        return this._array.pop();
                    }
                    else if (this._size < this._maxSize) {
                        this._size++;
                        const item = await this.creator();
                        return item;
                    }
                    const defer = deps_ts_25.deferred();
                    this._queue.push(defer);
                    await defer;
                    return this._array.pop();
                }
                async push(item) {
                    this._array.push(item);
                    if (this._queue.length) {
                        this._queue.shift().resolve();
                    }
                }
                reduceSize() {
                    this._size--;
                }
            };
            exports_136("DeferredStack", DeferredStack);
        }
    };
});
System.register("https://deno.land/x/mysql@2.1.0/src/client", ["https://deno.land/x/mysql@2.1.0/src/connection", "https://deno.land/x/mysql@2.1.0/src/constant/errors", "https://deno.land/x/mysql@2.1.0/src/deferred", "https://deno.land/x/mysql@2.1.0/src/logger"], function (exports_137, context_137) {
    "use strict";
    var connection_ts_1, errors_ts_3, deferred_ts_6, logger_ts_4, Client;
    var __moduleName = context_137 && context_137.id;
    return {
        setters: [
            function (connection_ts_1_1) {
                connection_ts_1 = connection_ts_1_1;
            },
            function (errors_ts_3_1) {
                errors_ts_3 = errors_ts_3_1;
            },
            function (deferred_ts_6_1) {
                deferred_ts_6 = deferred_ts_6_1;
            },
            function (logger_ts_4_1) {
                logger_ts_4 = logger_ts_4_1;
            }
        ],
        execute: function () {
            /**
             * MySQL client
             */
            Client = class Client {
                constructor() {
                    this.config = {};
                    this._connections = [];
                }
                async createConnection() {
                    let connection = new connection_ts_1.Connection(this);
                    await connection.connect();
                    return connection;
                }
                /** get pool info */
                get pool() {
                    if (this._pool) {
                        return {
                            size: this._pool.size,
                            maxSize: this._pool.maxSize,
                            available: this._pool.available,
                        };
                    }
                }
                /**
                 * connect to database
                 * @param config config for client
                 * @returns Clinet instance
                 */
                async connect(config) {
                    this.config = {
                        hostname: "127.0.0.1",
                        username: "root",
                        port: 3306,
                        poolSize: 1,
                        ...config,
                    };
                    Object.freeze(this.config);
                    this._connections = [];
                    this._pool = new deferred_ts_6.DeferredStack(this.config.poolSize || 10, this._connections, this.createConnection.bind(this));
                    return this;
                }
                /**
                 * excute query sql
                 * @param sql query sql string
                 * @param params query params
                 */
                async query(sql, params) {
                    return await this.useConnection(async (connection) => {
                        return await connection.query(sql, params);
                    });
                }
                /**
                 * excute sql
                 * @param sql sql string
                 * @param params query params
                 */
                async execute(sql, params) {
                    return await this.useConnection(async (connection) => {
                        return await connection.execute(sql, params);
                    });
                }
                async useConnection(fn) {
                    if (!this._pool) {
                        throw new Error("Unconnected");
                    }
                    const connection = await this._pool.pop();
                    try {
                        const result = await fn(connection);
                        this._pool.push(connection);
                        return result;
                    }
                    catch (error) {
                        if (error instanceof errors_ts_3.WriteError ||
                            error instanceof errors_ts_3.ResponseTimeoutError) {
                            this._pool.reduceSize();
                        }
                        else {
                            this._pool.push(connection);
                        }
                        throw error;
                    }
                }
                /**
                 * Execute a transaction process, and the transaction successfully
                 * returns the return value of the transaction process
                 * @param processor transation processor
                 */
                async transaction(processor) {
                    return await this.useConnection(async (connection) => {
                        try {
                            await connection.execute("BEGIN");
                            const result = await processor(connection);
                            await connection.execute("COMMIT");
                            return result;
                        }
                        catch (error) {
                            logger_ts_4.log.info(`ROLLBACK: ${error.message}`);
                            await connection.execute("ROLLBACK");
                            throw error;
                        }
                    });
                }
                /**
                 * close connection
                 */
                async close() {
                    await Promise.all(this._connections.map((conn) => conn.close()));
                }
            };
            exports_137("Client", Client);
        }
    };
});
System.register("https://deno.land/x/mysql@2.1.0/mod", ["https://deno.land/x/mysql@2.1.0/src/client", "https://deno.land/x/mysql@2.1.0/src/connection"], function (exports_138, context_138) {
    "use strict";
    var __moduleName = context_138 && context_138.id;
    return {
        setters: [
            function (client_ts_1_1) {
                exports_138({
                    "Client": client_ts_1_1["Client"]
                });
            },
            function (connection_ts_2_1) {
                exports_138({
                    "Connection": connection_ts_2_1["Connection"]
                });
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/sql_builder@1.5.0/util", [], function (exports_139, context_139) {
    "use strict";
    var __moduleName = context_139 && context_139.id;
    function replaceParams(sql, params) {
        if (!params)
            return sql;
        let paramIndex = 0;
        sql = sql.replace(/('.*')|(".*")|(\?\?)|(\?)/g, (str) => {
            if (paramIndex >= params.length)
                return str;
            // ignore
            if (/".*"/g.test(str) || /'.*'/g.test(str)) {
                return str;
            }
            // identifier
            if (str === "??") {
                const val = params[paramIndex++];
                if (val instanceof Array) {
                    return `(${val.map((item) => replaceParams("??", [item])).join(",")})`;
                }
                else if (val === "*") {
                    return val;
                }
                else if (typeof val === "string" && val.indexOf(".") > -1) {
                    // a.b => `a`.`b`
                    const _arr = val.split(".");
                    return replaceParams(_arr.map(() => "??").join("."), _arr);
                }
                else if (typeof val === "string" &&
                    (val.toLowerCase().indexOf(" as ") > -1 ||
                        val.toLowerCase().indexOf(" AS ") > -1)) {
                    // a as b => `a` AS `b`
                    const newVal = val.replace(" as ", " AS ");
                    const _arr = newVal.split(" AS ");
                    return replaceParams(_arr.map(() => "??").join(" AS "), _arr);
                }
                else {
                    return ["`", val, "`"].join("");
                }
            }
            // value
            const val = params[paramIndex++];
            if (val === null)
                return "NULL";
            switch (typeof val) {
                case "object":
                    if (val instanceof Date)
                        return `"${formatDate(val)}"`;
                    if (val instanceof Array) {
                        return `(${val.map((item) => replaceParams("?", [item])).join(",")})`;
                    }
                case "string":
                    return `"${escapeString(val)}"`;
                case "undefined":
                    return "NULL";
                case "number":
                case "boolean":
                default:
                    return val;
            }
        });
        return sql;
    }
    exports_139("replaceParams", replaceParams);
    function formatDate(date) {
        const year = date.getFullYear();
        const month = (date.getMonth() + 1).toString().padStart(2, "0");
        const days = date
            .getDate()
            .toString()
            .padStart(2, "0");
        const hours = date
            .getHours()
            .toString()
            .padStart(2, "0");
        const minutes = date
            .getMinutes()
            .toString()
            .padStart(2, "0");
        const seconds = date
            .getSeconds()
            .toString()
            .padStart(2, "0");
        return `${year}-${month}-${days} ${hours}:${minutes}:${seconds}`;
    }
    function escapeString(str) {
        return str.replace(/"/g, '\\"');
    }
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/sql_builder@1.5.0/join", ["https://deno.land/x/sql_builder@1.5.0/util"], function (exports_140, context_140) {
    "use strict";
    var util_ts_12, Join;
    var __moduleName = context_140 && context_140.id;
    return {
        setters: [
            function (util_ts_12_1) {
                util_ts_12 = util_ts_12_1;
            }
        ],
        execute: function () {
            Join = class Join {
                constructor(type, table, alias) {
                    this.table = table;
                    this.alias = alias;
                    this.value = "";
                    const name = alias ? "?? ??" : "??";
                    this.value = util_ts_12.replaceParams(`${type} ${name}`, [table, alias]);
                }
                static inner(table, alias) {
                    return new Join("INNER JOIN", table, alias);
                }
                static full(table, alias) {
                    return new Join("FULL OUTER JOIN", table, alias);
                }
                static left(table, alias) {
                    return new Join("LEFT OUTER JOIN", table, alias);
                }
                static right(table, alias) {
                    return new Join("RIGHT OUTER JOIN", table, alias);
                }
                on(a, b) {
                    this.value += util_ts_12.replaceParams(` ON ?? = ??`, [a, b]);
                    return this;
                }
            };
            exports_140("Join", Join);
        }
    };
});
System.register("https://deno.land/x/sql_builder@1.5.0/order", ["https://deno.land/x/sql_builder@1.5.0/util"], function (exports_141, context_141) {
    "use strict";
    var util_ts_13, Order;
    var __moduleName = context_141 && context_141.id;
    return {
        setters: [
            function (util_ts_13_1) {
                util_ts_13 = util_ts_13_1;
            }
        ],
        execute: function () {
            Order = class Order {
                constructor() {
                    this.value = "";
                }
                static by(field) {
                    const order = new Order();
                    return {
                        get desc() {
                            order.value = util_ts_13.replaceParams("?? DESC", [field]);
                            return order;
                        },
                        get asc() {
                            order.value = util_ts_13.replaceParams("?? ASC", [field]);
                            return order;
                        },
                    };
                }
            };
            exports_141("Order", Order);
        }
    };
});
System.register("https://deno.land/x/sql_builder@1.5.0/deps", ["https://deno.land/std@v0.51.0/testing/asserts", "https://deno.land/x/sql_builder@1.5.0/util"], function (exports_142, context_142) {
    "use strict";
    var __moduleName = context_142 && context_142.id;
    return {
        setters: [
            function (asserts_ts_4_1) {
                exports_142({
                    "assert": asserts_ts_4_1["assert"],
                    "assertEquals": asserts_ts_4_1["assertEquals"]
                });
            },
            function (util_ts_14_1) {
                exports_142({
                    "replaceParams": util_ts_14_1["replaceParams"]
                });
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/sql_builder@1.5.0/where", ["https://deno.land/x/sql_builder@1.5.0/util"], function (exports_143, context_143) {
    "use strict";
    var util_ts_15, Where;
    var __moduleName = context_143 && context_143.id;
    return {
        setters: [
            function (util_ts_15_1) {
                util_ts_15 = util_ts_15_1;
            }
        ],
        execute: function () {
            /**
             * Where sub sql builder
             */
            Where = class Where {
                constructor(expr, params) {
                    this.expr = expr;
                    this.params = params;
                }
                get value() {
                    return this.toString();
                }
                toString() {
                    return util_ts_15.replaceParams(this.expr, this.params);
                }
                static expr(expr, ...params) {
                    return new Where(expr, params);
                }
                static eq(field, value) {
                    return this.expr("?? = ?", field, value);
                }
                /**
                 * eq from object
                 * @param data
                 */
                static from(data) {
                    const conditions = Object.keys(data).map((key) => this.eq(key, data[key]));
                    return this.and(...conditions);
                }
                static gt(field, value) {
                    return this.expr("?? > ?", field, value);
                }
                static gte(field, value) {
                    return this.expr("?? >= ?", field, value);
                }
                static lt(field, value) {
                    return this.expr("?? < ?", field, value);
                }
                static lte(field, value) {
                    return this.expr("?? <= ?", field, value);
                }
                static ne(field, value) {
                    return this.expr("?? != ?", field, value);
                }
                static isNull(field) {
                    return this.expr("?? IS NULL", field);
                }
                static notNull(field) {
                    return this.expr("?? NOT NULL", field);
                }
                static in(field, ...values) {
                    const params = values.length > 1 ? values : values[0];
                    return this.expr("?? IN ?", field, params);
                }
                static notIn(field, ...values) {
                    const params = values.length > 1 ? values : values[0];
                    return this.expr("?? NOT IN ?", field, params);
                }
                static like(field, value) {
                    return this.expr("?? LIKE ?", field, value);
                }
                static between(field, startValue, endValue) {
                    return this.expr("?? BETWEEN ? AND ?", field, startValue, endValue);
                }
                static field(name) {
                    return {
                        gt: (value) => this.gt(name, value),
                        gte: (value) => this.gte(name, value),
                        lt: (value) => this.lt(name, value),
                        lte: (value) => this.lte(name, value),
                        ne: (value) => this.ne(name, value),
                        eq: (value) => this.eq(name, value),
                        isNull: () => this.isNull(name),
                        notNull: () => this.notNull(name),
                        in: (...values) => this.in(name, ...values),
                        notIn: (...values) => this.notIn(name, ...values),
                        like: (value) => this.like(name, value),
                        between: (start, end) => this.between(name, start, end),
                    };
                }
                static and(...expr) {
                    const sql = `(${expr
                        .filter((e) => e)
                        .map((e) => e.value)
                        .join(" AND ")})`;
                    return new Where(sql, []);
                }
                static or(...expr) {
                    const sql = `(${expr
                        .filter((e) => e)
                        .map((e) => e.value)
                        .join(" OR ")})`;
                    return new Where(sql, []);
                }
            };
            exports_143("Where", Where);
        }
    };
});
System.register("https://deno.land/x/sql_builder@1.5.0/query", ["https://deno.land/x/sql_builder@1.5.0/deps"], function (exports_144, context_144) {
    "use strict";
    var deps_ts_26, Query;
    var __moduleName = context_144 && context_144.id;
    return {
        setters: [
            function (deps_ts_26_1) {
                deps_ts_26 = deps_ts_26_1;
            }
        ],
        execute: function () {
            Query = class Query {
                constructor() {
                    this._where = [];
                    this._joins = [];
                    this._orders = [];
                    this._fields = [];
                    this._groupBy = [];
                    this._having = [];
                    this._insertValues = [];
                }
                get orderSQL() {
                    if (this._orders && this._orders.length) {
                        return `ORDER BY ` + this._orders.map((order) => order.value).join(", ");
                    }
                }
                get whereSQL() {
                    if (this._where && this._where.length) {
                        return `WHERE ` + this._where.join(" AND ");
                    }
                }
                get havingSQL() {
                    if (this._having && this._having.length) {
                        return `HAVING ` + this._having.join(" AND ");
                    }
                }
                get joinSQL() {
                    if (this._joins && this._joins.length) {
                        return this._joins.join(" ");
                    }
                }
                get groupSQL() {
                    if (this._groupBy && this._groupBy.length) {
                        return ("GROUP BY " +
                            this._groupBy.map((f) => deps_ts_26.replaceParams("??", [f])).join(", "));
                    }
                }
                get limitSQL() {
                    if (this._limit) {
                        return `LIMIT ${this._limit.start}, ${this._limit.size}`;
                    }
                }
                get selectSQL() {
                    return [
                        "SELECT",
                        this._fields.join(", "),
                        "FROM",
                        deps_ts_26.replaceParams("??", [this._table]),
                        this.joinSQL,
                        this.whereSQL,
                        this.groupSQL,
                        this.havingSQL,
                        this.orderSQL,
                        this.limitSQL,
                    ]
                        .filter((str) => str)
                        .join(" ");
                }
                get insertSQL() {
                    const len = this._insertValues.length;
                    const fields = Object.keys(this._insertValues[0]);
                    const values = this._insertValues.map((row) => {
                        return fields.map((key) => row[key]);
                    });
                    return deps_ts_26.replaceParams(`INSERT INTO ?? ?? VALUES ${"? ".repeat(len)}`, [
                        this._table,
                        fields,
                        ...values,
                    ]);
                }
                get updateSQL() {
                    deps_ts_26.assert(!!this._updateValue);
                    const set = Object.keys(this._updateValue)
                        .map((key) => {
                        return deps_ts_26.replaceParams(`?? = ?`, [key, this._updateValue[key]]);
                    })
                        .join(", ");
                    return [
                        deps_ts_26.replaceParams(`UPDATE ?? SET ${set}`, [this._table]),
                        this.whereSQL,
                    ].join(" ");
                }
                get deleteSQL() {
                    return [deps_ts_26.replaceParams(`DELETE FROM ??`, [this._table]), this.whereSQL].join(" ");
                }
                table(name) {
                    this._table = name;
                    return this;
                }
                order(...orders) {
                    this._orders = this._orders.concat(orders);
                    return this;
                }
                groupBy(...fields) {
                    this._groupBy = fields;
                    return this;
                }
                where(where) {
                    if (typeof where === "string") {
                        this._where.push(where);
                    }
                    else {
                        this._where.push(where.value);
                    }
                    return this;
                }
                having(where) {
                    if (typeof where === "string") {
                        this._having.push(where);
                    }
                    else {
                        this._having.push(where.value);
                    }
                    return this;
                }
                limit(start, size) {
                    this._limit = { start, size };
                    return this;
                }
                join(join) {
                    if (typeof join === "string") {
                        this._joins.push(join);
                    }
                    else {
                        this._joins.push(join.value);
                    }
                    return this;
                }
                select(...fields) {
                    this._type = "select";
                    deps_ts_26.assert(fields.length > 0);
                    this._fields = this._fields.concat(fields.map((field) => {
                        if (field.toLocaleLowerCase().indexOf(" as ") > -1) {
                            return field;
                        }
                        else if (field.split(".").length > 1) {
                            return deps_ts_26.replaceParams("??.??", field.split("."));
                        }
                        else {
                            return deps_ts_26.replaceParams("??", [field]);
                        }
                    }));
                    return this;
                }
                insert(data) {
                    this._type = "insert";
                    if (!(data instanceof Array)) {
                        data = [data];
                    }
                    this._insertValues = data;
                    return this;
                }
                update(data) {
                    this._type = "update";
                    this._updateValue = data;
                    return this;
                }
                delete(table) {
                    if (table)
                        this._table = table;
                    this._type = "delete";
                    return this;
                }
                build() {
                    deps_ts_26.assert(!!this._table);
                    switch (this._type) {
                        case "select":
                            return this.selectSQL;
                        case "insert":
                            return this.insertSQL;
                        case "update":
                            return this.updateSQL;
                        case "delete":
                            return this.deleteSQL;
                        default:
                            return "";
                    }
                }
            };
            exports_144("Query", Query);
        }
    };
});
System.register("https://deno.land/x/sql_builder@1.5.0/mod", ["https://deno.land/x/sql_builder@1.5.0/join", "https://deno.land/x/sql_builder@1.5.0/order", "https://deno.land/x/sql_builder@1.5.0/query", "https://deno.land/x/sql_builder@1.5.0/util", "https://deno.land/x/sql_builder@1.5.0/where"], function (exports_145, context_145) {
    "use strict";
    var __moduleName = context_145 && context_145.id;
    return {
        setters: [
            function (join_ts_1_1) {
                exports_145({
                    "Join": join_ts_1_1["Join"]
                });
            },
            function (order_ts_1_1) {
                exports_145({
                    "Order": order_ts_1_1["Order"]
                });
            },
            function (query_ts_2_1) {
                exports_145({
                    "Query": query_ts_2_1["Query"]
                });
            },
            function (util_ts_16_1) {
                exports_145({
                    "replaceParams": util_ts_16_1["replaceParams"]
                });
            },
            function (where_ts_1_1) {
                exports_145({
                    "Where": where_ts_1_1["Where"]
                });
            }
        ],
        execute: function () {
        }
    };
});
// @ts-nocheck
/*! *****************************************************************************
Copyright (C) Microsoft. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0
THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.
See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var Reflect;
// @ts-nocheck
/*! *****************************************************************************
Copyright (C) Microsoft. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0
THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.
See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
(function (Reflect) {
    // Metadata Proposal
    // https://rbuckton.github.io/reflect-metadata/
    (function (factory) {
        var self;
        const root = typeof global === "object"
            ? global
            : typeof self === "object"
                ? self
                : typeof this === "object"
                    ? this
                    : Function("return this;")();
        let exporter = makeExporter(Reflect);
        if (typeof root.Reflect === "undefined") {
            root.Reflect = Reflect;
        }
        else {
            exporter = makeExporter(root.Reflect, exporter);
        }
        factory(exporter);
        function makeExporter(target, previous) {
            return (key, value) => {
                if (typeof target[key] !== "function") {
                    Object.defineProperty(target, key, {
                        configurable: true,
                        writable: true,
                        value,
                    });
                }
                if (previous)
                    previous(key, value);
            };
        }
    })(function (exporter) {
        const hasOwn = Object.prototype.hasOwnProperty;
        // feature test for Symbol support
        const supportsSymbol = typeof Symbol === "function";
        const toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined"
            ? Symbol.toPrimitive
            : "@@toPrimitive";
        const iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined"
            ? Symbol.iterator
            : "@@iterator";
        const supportsCreate = typeof Object.create === "function"; // feature test for Object.create support
        const supportsProto = { __proto__: [] } instanceof Array; // feature test for __proto__ support
        const downLevel = !supportsCreate && !supportsProto;
        const HashMap = {
            // create an object in dictionary mode (a.k.a. "slow" mode in v8)
            create: supportsCreate
                ? () => MakeDictionary(Object.create(null))
                : supportsProto
                    ? () => MakeDictionary({ __proto__: null })
                    : () => MakeDictionary({}),
            has: downLevel
                ? (map, key) => hasOwn.call(map, key)
                : (map, key) => key in map,
            get: downLevel
                ? (map, key) => hasOwn.call(map, key) ? map[key] : undefined
                : (map, key) => map[key],
        };
        // Load global or shim versions of Map, Set, and WeakMap
        const functionPrototype = Object.getPrototypeOf(Function);
        const usePolyfill = typeof process === "object" &&
            process.env &&
            process.env["REFLECT_METADATA_USE_MAP_POLYFILL"] === "true";
        const _Map = !usePolyfill &&
            typeof Map === "function" &&
            typeof Map.prototype.entries === "function"
            ? Map
            : CreateMapPolyfill();
        const _Set = !usePolyfill &&
            typeof Set === "function" &&
            typeof Set.prototype.entries === "function"
            ? Set
            : CreateSetPolyfill();
        const _WeakMap = !usePolyfill && typeof WeakMap === "function"
            ? WeakMap
            : CreateWeakMapPolyfill();
        // [[Metadata]] internal slot
        // https://rbuckton.github.io/reflect-metadata/#ordinary-object-internal-methods-and-internal-slots
        const Metadata = new _WeakMap();
        /**
         * Applies a set of decorators to a property of a target object.
         * @param decorators An array of decorators.
         * @param target The target object.
         * @param propertyKey (Optional) The property key to decorate.
         * @param attributes (Optional) The property descriptor for the target key.
         * @remarks Decorators are applied in reverse order.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     Example = Reflect.decorate(decoratorsArray, Example);
         *
         *     // property (on constructor)
         *     Reflect.decorate(decoratorsArray, Example, "staticProperty");
         *
         *     // property (on prototype)
         *     Reflect.decorate(decoratorsArray, Example.prototype, "property");
         *
         *     // method (on constructor)
         *     Object.defineProperty(Example, "staticMethod",
         *         Reflect.decorate(decoratorsArray, Example, "staticMethod",
         *             Object.getOwnPropertyDescriptor(Example, "staticMethod")));
         *
         *     // method (on prototype)
         *     Object.defineProperty(Example.prototype, "method",
         *         Reflect.decorate(decoratorsArray, Example.prototype, "method",
         *             Object.getOwnPropertyDescriptor(Example.prototype, "method")));
         *
         */
        function decorate(decorators, target, propertyKey, attributes) {
            if (!IsUndefined(propertyKey)) {
                if (!IsArray(decorators))
                    throw new TypeError();
                if (!IsObject(target))
                    throw new TypeError();
                if (!IsObject(attributes) &&
                    !IsUndefined(attributes) &&
                    !IsNull(attributes)) {
                    throw new TypeError();
                }
                if (IsNull(attributes))
                    attributes = undefined;
                propertyKey = ToPropertyKey(propertyKey);
                return DecorateProperty(decorators, target, propertyKey, attributes);
            }
            else {
                if (!IsArray(decorators))
                    throw new TypeError();
                if (!IsConstructor(target))
                    throw new TypeError();
                return DecorateConstructor(decorators, target);
            }
        }
        exporter("decorate", decorate);
        // 4.1.2 Reflect.metadata(metadataKey, metadataValue)
        // https://rbuckton.github.io/reflect-metadata/#reflect.metadata
        /**
         * A default metadata decorator factory that can be used on a class, class member, or parameter.
         * @param metadataKey The key for the metadata entry.
         * @param metadataValue The value for the metadata entry.
         * @returns A decorator function.
         * @remarks
         * If `metadataKey` is already defined for the target and target key, the
         * metadataValue for that key will be overwritten.
         * @example
         *
         *     // constructor
         *     @Reflect.metadata(key, value)
         *     class Example {
         *     }
         *
         *     // property (on constructor, TypeScript only)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         static staticProperty;
         *     }
         *
         *     // property (on prototype, TypeScript only)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         property;
         *     }
         *
         *     // method (on constructor)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         static staticMethod() { }
         *     }
         *
         *     // method (on prototype)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         method() { }
         *     }
         *
         */
        function metadata(metadataKey, metadataValue) {
            function decorator(target, propertyKey) {
                if (!IsObject(target))
                    throw new TypeError();
                if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey)) {
                    throw new TypeError();
                }
                OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
            }
            return decorator;
        }
        exporter("metadata", metadata);
        /**
         * Define a unique metadata entry on the target.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param metadataValue A value that contains attached metadata.
         * @param target The target object on which to define metadata.
         * @param propertyKey (Optional) The property key for the target.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     Reflect.defineMetadata("custom:annotation", options, Example);
         *
         *     // property (on constructor)
         *     Reflect.defineMetadata("custom:annotation", options, Example, "staticProperty");
         *
         *     // property (on prototype)
         *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "property");
         *
         *     // method (on constructor)
         *     Reflect.defineMetadata("custom:annotation", options, Example, "staticMethod");
         *
         *     // method (on prototype)
         *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "method");
         *
         *     // decorator factory as metadata-producing annotation.
         *     function MyAnnotation(options): Decorator {
         *         return (target, key?) => Reflect.defineMetadata("custom:annotation", options, target, key);
         *     }
         *
         */
        function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
        }
        exporter("defineMetadata", defineMetadata);
        /**
         * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.hasMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.hasMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.hasMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function hasMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryHasMetadata(metadataKey, target, propertyKey);
        }
        exporter("hasMetadata", hasMetadata);
        /**
         * Gets a value indicating whether the target object has the provided metadata key defined.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata key was defined on the target object; otherwise, `false`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function hasOwnMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
        }
        exporter("hasOwnMetadata", hasOwnMetadata);
        /**
         * Gets the metadata value for the provided metadata key on the target object or its prototype chain.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function getMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryGetMetadata(metadataKey, target, propertyKey);
        }
        exporter("getMetadata", getMetadata);
        /**
         * Gets the metadata value for the provided metadata key on the target object.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getOwnMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function getOwnMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
        }
        exporter("getOwnMetadata", getOwnMetadata);
        /**
         * Gets the metadata keys defined on the target object or its prototype chain.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns An array of unique metadata keys.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getMetadataKeys(Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getMetadataKeys(Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getMetadataKeys(Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getMetadataKeys(Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getMetadataKeys(Example.prototype, "method");
         *
         */
        function getMetadataKeys(target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryMetadataKeys(target, propertyKey);
        }
        exporter("getMetadataKeys", getMetadataKeys);
        /**
         * Gets the unique metadata keys defined on the target object.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns An array of unique metadata keys.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getOwnMetadataKeys(Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getOwnMetadataKeys(Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getOwnMetadataKeys(Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getOwnMetadataKeys(Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getOwnMetadataKeys(Example.prototype, "method");
         *
         */
        function getOwnMetadataKeys(target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryOwnMetadataKeys(target, propertyKey);
        }
        exporter("getOwnMetadataKeys", getOwnMetadataKeys);
        /**
         * Deletes the metadata entry from the target object with the provided key.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata entry was found and deleted; otherwise, false.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.deleteMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function deleteMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            const metadataMap = GetOrCreateMetadataMap(target, propertyKey, 
            /*Create*/ false);
            if (IsUndefined(metadataMap))
                return false;
            if (!metadataMap.delete(metadataKey))
                return false;
            if (metadataMap.size > 0)
                return true;
            const targetMetadata = Metadata.get(target);
            targetMetadata.delete(propertyKey);
            if (targetMetadata.size > 0)
                return true;
            Metadata.delete(target);
            return true;
        }
        exporter("deleteMetadata", deleteMetadata);
        function DecorateConstructor(decorators, target) {
            for (let i = decorators.length - 1; i >= 0; --i) {
                const decorator = decorators[i];
                const decorated = decorator(target);
                if (!IsUndefined(decorated) && !IsNull(decorated)) {
                    if (!IsConstructor(decorated))
                        throw new TypeError();
                    target = decorated;
                }
            }
            return target;
        }
        function DecorateProperty(decorators, target, propertyKey, descriptor) {
            for (let i = decorators.length - 1; i >= 0; --i) {
                const decorator = decorators[i];
                const decorated = decorator(target, propertyKey, descriptor);
                if (!IsUndefined(decorated) && !IsNull(decorated)) {
                    if (!IsObject(decorated))
                        throw new TypeError();
                    descriptor = decorated;
                }
            }
            return descriptor;
        }
        function GetOrCreateMetadataMap(O, P, Create) {
            let targetMetadata = Metadata.get(O);
            if (IsUndefined(targetMetadata)) {
                if (!Create)
                    return undefined;
                targetMetadata = new _Map();
                Metadata.set(O, targetMetadata);
            }
            let metadataMap = targetMetadata.get(P);
            if (IsUndefined(metadataMap)) {
                if (!Create)
                    return undefined;
                metadataMap = new _Map();
                targetMetadata.set(P, metadataMap);
            }
            return metadataMap;
        }
        // 3.1.1.1 OrdinaryHasMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryhasmetadata
        function OrdinaryHasMetadata(MetadataKey, O, P) {
            const hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
            if (hasOwn)
                return true;
            const parent = OrdinaryGetPrototypeOf(O);
            if (!IsNull(parent))
                return OrdinaryHasMetadata(MetadataKey, parent, P);
            return false;
        }
        // 3.1.2.1 OrdinaryHasOwnMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryhasownmetadata
        function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
            const metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return false;
            return ToBoolean(metadataMap.has(MetadataKey));
        }
        // 3.1.3.1 OrdinaryGetMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarygetmetadata
        function OrdinaryGetMetadata(MetadataKey, O, P) {
            const hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
            if (hasOwn)
                return OrdinaryGetOwnMetadata(MetadataKey, O, P);
            const parent = OrdinaryGetPrototypeOf(O);
            if (!IsNull(parent))
                return OrdinaryGetMetadata(MetadataKey, parent, P);
            return undefined;
        }
        // 3.1.4.1 OrdinaryGetOwnMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarygetownmetadata
        function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
            const metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return undefined;
            return metadataMap.get(MetadataKey);
        }
        // 3.1.5.1 OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarydefineownmetadata
        function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
            const metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ true);
            metadataMap.set(MetadataKey, MetadataValue);
        }
        // 3.1.6.1 OrdinaryMetadataKeys(O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarymetadatakeys
        function OrdinaryMetadataKeys(O, P) {
            const ownKeys = OrdinaryOwnMetadataKeys(O, P);
            const parent = OrdinaryGetPrototypeOf(O);
            if (parent === null)
                return ownKeys;
            const parentKeys = OrdinaryMetadataKeys(parent, P);
            if (parentKeys.length <= 0)
                return ownKeys;
            if (ownKeys.length <= 0)
                return parentKeys;
            const set = new _Set();
            const keys = [];
            for (const key of ownKeys) {
                const hasKey = set.has(key);
                if (!hasKey) {
                    set.add(key);
                    keys.push(key);
                }
            }
            for (const key of parentKeys) {
                const hasKey = set.has(key);
                if (!hasKey) {
                    set.add(key);
                    keys.push(key);
                }
            }
            return keys;
        }
        // 3.1.7.1 OrdinaryOwnMetadataKeys(O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryownmetadatakeys
        function OrdinaryOwnMetadataKeys(O, P) {
            const keys = [];
            const metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return keys;
            const keysObj = metadataMap.keys();
            const iterator = GetIterator(keysObj);
            let k = 0;
            while (true) {
                const next = IteratorStep(iterator);
                if (!next) {
                    keys.length = k;
                    return keys;
                }
                const nextValue = IteratorValue(next);
                try {
                    keys[k] = nextValue;
                }
                catch (e) {
                    try {
                        IteratorClose(iterator);
                    }
                    finally {
                        throw e;
                    }
                }
                k++;
            }
        }
        // 6 ECMAScript Data Typ0es and Values
        // https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values
        function Type(x) {
            if (x === null)
                return 1 /* Null */;
            switch (typeof x) {
                case "undefined":
                    return 0 /* Undefined */;
                case "boolean":
                    return 2 /* Boolean */;
                case "string":
                    return 3 /* String */;
                case "symbol":
                    return 4 /* Symbol */;
                case "number":
                    return 5 /* Number */;
                case "object":
                    return x === null ? 1 /* Null */ : 6 /* Object */;
                default:
                    return 6 /* Object */;
            }
        }
        // 6.1.1 The Undefined Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-undefined-type
        function IsUndefined(x) {
            return x === undefined;
        }
        // 6.1.2 The Null Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-null-type
        function IsNull(x) {
            return x === null;
        }
        // 6.1.5 The Symbol Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-symbol-type
        function IsSymbol(x) {
            return typeof x === "symbol";
        }
        // 6.1.7 The Object Type
        // https://tc39.github.io/ecma262/#sec-object-type
        function IsObject(x) {
            return typeof x === "object" ? x !== null : typeof x === "function";
        }
        // 7.1 Type Conversion
        // https://tc39.github.io/ecma262/#sec-type-conversion
        // 7.1.1 ToPrimitive(input [, PreferredType])
        // https://tc39.github.io/ecma262/#sec-toprimitive
        function ToPrimitive(input, PreferredType) {
            switch (Type(input)) {
                case 0 /* Undefined */:
                    return input;
                case 1 /* Null */:
                    return input;
                case 2 /* Boolean */:
                    return input;
                case 3 /* String */:
                    return input;
                case 4 /* Symbol */:
                    return input;
                case 5 /* Number */:
                    return input;
            }
            const hint = PreferredType === 3 /* String */
                ? "string"
                : PreferredType === 5 /* Number */
                    ? "number"
                    : "default";
            const exoticToPrim = GetMethod(input, toPrimitiveSymbol);
            if (exoticToPrim !== undefined) {
                const result = exoticToPrim.call(input, hint);
                if (IsObject(result))
                    throw new TypeError();
                return result;
            }
            return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
        }
        // 7.1.1.1 OrdinaryToPrimitive(O, hint)
        // https://tc39.github.io/ecma262/#sec-ordinarytoprimitive
        function OrdinaryToPrimitive(O, hint) {
            if (hint === "string") {
                const toString = O.toString;
                if (IsCallable(toString)) {
                    const result = toString.call(O);
                    if (!IsObject(result))
                        return result;
                }
                const valueOf = O.valueOf;
                if (IsCallable(valueOf)) {
                    const result = valueOf.call(O);
                    if (!IsObject(result))
                        return result;
                }
            }
            else {
                const valueOf = O.valueOf;
                if (IsCallable(valueOf)) {
                    const result = valueOf.call(O);
                    if (!IsObject(result))
                        return result;
                }
                const toString = O.toString;
                if (IsCallable(toString)) {
                    const result = toString.call(O);
                    if (!IsObject(result))
                        return result;
                }
            }
            throw new TypeError();
        }
        // 7.1.2 ToBoolean(argument)
        // https://tc39.github.io/ecma262/2016/#sec-toboolean
        function ToBoolean(argument) {
            return !!argument;
        }
        // 7.1.12 ToString(argument)
        // https://tc39.github.io/ecma262/#sec-tostring
        function ToString(argument) {
            return "" + argument;
        }
        // 7.1.14 ToPropertyKey(argument)
        // https://tc39.github.io/ecma262/#sec-topropertykey
        function ToPropertyKey(argument) {
            const key = ToPrimitive(argument, 3 /* String */);
            if (IsSymbol(key))
                return key;
            return ToString(key);
        }
        // 7.2 Testing and Comparison Operations
        // https://tc39.github.io/ecma262/#sec-testing-and-comparison-operations
        // 7.2.2 IsArray(argument)
        // https://tc39.github.io/ecma262/#sec-isarray
        function IsArray(argument) {
            return Array.isArray
                ? Array.isArray(argument)
                : argument instanceof Object
                    ? argument instanceof Array
                    : Object.prototype.toString.call(argument) === "[object Array]";
        }
        // 7.2.3 IsCallable(argument)
        // https://tc39.github.io/ecma262/#sec-iscallable
        function IsCallable(argument) {
            // NOTE: This is an approximation as we cannot check for [[Call]] internal method.
            return typeof argument === "function";
        }
        // 7.2.4 IsConstructor(argument)
        // https://tc39.github.io/ecma262/#sec-isconstructor
        function IsConstructor(argument) {
            // NOTE: This is an approximation as we cannot check for [[Construct]] internal method.
            return typeof argument === "function";
        }
        // 7.2.7 IsPropertyKey(argument)
        // https://tc39.github.io/ecma262/#sec-ispropertykey
        function IsPropertyKey(argument) {
            switch (Type(argument)) {
                case 3 /* String */:
                    return true;
                case 4 /* Symbol */:
                    return true;
                default:
                    return false;
            }
        }
        // 7.3 Operations on Objects
        // https://tc39.github.io/ecma262/#sec-operations-on-objects
        // 7.3.9 GetMethod(V, P)
        // https://tc39.github.io/ecma262/#sec-getmethod
        function GetMethod(V, P) {
            const func = V[P];
            if (func === undefined || func === null)
                return undefined;
            if (!IsCallable(func))
                throw new TypeError();
            return func;
        }
        // 7.4 Operations on Iterator Objects
        // https://tc39.github.io/ecma262/#sec-operations-on-iterator-objects
        function GetIterator(obj) {
            const method = GetMethod(obj, iteratorSymbol);
            if (!IsCallable(method))
                throw new TypeError(); // from Call
            const iterator = method.call(obj);
            if (!IsObject(iterator))
                throw new TypeError();
            return iterator;
        }
        // 7.4.4 IteratorValue(iterResult)
        // https://tc39.github.io/ecma262/2016/#sec-iteratorvalue
        function IteratorValue(iterResult) {
            return iterResult.value;
        }
        // 7.4.5 IteratorStep(iterator)
        // https://tc39.github.io/ecma262/#sec-iteratorstep
        function IteratorStep(iterator) {
            const result = iterator.next();
            return result.done ? false : result;
        }
        // 7.4.6 IteratorClose(iterator, completion)
        // https://tc39.github.io/ecma262/#sec-iteratorclose
        function IteratorClose(iterator) {
            const f = iterator["return"];
            if (f)
                f.call(iterator);
        }
        // 9.1 Ordinary Object Internal Methods and Internal Slots
        // https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots
        // 9.1.1.1 OrdinaryGetPrototypeOf(O)
        // https://tc39.github.io/ecma262/#sec-ordinarygetprototypeof
        function OrdinaryGetPrototypeOf(O) {
            const proto = Object.getPrototypeOf(O);
            if (typeof O !== "function" || O === functionPrototype)
                return proto;
            // TypeScript doesn't set __proto__ in ES5, as it's non-standard.
            // Try to determine the superclass constructor. Compatible implementations
            // must either set __proto__ on a subclass constructor to the superclass constructor,
            // or ensure each class has a valid `constructor` property on its prototype that
            // points back to the constructor.
            // If this is not the same as Function.[[Prototype]], then this is definately inherited.
            // This is the case when in ES6 or when using __proto__ in a compatible browser.
            if (proto !== functionPrototype)
                return proto;
            // If the super prototype is Object.prototype, null, or undefined, then we cannot determine the heritage.
            const prototype = O.prototype;
            const prototypeProto = prototype && Object.getPrototypeOf(prototype);
            if (prototypeProto == null || prototypeProto === Object.prototype) {
                return proto;
            }
            // If the constructor was not a function, then we cannot determine the heritage.
            const constructor = prototypeProto.constructor;
            if (typeof constructor !== "function")
                return proto;
            // If we have some kind of self-reference, then we cannot determine the heritage.
            if (constructor === O)
                return proto;
            // we have a pretty good guess at the heritage.
            return constructor;
        }
        // naive Map shim
        function CreateMapPolyfill() {
            const cacheSentinel = {};
            const arraySentinel = [];
            class MapIterator {
                constructor(keys, values, selector) {
                    this._index = 0;
                    this._keys = keys;
                    this._values = values;
                    this._selector = selector;
                }
                "@@iterator"() {
                    return this;
                }
                [iteratorSymbol]() {
                    return this;
                }
                next() {
                    const index = this._index;
                    if (index >= 0 && index < this._keys.length) {
                        const result = this._selector(this._keys[index], this._values[index]);
                        if (index + 1 >= this._keys.length) {
                            this._index = -1;
                            this._keys = arraySentinel;
                            this._values = arraySentinel;
                        }
                        else {
                            this._index++;
                        }
                        return { value: result, done: false };
                    }
                    return { value: undefined, done: true };
                }
                throw(error) {
                    if (this._index >= 0) {
                        this._index = -1;
                        this._keys = arraySentinel;
                        this._values = arraySentinel;
                    }
                    throw error;
                }
                return(value) {
                    if (this._index >= 0) {
                        this._index = -1;
                        this._keys = arraySentinel;
                        this._values = arraySentinel;
                    }
                    return { value: value, done: true };
                }
            }
            return class Map {
                constructor() {
                    this._keys = [];
                    this._values = [];
                    this._cacheKey = cacheSentinel;
                    this._cacheIndex = -2;
                }
                get size() {
                    return this._keys.length;
                }
                has(key) {
                    return this._find(key, /*insert*/ false) >= 0;
                }
                get(key) {
                    const index = this._find(key, /*insert*/ false);
                    return index >= 0 ? this._values[index] : undefined;
                }
                set(key, value) {
                    const index = this._find(key, /*insert*/ true);
                    this._values[index] = value;
                    return this;
                }
                delete(key) {
                    const index = this._find(key, /*insert*/ false);
                    if (index >= 0) {
                        const size = this._keys.length;
                        for (let i = index + 1; i < size; i++) {
                            this._keys[i - 1] = this._keys[i];
                            this._values[i - 1] = this._values[i];
                        }
                        this._keys.length--;
                        this._values.length--;
                        if (key === this._cacheKey) {
                            this._cacheKey = cacheSentinel;
                            this._cacheIndex = -2;
                        }
                        return true;
                    }
                    return false;
                }
                clear() {
                    this._keys.length = 0;
                    this._values.length = 0;
                    this._cacheKey = cacheSentinel;
                    this._cacheIndex = -2;
                }
                keys() {
                    return new MapIterator(this._keys, this._values, getKey);
                }
                values() {
                    return new MapIterator(this._keys, this._values, getValue);
                }
                entries() {
                    return new MapIterator(this._keys, this._values, getEntry);
                }
                "@@iterator"() {
                    return this.entries();
                }
                [iteratorSymbol]() {
                    return this.entries();
                }
                _find(key, insert) {
                    if (this._cacheKey !== key) {
                        this._cacheIndex = this._keys.indexOf((this._cacheKey = key));
                    }
                    if (this._cacheIndex < 0 && insert) {
                        this._cacheIndex = this._keys.length;
                        this._keys.push(key);
                        this._values.push(undefined);
                    }
                    return this._cacheIndex;
                }
            };
            function getKey(key, _) {
                return key;
            }
            function getValue(_, value) {
                return value;
            }
            function getEntry(key, value) {
                return [key, value];
            }
        }
        // naive Set shim
        function CreateSetPolyfill() {
            return class Set {
                constructor() {
                    this._map = new _Map();
                }
                get size() {
                    return this._map.size;
                }
                has(value) {
                    return this._map.has(value);
                }
                add(value) {
                    return this._map.set(value, value), this;
                }
                delete(value) {
                    return this._map.delete(value);
                }
                clear() {
                    this._map.clear();
                }
                keys() {
                    return this._map.keys();
                }
                values() {
                    return this._map.values();
                }
                entries() {
                    return this._map.entries();
                }
                "@@iterator"() {
                    return this.keys();
                }
                [iteratorSymbol]() {
                    return this.keys();
                }
            };
        }
        // naive WeakMap shim
        function CreateWeakMapPolyfill() {
            const UUID_SIZE = 16;
            const keys = HashMap.create();
            const rootKey = CreateUniqueKey();
            return class WeakMap {
                constructor() {
                    this._key = CreateUniqueKey();
                }
                has(target) {
                    const table = GetOrCreateWeakMapTable(target, /*create*/ false);
                    return table !== undefined ? HashMap.has(table, this._key) : false;
                }
                get(target) {
                    const table = GetOrCreateWeakMapTable(target, /*create*/ false);
                    return table !== undefined
                        ? HashMap.get(table, this._key)
                        : undefined;
                }
                set(target, value) {
                    const table = GetOrCreateWeakMapTable(target, /*create*/ true);
                    table[this._key] = value;
                    return this;
                }
                delete(target) {
                    const table = GetOrCreateWeakMapTable(target, /*create*/ false);
                    return table !== undefined ? delete table[this._key] : false;
                }
                clear() {
                    // NOTE: not a real clear, just makes the previous data unreachable
                    this._key = CreateUniqueKey();
                }
            };
            function CreateUniqueKey() {
                let key;
                do
                    key = "@@WeakMap@@" + CreateUUID();
                while (HashMap.has(keys, key));
                keys[key] = true;
                return key;
            }
            function GetOrCreateWeakMapTable(target, create) {
                if (!hasOwn.call(target, rootKey)) {
                    if (!create)
                        return undefined;
                    Object.defineProperty(target, rootKey, {
                        value: HashMap.create(),
                    });
                }
                return target[rootKey];
            }
            function FillRandomBytes(buffer, size) {
                for (let i = 0; i < size; ++i)
                    buffer[i] = (Math.random() * 0xff) | 0;
                return buffer;
            }
            function GenRandomBytes(size) {
                if (typeof Uint8Array === "function") {
                    if (typeof crypto !== "undefined") {
                        return crypto.getRandomValues(new Uint8Array(size));
                    }
                    if (typeof msCrypto !== "undefined") {
                        return msCrypto.getRandomValues(new Uint8Array(size));
                    }
                    return FillRandomBytes(new Uint8Array(size), size);
                }
                return FillRandomBytes(new Array(size), size);
            }
            function CreateUUID() {
                const data = GenRandomBytes(UUID_SIZE);
                // mark as random - RFC 4122 § 4.4
                data[6] = (data[6] & 0x4f) | 0x40;
                data[8] = (data[8] & 0xbf) | 0x80;
                let result = "";
                for (let offset = 0; offset < UUID_SIZE; ++offset) {
                    const byte = data[offset];
                    if (offset === 4 || offset === 6 || offset === 8)
                        result += "-";
                    if (byte < 16)
                        result += "0";
                    result += byte.toString(16).toLowerCase();
                }
                return result;
            }
        }
        // uses a heuristic used by v8 and chakra to force an object into dictionary mode.
        function MakeDictionary(obj) {
            obj.__ = undefined;
            delete obj.__;
            return obj;
        }
    });
})(Reflect || (Reflect = {}));
System.register("https://deno.land/x/dso@v1.0.0/deps", ["https://deno.land/std@v0.51.0/testing/asserts", "https://deno.land/x/mysql@2.1.0/mod", "https://deno.land/x/sql_builder@1.5.0/mod", "./src/Reflect.ts"], function (exports_146, context_146) {
    "use strict";
    var __moduleName = context_146 && context_146.id;
    return {
        setters: [
            function (asserts_ts_5_1) {
                exports_146({
                    "assert": asserts_ts_5_1["assert"],
                    "assertEquals": asserts_ts_5_1["assertEquals"],
                    "assertThrowsAsync": asserts_ts_5_1["assertThrowsAsync"]
                });
            },
            function (mod_ts_21_1) {
                exports_146({
                    "Client": mod_ts_21_1["Client"],
                    "Connection": mod_ts_21_1["Connection"]
                });
            },
            function (mod_ts_22_1) {
                exports_146({
                    "Join": mod_ts_22_1["Join"],
                    "Order": mod_ts_22_1["Order"],
                    "Query": mod_ts_22_1["Query"],
                    "replaceParams": mod_ts_22_1["replaceParams"],
                    "Where": mod_ts_22_1["Where"]
                });
            },
            function (_1) {
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/dso@v1.0.0/src/util", [], function (exports_147, context_147) {
    "use strict";
    var __moduleName = context_147 && context_147.id;
    // 驼峰转下划线
    function camel2line(key) {
        return key.replace(/([A-Z])/g, "_$1").toLowerCase();
    }
    exports_147("camel2line", camel2line);
    // 下划线转驼峰
    function line2camel(key) {
        return key.replace(/_(\w)/g, function (_, letter) {
            return letter.toUpperCase();
        });
    }
    exports_147("line2camel", line2camel);
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/dso@v1.0.0/src/field", ["https://deno.land/x/dso@v1.0.0/src/util"], function (exports_148, context_148) {
    "use strict";
    var util_ts_17, Defaults, FieldType;
    var __moduleName = context_148 && context_148.id;
    /** Field Decorator */
    function Field(options) {
        return (target, property) => {
            const fields = target.modelFields;
            const name = util_ts_17.camel2line(property);
            fields.push({ ...options, property, name });
            Reflect.defineMetadata("model:fields", fields, target);
        };
    }
    exports_148("Field", Field);
    return {
        setters: [
            function (util_ts_17_1) {
                util_ts_17 = util_ts_17_1;
            }
        ],
        execute: function () {
            (function (Defaults) {
                Defaults["CURRENT_TIMESTAMP"] = "CURRENT_TIMESTAMP";
                Defaults["NULL"] = "NULL";
            })(Defaults || (Defaults = {}));
            exports_148("Defaults", Defaults);
            /** Field type */
            (function (FieldType) {
                FieldType[FieldType["DATE"] = 0] = "DATE";
                FieldType[FieldType["INT"] = 1] = "INT";
                FieldType[FieldType["STRING"] = 2] = "STRING";
                FieldType[FieldType["TEXT"] = 3] = "TEXT";
                FieldType[FieldType["BOOLEAN"] = 4] = "BOOLEAN";
                FieldType[FieldType["LONGTEXT"] = 5] = "LONGTEXT";
                FieldType[FieldType["GeoPOINT"] = 6] = "GeoPOINT";
            })(FieldType || (FieldType = {}));
            exports_148("FieldType", FieldType);
        }
    };
});
System.register("https://deno.land/x/dso@v1.0.0/src/model", ["https://deno.land/x/dso@v1.0.0/deps", "https://deno.land/x/dso@v1.0.0/src/dso", "https://deno.land/x/dso@v1.0.0/src/field"], function (exports_149, context_149) {
    "use strict";
    var deps_ts_27, dso_ts_1, field_ts_1, BaseModel;
    var __moduleName = context_149 && context_149.id;
    /** Model Decorator */
    function Model(name) {
        return (target) => {
            Reflect.defineMetadata("model:name", name, target.prototype);
        };
    }
    exports_149("Model", Model);
    return {
        setters: [
            function (deps_ts_27_1) {
                deps_ts_27 = deps_ts_27_1;
            },
            function (dso_ts_1_1) {
                dso_ts_1 = dso_ts_1_1;
            },
            function (field_ts_1_1) {
                field_ts_1 = field_ts_1_1;
            }
        ],
        execute: function () {
            /** Model base class */
            BaseModel = class BaseModel {
                constructor(connection) {
                    this.connection = connection;
                }
                /** get model name */
                get modelName() {
                    return Reflect.getMetadata("model:name", this);
                }
                /** get primary key */
                get primaryKey() {
                    return this.modelFields.find((field) => field.primary);
                }
                /** get defined fields list */
                get modelFields() {
                    return (Reflect.getMetadata("model:fields", this) || [
                        {
                            type: field_ts_1.FieldType.DATE,
                            default: field_ts_1.Defaults.CURRENT_TIMESTAMP,
                            autoUpdate: true,
                            name: "updated_at",
                            property: "updated_at",
                        },
                        {
                            type: field_ts_1.FieldType.DATE,
                            default: field_ts_1.Defaults.CURRENT_TIMESTAMP,
                            name: "created_at",
                            property: "created_at",
                        },
                    ]);
                }
                /** return a new Query instance with table name */
                builder() {
                    const builder = new deps_ts_27.Query();
                    return builder.table(this.modelName);
                }
                /**
                 * Convert data object to model
                 * @param data
                 */
                convertModel(data) {
                    if (!data)
                        return;
                    const model = {};
                    const fieldsMapping = {};
                    this.modelFields.map((field) => (fieldsMapping[field.name] = field.property));
                    Object.keys(data).forEach((key) => {
                        const propertyName = fieldsMapping[key];
                        model[propertyName || key] = data[key];
                    });
                    return model;
                }
                /**
                 * Convert model object to db object
                 * @param model
                 */
                convertObject(model) {
                    const data = {};
                    const fieldsMapping = {};
                    this.modelFields.map((field) => (fieldsMapping[field.property] = field.name));
                    Object.keys(model).forEach((key) => {
                        const name = fieldsMapping[key];
                        data[name || key] = model[key];
                    });
                    return data;
                }
                optionsToQuery(options) {
                    const query = this.builder();
                    if (options.fields) {
                        query.select(...options.fields);
                    }
                    else {
                        query.select(`${this.modelName}.*`);
                    }
                    if (options.where)
                        query.where(options.where);
                    if (options.group)
                        query.groupBy(...options.group);
                    if (options.having)
                        query.having(options.having);
                    if (options.join) {
                        options.join.forEach((join) => query.join(join));
                    }
                    if (options.limit)
                        query.limit(...options.limit);
                    if (options.order)
                        options.order.forEach((order) => query.order(order));
                    return query;
                }
                /**
                 * find one record
                 * @param where conditions
                 */
                async findOne(options) {
                    if (options instanceof deps_ts_27.Where) {
                        options = {
                            where: options,
                        };
                    }
                    const result = await this.query(this.optionsToQuery(options).limit(0, 1));
                    return this.convertModel(result[0]);
                }
                /**
                 * delete by conditions
                 * @param where
                 */
                async delete(where) {
                    const result = await this.execute(this.builder()
                        .delete()
                        .where(where));
                    return result.affectedRows ?? 0;
                }
                /** find all records by given conditions */
                async findAll(options) {
                    if (options instanceof deps_ts_27.Where) {
                        options = {
                            where: options,
                        };
                    }
                    const result = await this.query(this.optionsToQuery(options));
                    return result.map((record) => this.convertModel(record));
                }
                /** find one record by primary key */
                async findById(id) {
                    deps_ts_27.assert(!!this.primaryKey);
                    return await this.findOne(deps_ts_27.Where.field(this.primaryKey.name).eq(id));
                }
                /** insert record */
                async insert(fields) {
                    const query = this.builder().insert(this.convertObject(fields));
                    const result = await this.execute(query);
                    return result.lastInsertId;
                }
                /** update records by given conditions */
                async update(data, where) {
                    if (!where &&
                        this.primaryKey &&
                        data[this.primaryKey.property]) {
                        where = deps_ts_27.Where.field(this.primaryKey.name).eq(data[this.primaryKey.property]);
                    }
                    const query = this.builder()
                        .update(this.convertObject(data))
                        .where(where ?? "");
                    const result = await this.execute(query);
                    return result.affectedRows;
                }
                /**
                 * query custom
                 * @param query
                 */
                async query(query) {
                    const sql = query.build();
                    dso_ts_1.dso.showQueryLog && console.log(`\n[ DSO:QUERY ]\nSQL:\t ${sql}\n`);
                    const result = this.connection
                        ? await this.connection.query(sql)
                        : await dso_ts_1.dso.client.query(sql);
                    dso_ts_1.dso.showQueryLog && console.log(`REUSLT:\t`, result, `\n`);
                    return result;
                }
                /**
                 * excute custom
                 * @param query
                 */
                async execute(query) {
                    const sql = query.build();
                    dso_ts_1.dso.showQueryLog && console.log(`\n[ DSO:EXECUTE ]\nSQL:\t ${sql}\n`);
                    const result = this.connection
                        ? await this.connection.execute(sql)
                        : await dso_ts_1.dso.client.execute(sql);
                    dso_ts_1.dso.showQueryLog && console.log(`REUSLT:\t`, result, `\n`);
                    return result;
                }
            };
            exports_149("BaseModel", BaseModel);
        }
    };
});
System.register("https://deno.land/x/dso@v1.0.0/src/sync", ["https://deno.land/x/dso@v1.0.0/deps", "https://deno.land/x/dso@v1.0.0/mod", "https://deno.land/x/dso@v1.0.0/src/field"], function (exports_150, context_150) {
    "use strict";
    var deps_ts_28, mod_ts_23, field_ts_2;
    var __moduleName = context_150 && context_150.id;
    async function sync(client, model, force) {
        if (force) {
            await client.execute(`DROP TABLE IF EXISTS ${model.modelName}`);
        }
        let defs = model.modelFields
            .map((field) => {
            let def = field.name;
            let type = "";
            switch (field.type) {
                case field_ts_2.FieldType.STRING:
                    type = `VARCHAR(${field.length || 255})`;
                    break;
                case field_ts_2.FieldType.INT:
                    type = `INT(${field.length || 11})`;
                    break;
                case field_ts_2.FieldType.DATE:
                    type = `TIMESTAMP`;
                    break;
                case field_ts_2.FieldType.BOOLEAN:
                    type = `TINYINT(1)`;
                    break;
                case field_ts_2.FieldType.TEXT:
                    type = `TEXT(${field.length})`;
                    break;
                case field_ts_2.FieldType.LONGTEXT: {
                    type = `LONGTEXT`;
                    break;
                }
                case field_ts_2.FieldType.GeoPOINT: {
                    type = `POINT`;
                    break;
                }
            }
            def += ` ${type}`;
            if (field.notNull)
                def += " NOT NULL";
            if (field.default != null) {
                if (field.default === field_ts_2.Defaults.NULL) {
                    def += ` NULL DEFAULT NULL`;
                }
                else {
                    def += ` DEFAULT ${field.default}`;
                }
            }
            if (field.autoIncrement)
                def += " AUTO_INCREMENT";
            if (field.autoUpdate) {
                deps_ts_28.assert(field.type === field_ts_2.FieldType.DATE, "AutoUpdate only support Date field");
                def += ` ON UPDATE CURRENT_TIMESTAMP()`;
            }
            return def;
        })
            .join(", ");
        if (model.primaryKey) {
            defs += `, PRIMARY KEY (${model.primaryKey.name})`;
        }
        const sql = [
            "CREATE TABLE IF NOT EXISTS",
            model.modelName,
            "(",
            defs,
            ")",
            "ENGINE=InnoDB DEFAULT CHARSET=utf8;",
        ].join(" ");
        mod_ts_23.dso.showQueryLog && console.log(`\n[ DSO:SYNC ]\nSQL:\t ${sql}\n`);
        const result = await client.execute(sql);
        mod_ts_23.dso.showQueryLog && console.log(`REUSLT:\t`, result, `\n`);
    }
    exports_150("sync", sync);
    return {
        setters: [
            function (deps_ts_28_1) {
                deps_ts_28 = deps_ts_28_1;
            },
            function (mod_ts_23_1) {
                mod_ts_23 = mod_ts_23_1;
            },
            function (field_ts_2_1) {
                field_ts_2 = field_ts_2_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/dso@v1.0.0/src/transaction", ["https://deno.land/x/dso@v1.0.0/src/dso"], function (exports_151, context_151) {
    "use strict";
    var dso_ts_2, Transaction;
    var __moduleName = context_151 && context_151.id;
    return {
        setters: [
            function (dso_ts_2_1) {
                dso_ts_2 = dso_ts_2_1;
            }
        ],
        execute: function () {
            Transaction = class Transaction {
                constructor(_conn) {
                    this._conn = _conn;
                }
                getModel(Model) {
                    const model = new Model(this._conn);
                    return model;
                }
                static async transaction(processor) {
                    return (await dso_ts_2.dso.client.transaction(async (conn) => {
                        const trans = new Transaction(conn);
                        return await processor(trans);
                    }));
                }
            };
            exports_151("Transaction", Transaction);
        }
    };
});
System.register("https://deno.land/x/dso@v1.0.0/src/dso", ["https://deno.land/x/dso@v1.0.0/deps", "https://deno.land/x/dso@v1.0.0/src/sync", "https://deno.land/x/dso@v1.0.0/src/transaction"], function (exports_152, context_152) {
    "use strict";
    var deps_ts_29, sync_ts_1, transaction_ts_1, _client, _models, dso;
    var __moduleName = context_152 && context_152.id;
    return {
        setters: [
            function (deps_ts_29_1) {
                deps_ts_29 = deps_ts_29_1;
            },
            function (sync_ts_1_1) {
                sync_ts_1 = sync_ts_1_1;
            },
            function (transaction_ts_1_1) {
                transaction_ts_1 = transaction_ts_1_1;
            }
        ],
        execute: function () {
            /** @ignore */
            _models = [];
            /**
             * Global dso instance
             */
            exports_152("dso", dso = {
                /**
                 * set true will show exucte/query sql
                 */
                showQueryLog: false,
                /**
                 * Sync model to database table
                 * @param force set true, will drop table before create table
                 */
                async sync(force = false) {
                    for (const model of _models) {
                        await sync_ts_1.sync(_client, model, force);
                    }
                },
                /**
                 * Database client
                 */
                get client() {
                    return _client;
                },
                /**
                 * all models
                 */
                get models() {
                    return _models;
                },
                /**
                 * add model
                 * @param model
                 */
                define(ModelClass) {
                    const model = new ModelClass();
                    _models.push(model);
                    return model;
                },
                transaction: transaction_ts_1.Transaction.transaction,
                /**
                 * connect to database
                 * @param config client config
                 */
                async connect(config) {
                    if (config instanceof deps_ts_29.Client) {
                        _client = config;
                    }
                    else {
                        _client = new deps_ts_29.Client();
                        await _client.connect(config);
                    }
                    return _client;
                },
                close() {
                    _client.close();
                },
            });
        }
    };
});
System.register("https://deno.land/x/dso@v1.0.0/mod", ["https://deno.land/x/dso@v1.0.0/deps", "https://deno.land/x/dso@v1.0.0/src/dso", "https://deno.land/x/dso@v1.0.0/src/field", "https://deno.land/x/dso@v1.0.0/src/model", "https://deno.land/x/dso@v1.0.0/src/util"], function (exports_153, context_153) {
    "use strict";
    var __moduleName = context_153 && context_153.id;
    var exportedNames_3 = {
        "Client": true,
        "Join": true,
        "Order": true,
        "Query": true,
        "replaceParams": true,
        "Where": true,
        "dso": true
    };
    function exportStar_6(m) {
        var exports = {};
        for (var n in m) {
            if (n !== "default" && !exportedNames_3.hasOwnProperty(n)) exports[n] = m[n];
        }
        exports_153(exports);
    }
    return {
        setters: [
            function (deps_ts_30_1) {
                exports_153({
                    "Client": deps_ts_30_1["Client"],
                    "Join": deps_ts_30_1["Join"],
                    "Order": deps_ts_30_1["Order"],
                    "Query": deps_ts_30_1["Query"],
                    "replaceParams": deps_ts_30_1["replaceParams"],
                    "Where": deps_ts_30_1["Where"]
                });
            },
            function (dso_ts_3_1) {
                exports_153({
                    "dso": dso_ts_3_1["dso"]
                });
            },
            function (field_ts_3_1) {
                exportStar_6(field_ts_3_1);
            },
            function (model_ts_1_1) {
                exportStar_6(model_ts_1_1);
            },
            function (util_ts_18_1) {
                exportStar_6(util_ts_18_1);
            }
        ],
        execute: function () {
        }
    };
});
System.register("file:///home/jax/www/denoAPI2/src/controllers/database/database", ["https://deno.land/x/dso@v1.0.0/mod"], function (exports_154, context_154) {
    "use strict";
    var mod_ts_24, connectMySQL;
    var __moduleName = context_154 && context_154.id;
    return {
        setters: [
            function (mod_ts_24_1) {
                mod_ts_24 = mod_ts_24_1;
            }
        ],
        execute: function () {
            /**
             * Connects MySQL database.
             * @caution Drops and recreates whole database If @param sync is true!
             * @param config
             * @param sync
             */
            connectMySQL = async (config, sync = false) => {
                await mod_ts_24.dso.connect(config);
                await mod_ts_24.dso.sync(sync);
            };
            exports_154("connectMySQL", connectMySQL);
        }
    };
});
System.register("https://deno.land/std/encoding/utf8", [], function (exports_155, context_155) {
    "use strict";
    var encoder, decoder;
    var __moduleName = context_155 && context_155.id;
    /** Shorthand for new TextEncoder().encode() */
    function encode(input) {
        return encoder.encode(input);
    }
    exports_155("encode", encode);
    /** Shorthand for new TextDecoder().decode() */
    function decode(input) {
        return decoder.decode(input);
    }
    exports_155("decode", decode);
    return {
        setters: [],
        execute: function () {
            /** A default TextEncoder instance */
            exports_155("encoder", encoder = new TextEncoder());
            /** A default TextDecoder instance */
            exports_155("decoder", decoder = new TextDecoder());
        }
    };
});
System.register("https://deno.land/x/bcrypt/bcrypt/base64", [], function (exports_156, context_156) {
    "use strict";
    var base64_code, index_64;
    var __moduleName = context_156 && context_156.id;
    function encode(d, len) {
        let off = 0;
        let rs = [];
        let c1 = 0;
        let c2 = 0;
        while (off < len) {
            c1 = d[off++] & 0xff;
            rs.push(base64_code[(c1 >> 2) & 0x3f]);
            c1 = (c1 & 0x03) << 4;
            if (off >= len) {
                rs.push(base64_code[c1 & 0x3f]);
                break;
            }
            c2 = d[off++] & 0xff;
            c1 |= (c2 >> 4) & 0x0f;
            rs.push(base64_code[c1 & 0x3f]);
            c1 = (c2 & 0x0f) << 2;
            if (off >= len) {
                rs.push(base64_code[c1 & 0x3f]);
                break;
            }
            c2 = d[off++] & 0xff;
            c1 |= (c2 >> 6) & 0x03;
            rs.push(base64_code[c1 & 0x3f]);
            rs.push(base64_code[c2 & 0x3f]);
        }
        return rs.join("");
    }
    exports_156("encode", encode);
    // x is a single character
    function char64(x) {
        if (x.length > 1) {
            throw new Error("Expected a single character");
        }
        let characterAsciiCode = x.charCodeAt(0);
        if (characterAsciiCode < 0 || characterAsciiCode > index_64.length)
            return -1;
        return index_64[characterAsciiCode];
    }
    function decode(s, maxolen) {
        let rs = [];
        let off = 0;
        let slen = s.length;
        let olen = 0;
        let ret;
        let c1, c2, c3, c4, o;
        if (maxolen <= 0)
            throw new Error("Invalid maxolen");
        while (off < slen - 1 && olen < maxolen) {
            c1 = char64(s.charAt(off++));
            c2 = char64(s.charAt(off++));
            if (c1 === -1 || c2 === -1)
                break;
            o = c1 << 2;
            o |= (c2 & 0x30) >> 4;
            rs.push(o);
            if (++olen >= maxolen || off >= slen)
                break;
            c3 = char64(s.charAt(off++));
            if (c3 === -1)
                break;
            o = (c2 & 0x0f) << 4;
            o |= (c3 & 0x3c) >> 2;
            rs.push(o);
            if (++olen >= maxolen || off >= slen)
                break;
            c4 = char64(s.charAt(off++));
            o = (c3 & 0x03) << 6;
            o |= c4;
            rs.push(o);
            ++olen;
        }
        ret = new Uint8Array(olen);
        for (off = 0; off < olen; off++)
            ret[off] = rs[off];
        return ret;
    }
    exports_156("decode", decode);
    return {
        setters: [],
        execute: function () {
            base64_code = "./ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split("");
            index_64 = new Uint8Array([
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                0,
                1,
                54,
                55,
                56,
                57,
                58,
                59,
                60,
                61,
                62,
                63,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23,
                24,
                25,
                26,
                27,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                28,
                29,
                30,
                31,
                32,
                33,
                34,
                35,
                36,
                37,
                38,
                39,
                40,
                41,
                42,
                43,
                44,
                45,
                46,
                47,
                48,
                49,
                50,
                51,
                52,
                53,
                -1,
                -1,
                -1,
                -1,
                -1,
            ]);
        }
    };
});
System.register("https://deno.land/x/bcrypt/bcrypt/bcrypt", ["https://deno.land/std/encoding/utf8", "https://deno.land/x/bcrypt/bcrypt/base64"], function (exports_157, context_157) {
    "use strict";
    var utf8_ts_6, base64, crypto, GENSALT_DEFAULT_LOG2_ROUNDS, BCRYPT_SALT_LEN, BLOWFISH_NUM_ROUNDS, P_orig, S_orig, bf_crypt_ciphertext, P, S;
    var __moduleName = context_157 && context_157.id;
    function encipher(lr, off) {
        let i = 0;
        let n = 0;
        let l = lr[off];
        let r = lr[off + 1];
        l ^= P[0];
        for (i = 0; i <= BLOWFISH_NUM_ROUNDS - 2;) {
            // Feistel substitution on left word
            n = S[(l >> 24) & 0xff];
            n += S[0x100 | ((l >> 16) & 0xff)];
            n ^= S[0x200 | ((l >> 8) & 0xff)];
            n += S[0x300 | (l & 0xff)];
            r ^= n ^ P[++i];
            // Feistel substitution on right word
            n = S[(r >> 24) & 0xff];
            n += S[0x100 | ((r >> 16) & 0xff)];
            n ^= S[0x200 | ((r >> 8) & 0xff)];
            n += S[0x300 | (r & 0xff)];
            l ^= n ^ P[++i];
        }
        lr[off] = r ^ P[BLOWFISH_NUM_ROUNDS + 1];
        lr[off + 1] = l;
    }
    function streamtoword(data, offp) {
        let word = 0;
        let off = offp[0];
        for (let i = 0; i < 4; i++) {
            word = (word << 8) | (data[off] & 0xff);
            off = (off + 1) % data.length;
        }
        offp[0] = off;
        return word;
    }
    function init_key() {
        P = P_orig.slice();
        S = S_orig.slice();
    }
    function key(key) {
        let i;
        let koffp = new Int32Array([0]);
        let lr = new Int32Array([0, 0]);
        let plen = P.length, slen = S.length;
        for (i = 0; i < plen; i++)
            P[i] = P[i] ^ streamtoword(key, koffp);
        for (i = 0; i < plen; i += 2) {
            encipher(lr, 0);
            P[i] = lr[0];
            P[i + 1] = lr[1];
        }
        for (i = 0; i < slen; i += 2) {
            encipher(lr, 0);
            S[i] = lr[0];
            S[i + 1] = lr[1];
        }
    }
    function ekskey(data, key) {
        let i = 0;
        let koffp = new Int32Array([0]);
        let doffp = new Int32Array([0]);
        let lr = new Int32Array([0, 0]);
        let plen = P.length, slen = S.length;
        for (i = 0; i < plen; i++)
            P[i] = P[i] ^ streamtoword(key, koffp);
        for (i = 0; i < plen; i += 2) {
            lr[0] ^= streamtoword(data, doffp);
            lr[1] ^= streamtoword(data, doffp);
            encipher(lr, 0);
            P[i] = lr[0];
            P[i + 1] = lr[1];
        }
        for (i = 0; i < slen; i += 2) {
            lr[0] ^= streamtoword(data, doffp);
            lr[1] ^= streamtoword(data, doffp);
            encipher(lr, 0);
            S[i] = lr[0];
            S[i + 1] = lr[1];
        }
    }
    function crypt_raw(password, salt, log_rounds, cdata) {
        let rounds = 0;
        let i = 0;
        let j = 0;
        let clen = cdata.length;
        let ret;
        if (log_rounds < 4 || log_rounds > 30) {
            throw new Error("Bad number of rounds");
        }
        rounds = 1 << log_rounds;
        if (salt.length !== BCRYPT_SALT_LEN)
            throw new Error("Bad salt length");
        init_key();
        ekskey(salt, password);
        for (i = 0; i !== rounds; i++) {
            key(password);
            key(salt);
        }
        for (i = 0; i < 64; i++) {
            for (j = 0; j < clen >> 1; j++)
                encipher(cdata, j << 1);
        }
        ret = new Uint8Array(clen * 4);
        for (i = 0, j = 0; i < clen; i++) {
            ret[j++] = (cdata[i] >> 24) & 0xff;
            ret[j++] = (cdata[i] >> 16) & 0xff;
            ret[j++] = (cdata[i] >> 8) & 0xff;
            ret[j++] = cdata[i] & 0xff;
        }
        return ret;
    }
    function hashpw(password, salt = gensalt()) {
        let real_salt;
        let passwordb;
        let saltb;
        let hashed;
        let minor = "";
        let rounds = 0;
        let off = 0;
        let rs = [];
        if (salt.charAt(0) !== "$" || salt.charAt(1) !== "2") {
            throw new Error("Invalid salt version");
        }
        if (salt.charAt(2) === "$")
            off = 3;
        else {
            minor = salt.charAt(2);
            if ((minor.charCodeAt(0) >= "a".charCodeAt(0) &&
                minor.charCodeAt(0) >= "z".charCodeAt(0)) ||
                salt.charAt(3) !== "$") {
                throw new Error("Invalid salt revision");
            }
            off = 4;
        }
        // Extract number of rounds
        if (salt.charAt(off + 2) > "$")
            throw new Error("Missing salt rounds");
        rounds = parseInt(salt.substring(off, off + 2));
        real_salt = salt.substring(off + 3, off + 25);
        passwordb = utf8_ts_6.encode(password + (minor.charCodeAt(0) >= "a".charCodeAt(0) ? "\u0000" : ""));
        saltb = base64.decode(real_salt, BCRYPT_SALT_LEN);
        hashed = crypt_raw(passwordb, saltb, rounds, bf_crypt_ciphertext.slice());
        rs.push("$2");
        if (minor.charCodeAt(0) >= "a".charCodeAt(0))
            rs.push(minor);
        rs.push("$");
        if (rounds < 10)
            rs.push("0");
        if (rounds > 30) {
            throw new Error("rounds exceeds maximum (30)");
        }
        rs.push(rounds.toString());
        rs.push("$");
        rs.push(base64.encode(saltb, saltb.length));
        rs.push(base64.encode(hashed, bf_crypt_ciphertext.length * 4 - 1));
        return rs.join("");
    }
    exports_157("hashpw", hashpw);
    function gensalt(log_rounds = GENSALT_DEFAULT_LOG2_ROUNDS) {
        let rs = [];
        let rnd = new Uint8Array(BCRYPT_SALT_LEN);
        crypto.getRandomValues(rnd);
        rs.push("$2a$");
        if (log_rounds < 10)
            rs.push("0");
        if (log_rounds > 30) {
            throw new Error("log_rounds exceeds maximum (30)");
        }
        rs.push(log_rounds.toString());
        rs.push("$");
        rs.push(base64.encode(rnd, rnd.length));
        return rs.join("");
    }
    exports_157("gensalt", gensalt);
    function checkpw(plaintext, hashed) {
        let hashed_bytes;
        let try_bytes;
        let try_pw = hashpw(plaintext, hashed);
        hashed_bytes = utf8_ts_6.encode(hashed);
        try_bytes = utf8_ts_6.encode(try_pw);
        if (hashed_bytes.length !== try_bytes.length)
            return false;
        let ret = 0;
        for (let i = 0; i < try_bytes.length; i++) {
            ret |= hashed_bytes[i] ^ try_bytes[i];
        }
        return ret === 0;
    }
    exports_157("checkpw", checkpw);
    return {
        setters: [
            function (utf8_ts_6_1) {
                utf8_ts_6 = utf8_ts_6_1;
            },
            function (base64_1) {
                base64 = base64_1;
            }
        ],
        execute: function () {
            crypto = globalThis.crypto;
            // BCrypt parameters
            GENSALT_DEFAULT_LOG2_ROUNDS = 10;
            BCRYPT_SALT_LEN = 16;
            // Blowfish parameters
            BLOWFISH_NUM_ROUNDS = 16;
            P_orig = new Int32Array([
                0x243f6a88,
                0x85a308d3,
                0x13198a2e,
                0x03707344,
                0xa4093822,
                0x299f31d0,
                0x082efa98,
                0xec4e6c89,
                0x452821e6,
                0x38d01377,
                0xbe5466cf,
                0x34e90c6c,
                0xc0ac29b7,
                0xc97c50dd,
                0x3f84d5b5,
                0xb5470917,
                0x9216d5d9,
                0x8979fb1b,
            ]);
            S_orig = new Int32Array([
                0xd1310ba6,
                0x98dfb5ac,
                0x2ffd72db,
                0xd01adfb7,
                0xb8e1afed,
                0x6a267e96,
                0xba7c9045,
                0xf12c7f99,
                0x24a19947,
                0xb3916cf7,
                0x0801f2e2,
                0x858efc16,
                0x636920d8,
                0x71574e69,
                0xa458fea3,
                0xf4933d7e,
                0x0d95748f,
                0x728eb658,
                0x718bcd58,
                0x82154aee,
                0x7b54a41d,
                0xc25a59b5,
                0x9c30d539,
                0x2af26013,
                0xc5d1b023,
                0x286085f0,
                0xca417918,
                0xb8db38ef,
                0x8e79dcb0,
                0x603a180e,
                0x6c9e0e8b,
                0xb01e8a3e,
                0xd71577c1,
                0xbd314b27,
                0x78af2fda,
                0x55605c60,
                0xe65525f3,
                0xaa55ab94,
                0x57489862,
                0x63e81440,
                0x55ca396a,
                0x2aab10b6,
                0xb4cc5c34,
                0x1141e8ce,
                0xa15486af,
                0x7c72e993,
                0xb3ee1411,
                0x636fbc2a,
                0x2ba9c55d,
                0x741831f6,
                0xce5c3e16,
                0x9b87931e,
                0xafd6ba33,
                0x6c24cf5c,
                0x7a325381,
                0x28958677,
                0x3b8f4898,
                0x6b4bb9af,
                0xc4bfe81b,
                0x66282193,
                0x61d809cc,
                0xfb21a991,
                0x487cac60,
                0x5dec8032,
                0xef845d5d,
                0xe98575b1,
                0xdc262302,
                0xeb651b88,
                0x23893e81,
                0xd396acc5,
                0x0f6d6ff3,
                0x83f44239,
                0x2e0b4482,
                0xa4842004,
                0x69c8f04a,
                0x9e1f9b5e,
                0x21c66842,
                0xf6e96c9a,
                0x670c9c61,
                0xabd388f0,
                0x6a51a0d2,
                0xd8542f68,
                0x960fa728,
                0xab5133a3,
                0x6eef0b6c,
                0x137a3be4,
                0xba3bf050,
                0x7efb2a98,
                0xa1f1651d,
                0x39af0176,
                0x66ca593e,
                0x82430e88,
                0x8cee8619,
                0x456f9fb4,
                0x7d84a5c3,
                0x3b8b5ebe,
                0xe06f75d8,
                0x85c12073,
                0x401a449f,
                0x56c16aa6,
                0x4ed3aa62,
                0x363f7706,
                0x1bfedf72,
                0x429b023d,
                0x37d0d724,
                0xd00a1248,
                0xdb0fead3,
                0x49f1c09b,
                0x075372c9,
                0x80991b7b,
                0x25d479d8,
                0xf6e8def7,
                0xe3fe501a,
                0xb6794c3b,
                0x976ce0bd,
                0x04c006ba,
                0xc1a94fb6,
                0x409f60c4,
                0x5e5c9ec2,
                0x196a2463,
                0x68fb6faf,
                0x3e6c53b5,
                0x1339b2eb,
                0x3b52ec6f,
                0x6dfc511f,
                0x9b30952c,
                0xcc814544,
                0xaf5ebd09,
                0xbee3d004,
                0xde334afd,
                0x660f2807,
                0x192e4bb3,
                0xc0cba857,
                0x45c8740f,
                0xd20b5f39,
                0xb9d3fbdb,
                0x5579c0bd,
                0x1a60320a,
                0xd6a100c6,
                0x402c7279,
                0x679f25fe,
                0xfb1fa3cc,
                0x8ea5e9f8,
                0xdb3222f8,
                0x3c7516df,
                0xfd616b15,
                0x2f501ec8,
                0xad0552ab,
                0x323db5fa,
                0xfd238760,
                0x53317b48,
                0x3e00df82,
                0x9e5c57bb,
                0xca6f8ca0,
                0x1a87562e,
                0xdf1769db,
                0xd542a8f6,
                0x287effc3,
                0xac6732c6,
                0x8c4f5573,
                0x695b27b0,
                0xbbca58c8,
                0xe1ffa35d,
                0xb8f011a0,
                0x10fa3d98,
                0xfd2183b8,
                0x4afcb56c,
                0x2dd1d35b,
                0x9a53e479,
                0xb6f84565,
                0xd28e49bc,
                0x4bfb9790,
                0xe1ddf2da,
                0xa4cb7e33,
                0x62fb1341,
                0xcee4c6e8,
                0xef20cada,
                0x36774c01,
                0xd07e9efe,
                0x2bf11fb4,
                0x95dbda4d,
                0xae909198,
                0xeaad8e71,
                0x6b93d5a0,
                0xd08ed1d0,
                0xafc725e0,
                0x8e3c5b2f,
                0x8e7594b7,
                0x8ff6e2fb,
                0xf2122b64,
                0x8888b812,
                0x900df01c,
                0x4fad5ea0,
                0x688fc31c,
                0xd1cff191,
                0xb3a8c1ad,
                0x2f2f2218,
                0xbe0e1777,
                0xea752dfe,
                0x8b021fa1,
                0xe5a0cc0f,
                0xb56f74e8,
                0x18acf3d6,
                0xce89e299,
                0xb4a84fe0,
                0xfd13e0b7,
                0x7cc43b81,
                0xd2ada8d9,
                0x165fa266,
                0x80957705,
                0x93cc7314,
                0x211a1477,
                0xe6ad2065,
                0x77b5fa86,
                0xc75442f5,
                0xfb9d35cf,
                0xebcdaf0c,
                0x7b3e89a0,
                0xd6411bd3,
                0xae1e7e49,
                0x00250e2d,
                0x2071b35e,
                0x226800bb,
                0x57b8e0af,
                0x2464369b,
                0xf009b91e,
                0x5563911d,
                0x59dfa6aa,
                0x78c14389,
                0xd95a537f,
                0x207d5ba2,
                0x02e5b9c5,
                0x83260376,
                0x6295cfa9,
                0x11c81968,
                0x4e734a41,
                0xb3472dca,
                0x7b14a94a,
                0x1b510052,
                0x9a532915,
                0xd60f573f,
                0xbc9bc6e4,
                0x2b60a476,
                0x81e67400,
                0x08ba6fb5,
                0x571be91f,
                0xf296ec6b,
                0x2a0dd915,
                0xb6636521,
                0xe7b9f9b6,
                0xff34052e,
                0xc5855664,
                0x53b02d5d,
                0xa99f8fa1,
                0x08ba4799,
                0x6e85076a,
                0x4b7a70e9,
                0xb5b32944,
                0xdb75092e,
                0xc4192623,
                0xad6ea6b0,
                0x49a7df7d,
                0x9cee60b8,
                0x8fedb266,
                0xecaa8c71,
                0x699a17ff,
                0x5664526c,
                0xc2b19ee1,
                0x193602a5,
                0x75094c29,
                0xa0591340,
                0xe4183a3e,
                0x3f54989a,
                0x5b429d65,
                0x6b8fe4d6,
                0x99f73fd6,
                0xa1d29c07,
                0xefe830f5,
                0x4d2d38e6,
                0xf0255dc1,
                0x4cdd2086,
                0x8470eb26,
                0x6382e9c6,
                0x021ecc5e,
                0x09686b3f,
                0x3ebaefc9,
                0x3c971814,
                0x6b6a70a1,
                0x687f3584,
                0x52a0e286,
                0xb79c5305,
                0xaa500737,
                0x3e07841c,
                0x7fdeae5c,
                0x8e7d44ec,
                0x5716f2b8,
                0xb03ada37,
                0xf0500c0d,
                0xf01c1f04,
                0x0200b3ff,
                0xae0cf51a,
                0x3cb574b2,
                0x25837a58,
                0xdc0921bd,
                0xd19113f9,
                0x7ca92ff6,
                0x94324773,
                0x22f54701,
                0x3ae5e581,
                0x37c2dadc,
                0xc8b57634,
                0x9af3dda7,
                0xa9446146,
                0x0fd0030e,
                0xecc8c73e,
                0xa4751e41,
                0xe238cd99,
                0x3bea0e2f,
                0x3280bba1,
                0x183eb331,
                0x4e548b38,
                0x4f6db908,
                0x6f420d03,
                0xf60a04bf,
                0x2cb81290,
                0x24977c79,
                0x5679b072,
                0xbcaf89af,
                0xde9a771f,
                0xd9930810,
                0xb38bae12,
                0xdccf3f2e,
                0x5512721f,
                0x2e6b7124,
                0x501adde6,
                0x9f84cd87,
                0x7a584718,
                0x7408da17,
                0xbc9f9abc,
                0xe94b7d8c,
                0xec7aec3a,
                0xdb851dfa,
                0x63094366,
                0xc464c3d2,
                0xef1c1847,
                0x3215d908,
                0xdd433b37,
                0x24c2ba16,
                0x12a14d43,
                0x2a65c451,
                0x50940002,
                0x133ae4dd,
                0x71dff89e,
                0x10314e55,
                0x81ac77d6,
                0x5f11199b,
                0x043556f1,
                0xd7a3c76b,
                0x3c11183b,
                0x5924a509,
                0xf28fe6ed,
                0x97f1fbfa,
                0x9ebabf2c,
                0x1e153c6e,
                0x86e34570,
                0xeae96fb1,
                0x860e5e0a,
                0x5a3e2ab3,
                0x771fe71c,
                0x4e3d06fa,
                0x2965dcb9,
                0x99e71d0f,
                0x803e89d6,
                0x5266c825,
                0x2e4cc978,
                0x9c10b36a,
                0xc6150eba,
                0x94e2ea78,
                0xa5fc3c53,
                0x1e0a2df4,
                0xf2f74ea7,
                0x361d2b3d,
                0x1939260f,
                0x19c27960,
                0x5223a708,
                0xf71312b6,
                0xebadfe6e,
                0xeac31f66,
                0xe3bc4595,
                0xa67bc883,
                0xb17f37d1,
                0x018cff28,
                0xc332ddef,
                0xbe6c5aa5,
                0x65582185,
                0x68ab9802,
                0xeecea50f,
                0xdb2f953b,
                0x2aef7dad,
                0x5b6e2f84,
                0x1521b628,
                0x29076170,
                0xecdd4775,
                0x619f1510,
                0x13cca830,
                0xeb61bd96,
                0x0334fe1e,
                0xaa0363cf,
                0xb5735c90,
                0x4c70a239,
                0xd59e9e0b,
                0xcbaade14,
                0xeecc86bc,
                0x60622ca7,
                0x9cab5cab,
                0xb2f3846e,
                0x648b1eaf,
                0x19bdf0ca,
                0xa02369b9,
                0x655abb50,
                0x40685a32,
                0x3c2ab4b3,
                0x319ee9d5,
                0xc021b8f7,
                0x9b540b19,
                0x875fa099,
                0x95f7997e,
                0x623d7da8,
                0xf837889a,
                0x97e32d77,
                0x11ed935f,
                0x16681281,
                0x0e358829,
                0xc7e61fd6,
                0x96dedfa1,
                0x7858ba99,
                0x57f584a5,
                0x1b227263,
                0x9b83c3ff,
                0x1ac24696,
                0xcdb30aeb,
                0x532e3054,
                0x8fd948e4,
                0x6dbc3128,
                0x58ebf2ef,
                0x34c6ffea,
                0xfe28ed61,
                0xee7c3c73,
                0x5d4a14d9,
                0xe864b7e3,
                0x42105d14,
                0x203e13e0,
                0x45eee2b6,
                0xa3aaabea,
                0xdb6c4f15,
                0xfacb4fd0,
                0xc742f442,
                0xef6abbb5,
                0x654f3b1d,
                0x41cd2105,
                0xd81e799e,
                0x86854dc7,
                0xe44b476a,
                0x3d816250,
                0xcf62a1f2,
                0x5b8d2646,
                0xfc8883a0,
                0xc1c7b6a3,
                0x7f1524c3,
                0x69cb7492,
                0x47848a0b,
                0x5692b285,
                0x095bbf00,
                0xad19489d,
                0x1462b174,
                0x23820e00,
                0x58428d2a,
                0x0c55f5ea,
                0x1dadf43e,
                0x233f7061,
                0x3372f092,
                0x8d937e41,
                0xd65fecf1,
                0x6c223bdb,
                0x7cde3759,
                0xcbee7460,
                0x4085f2a7,
                0xce77326e,
                0xa6078084,
                0x19f8509e,
                0xe8efd855,
                0x61d99735,
                0xa969a7aa,
                0xc50c06c2,
                0x5a04abfc,
                0x800bcadc,
                0x9e447a2e,
                0xc3453484,
                0xfdd56705,
                0x0e1e9ec9,
                0xdb73dbd3,
                0x105588cd,
                0x675fda79,
                0xe3674340,
                0xc5c43465,
                0x713e38d8,
                0x3d28f89e,
                0xf16dff20,
                0x153e21e7,
                0x8fb03d4a,
                0xe6e39f2b,
                0xdb83adf7,
                0xe93d5a68,
                0x948140f7,
                0xf64c261c,
                0x94692934,
                0x411520f7,
                0x7602d4f7,
                0xbcf46b2e,
                0xd4a20068,
                0xd4082471,
                0x3320f46a,
                0x43b7d4b7,
                0x500061af,
                0x1e39f62e,
                0x97244546,
                0x14214f74,
                0xbf8b8840,
                0x4d95fc1d,
                0x96b591af,
                0x70f4ddd3,
                0x66a02f45,
                0xbfbc09ec,
                0x03bd9785,
                0x7fac6dd0,
                0x31cb8504,
                0x96eb27b3,
                0x55fd3941,
                0xda2547e6,
                0xabca0a9a,
                0x28507825,
                0x530429f4,
                0x0a2c86da,
                0xe9b66dfb,
                0x68dc1462,
                0xd7486900,
                0x680ec0a4,
                0x27a18dee,
                0x4f3ffea2,
                0xe887ad8c,
                0xb58ce006,
                0x7af4d6b6,
                0xaace1e7c,
                0xd3375fec,
                0xce78a399,
                0x406b2a42,
                0x20fe9e35,
                0xd9f385b9,
                0xee39d7ab,
                0x3b124e8b,
                0x1dc9faf7,
                0x4b6d1856,
                0x26a36631,
                0xeae397b2,
                0x3a6efa74,
                0xdd5b4332,
                0x6841e7f7,
                0xca7820fb,
                0xfb0af54e,
                0xd8feb397,
                0x454056ac,
                0xba489527,
                0x55533a3a,
                0x20838d87,
                0xfe6ba9b7,
                0xd096954b,
                0x55a867bc,
                0xa1159a58,
                0xcca92963,
                0x99e1db33,
                0xa62a4a56,
                0x3f3125f9,
                0x5ef47e1c,
                0x9029317c,
                0xfdf8e802,
                0x04272f70,
                0x80bb155c,
                0x05282ce3,
                0x95c11548,
                0xe4c66d22,
                0x48c1133f,
                0xc70f86dc,
                0x07f9c9ee,
                0x41041f0f,
                0x404779a4,
                0x5d886e17,
                0x325f51eb,
                0xd59bc0d1,
                0xf2bcc18f,
                0x41113564,
                0x257b7834,
                0x602a9c60,
                0xdff8e8a3,
                0x1f636c1b,
                0x0e12b4c2,
                0x02e1329e,
                0xaf664fd1,
                0xcad18115,
                0x6b2395e0,
                0x333e92e1,
                0x3b240b62,
                0xeebeb922,
                0x85b2a20e,
                0xe6ba0d99,
                0xde720c8c,
                0x2da2f728,
                0xd0127845,
                0x95b794fd,
                0x647d0862,
                0xe7ccf5f0,
                0x5449a36f,
                0x877d48fa,
                0xc39dfd27,
                0xf33e8d1e,
                0x0a476341,
                0x992eff74,
                0x3a6f6eab,
                0xf4f8fd37,
                0xa812dc60,
                0xa1ebddf8,
                0x991be14c,
                0xdb6e6b0d,
                0xc67b5510,
                0x6d672c37,
                0x2765d43b,
                0xdcd0e804,
                0xf1290dc7,
                0xcc00ffa3,
                0xb5390f92,
                0x690fed0b,
                0x667b9ffb,
                0xcedb7d9c,
                0xa091cf0b,
                0xd9155ea3,
                0xbb132f88,
                0x515bad24,
                0x7b9479bf,
                0x763bd6eb,
                0x37392eb3,
                0xcc115979,
                0x8026e297,
                0xf42e312d,
                0x6842ada7,
                0xc66a2b3b,
                0x12754ccc,
                0x782ef11c,
                0x6a124237,
                0xb79251e7,
                0x06a1bbe6,
                0x4bfb6350,
                0x1a6b1018,
                0x11caedfa,
                0x3d25bdd8,
                0xe2e1c3c9,
                0x44421659,
                0x0a121386,
                0xd90cec6e,
                0xd5abea2a,
                0x64af674e,
                0xda86a85f,
                0xbebfe988,
                0x64e4c3fe,
                0x9dbc8057,
                0xf0f7c086,
                0x60787bf8,
                0x6003604d,
                0xd1fd8346,
                0xf6381fb0,
                0x7745ae04,
                0xd736fccc,
                0x83426b33,
                0xf01eab71,
                0xb0804187,
                0x3c005e5f,
                0x77a057be,
                0xbde8ae24,
                0x55464299,
                0xbf582e61,
                0x4e58f48f,
                0xf2ddfda2,
                0xf474ef38,
                0x8789bdc2,
                0x5366f9c3,
                0xc8b38e74,
                0xb475f255,
                0x46fcd9b9,
                0x7aeb2661,
                0x8b1ddf84,
                0x846a0e79,
                0x915f95e2,
                0x466e598e,
                0x20b45770,
                0x8cd55591,
                0xc902de4c,
                0xb90bace1,
                0xbb8205d0,
                0x11a86248,
                0x7574a99e,
                0xb77f19b6,
                0xe0a9dc09,
                0x662d09a1,
                0xc4324633,
                0xe85a1f02,
                0x09f0be8c,
                0x4a99a025,
                0x1d6efe10,
                0x1ab93d1d,
                0x0ba5a4df,
                0xa186f20f,
                0x2868f169,
                0xdcb7da83,
                0x573906fe,
                0xa1e2ce9b,
                0x4fcd7f52,
                0x50115e01,
                0xa70683fa,
                0xa002b5c4,
                0x0de6d027,
                0x9af88c27,
                0x773f8641,
                0xc3604c06,
                0x61a806b5,
                0xf0177a28,
                0xc0f586e0,
                0x006058aa,
                0x30dc7d62,
                0x11e69ed7,
                0x2338ea63,
                0x53c2dd94,
                0xc2c21634,
                0xbbcbee56,
                0x90bcb6de,
                0xebfc7da1,
                0xce591d76,
                0x6f05e409,
                0x4b7c0188,
                0x39720a3d,
                0x7c927c24,
                0x86e3725f,
                0x724d9db9,
                0x1ac15bb4,
                0xd39eb8fc,
                0xed545578,
                0x08fca5b5,
                0xd83d7cd3,
                0x4dad0fc4,
                0x1e50ef5e,
                0xb161e6f8,
                0xa28514d9,
                0x6c51133c,
                0x6fd5c7e7,
                0x56e14ec4,
                0x362abfce,
                0xddc6c837,
                0xd79a3234,
                0x92638212,
                0x670efa8e,
                0x406000e0,
                0x3a39ce37,
                0xd3faf5cf,
                0xabc27737,
                0x5ac52d1b,
                0x5cb0679e,
                0x4fa33742,
                0xd3822740,
                0x99bc9bbe,
                0xd5118e9d,
                0xbf0f7315,
                0xd62d1c7e,
                0xc700c47b,
                0xb78c1b6b,
                0x21a19045,
                0xb26eb1be,
                0x6a366eb4,
                0x5748ab2f,
                0xbc946e79,
                0xc6a376d2,
                0x6549c2c8,
                0x530ff8ee,
                0x468dde7d,
                0xd5730a1d,
                0x4cd04dc6,
                0x2939bbdb,
                0xa9ba4650,
                0xac9526e8,
                0xbe5ee304,
                0xa1fad5f0,
                0x6a2d519a,
                0x63ef8ce2,
                0x9a86ee22,
                0xc089c2b8,
                0x43242ef6,
                0xa51e03aa,
                0x9cf2d0a4,
                0x83c061ba,
                0x9be96a4d,
                0x8fe51550,
                0xba645bd6,
                0x2826a2f9,
                0xa73a3ae1,
                0x4ba99586,
                0xef5562e9,
                0xc72fefd3,
                0xf752f7da,
                0x3f046f69,
                0x77fa0a59,
                0x80e4a915,
                0x87b08601,
                0x9b09e6ad,
                0x3b3ee593,
                0xe990fd5a,
                0x9e34d797,
                0x2cf0b7d9,
                0x022b8b51,
                0x96d5ac3a,
                0x017da67d,
                0xd1cf3ed6,
                0x7c7d2d28,
                0x1f9f25cf,
                0xadf2b89b,
                0x5ad6b472,
                0x5a88f54c,
                0xe029ac71,
                0xe019a5e6,
                0x47b0acfd,
                0xed93fa9b,
                0xe8d3c48d,
                0x283b57cc,
                0xf8d56629,
                0x79132e28,
                0x785f0191,
                0xed756055,
                0xf7960e44,
                0xe3d35e8c,
                0x15056dd4,
                0x88f46dba,
                0x03a16125,
                0x0564f0bd,
                0xc3eb9e15,
                0x3c9057a2,
                0x97271aec,
                0xa93a072a,
                0x1b3f6d9b,
                0x1e6321f5,
                0xf59c66fb,
                0x26dcf319,
                0x7533d928,
                0xb155fdf5,
                0x03563482,
                0x8aba3cbb,
                0x28517711,
                0xc20ad9f8,
                0xabcc5167,
                0xccad925f,
                0x4de81751,
                0x3830dc8e,
                0x379d5862,
                0x9320f991,
                0xea7a90c2,
                0xfb3e7bce,
                0x5121ce64,
                0x774fbe32,
                0xa8b6e37e,
                0xc3293d46,
                0x48de5369,
                0x6413e680,
                0xa2ae0810,
                0xdd6db224,
                0x69852dfd,
                0x09072166,
                0xb39a460a,
                0x6445c0dd,
                0x586cdecf,
                0x1c20c8ae,
                0x5bbef7dd,
                0x1b588d40,
                0xccd2017f,
                0x6bb4e3bb,
                0xdda26a7e,
                0x3a59ff45,
                0x3e350a44,
                0xbcb4cdd5,
                0x72eacea8,
                0xfa6484bb,
                0x8d6612ae,
                0xbf3c6f47,
                0xd29be463,
                0x542f5d9e,
                0xaec2771b,
                0xf64e6370,
                0x740e0d8d,
                0xe75b1357,
                0xf8721671,
                0xaf537d5d,
                0x4040cb08,
                0x4eb4e2cc,
                0x34d2466a,
                0x0115af84,
                0xe1b00428,
                0x95983a1d,
                0x06b89fb4,
                0xce6ea048,
                0x6f3f3b82,
                0x3520ab82,
                0x011a1d4b,
                0x277227f8,
                0x611560b1,
                0xe7933fdc,
                0xbb3a792b,
                0x344525bd,
                0xa08839e1,
                0x51ce794b,
                0x2f32c9b7,
                0xa01fbac9,
                0xe01cc87e,
                0xbcc7d1f6,
                0xcf0111c3,
                0xa1e8aac7,
                0x1a908749,
                0xd44fbd9a,
                0xd0dadecb,
                0xd50ada38,
                0x0339c32a,
                0xc6913667,
                0x8df9317c,
                0xe0b12b4f,
                0xf79e59b7,
                0x43f5bb3a,
                0xf2d519ff,
                0x27d9459c,
                0xbf97222c,
                0x15e6fc2a,
                0x0f91fc71,
                0x9b941525,
                0xfae59361,
                0xceb69ceb,
                0xc2a86459,
                0x12baa8d1,
                0xb6c1075e,
                0xe3056a0c,
                0x10d25065,
                0xcb03a442,
                0xe0ec6e0e,
                0x1698db3b,
                0x4c98a0be,
                0x3278e964,
                0x9f1f9532,
                0xe0d392df,
                0xd3a0342b,
                0x8971f21e,
                0x1b0a7441,
                0x4ba3348c,
                0xc5be7120,
                0xc37632d8,
                0xdf359f8d,
                0x9b992f2e,
                0xe60b6f47,
                0x0fe3f11d,
                0xe54cda54,
                0x1edad891,
                0xce6279cf,
                0xcd3e7e6f,
                0x1618b166,
                0xfd2c1d05,
                0x848fd2c5,
                0xf6fb2299,
                0xf523f357,
                0xa6327623,
                0x93a83531,
                0x56cccd02,
                0xacf08162,
                0x5a75ebb5,
                0x6e163697,
                0x88d273cc,
                0xde966292,
                0x81b949d0,
                0x4c50901b,
                0x71c65614,
                0xe6c6c7bd,
                0x327a140a,
                0x45e1d006,
                0xc3f27b9a,
                0xc9aa53fd,
                0x62a80f00,
                0xbb25bfe2,
                0x35bdd2f6,
                0x71126905,
                0xb2040222,
                0xb6cbcf7c,
                0xcd769c2b,
                0x53113ec0,
                0x1640e3d3,
                0x38abbd60,
                0x2547adf0,
                0xba38209c,
                0xf746ce76,
                0x77afa1c5,
                0x20756060,
                0x85cbfe4e,
                0x8ae88dd8,
                0x7aaaf9b0,
                0x4cf9aa7e,
                0x1948c25c,
                0x02fb8a8c,
                0x01c36ae4,
                0xd6ebe1f9,
                0x90d4f869,
                0xa65cdea0,
                0x3f09252d,
                0xc208e69f,
                0xb74e6132,
                0xce77e25b,
                0x578fdfe3,
                0x3ac372e6,
            ]);
            // bcrypt IV: "OrpheanBeholderScryDoubt". The C implementation calls
            // this "ciphertext", but it is really plaintext or an IV. We keep
            // the name to make code comparison easier.
            bf_crypt_ciphertext = new Int32Array([
                0x4f727068,
                0x65616e42,
                0x65686f6c,
                0x64657253,
                0x63727944,
                0x6f756274,
            ]);
        }
    };
});
System.register("https://deno.land/x/bcrypt/main", ["https://deno.land/x/bcrypt/bcrypt/bcrypt"], function (exports_158, context_158) {
    "use strict";
    var bcrypt;
    var __moduleName = context_158 && context_158.id;
    /**
     * Generate a hash for the plaintext password
     * Requires --allow-net and --unstable flags
     *
     * @export
     * @param {string} plaintext The password to hash
     * @param {(string | undefined)} [salt=undefined] The salt to use when hashing. Recommended to leave this undefined.
     * @returns {Promise<string>} The hashed password
     */
    async function hash(plaintext, salt = undefined) {
        let worker = new Worker(new URL("worker.ts", context_158.meta.url).toString(), { type: "module", deno: true });
        worker.postMessage({
            action: "hash",
            payload: {
                plaintext,
                salt,
            },
        });
        return new Promise((resolve) => {
            worker.onmessage = (event) => {
                resolve(event.data);
                worker.terminate();
            };
        });
    }
    exports_158("hash", hash);
    /**
     * Generates a salt using a number of log rounds
     * Requires --allow-net and --unstable flags
     *
     * @export
     * @param {(number | undefined)} [log_rounds=undefined] Number of log rounds to use. Recommended to leave this undefined.
     * @returns {Promise<string>} The generated salt
     */
    async function genSalt(log_rounds = undefined) {
        let worker = new Worker(new URL("worker.ts", context_158.meta.url).toString(), { type: "module", deno: true });
        worker.postMessage({
            action: "genSalt",
            payload: {
                log_rounds,
            },
        });
        return new Promise((resolve) => {
            worker.onmessage = (event) => {
                resolve(event.data);
                worker.terminate();
            };
        });
    }
    exports_158("genSalt", genSalt);
    /**
     * Check if a plaintext password matches a hash
     * Requires --allow-net and --unstable flags
     *
     * @export
     * @param {string} plaintext The plaintext password to check
     * @param {string} hash The hash to compare to
     * @returns {Promise<boolean>} Whether the password matches the hash
     */
    async function compare(plaintext, hash) {
        let worker = new Worker(new URL("worker.ts", context_158.meta.url).toString(), { type: "module", deno: true });
        worker.postMessage({
            action: "compare",
            payload: {
                plaintext,
                hash,
            },
        });
        return new Promise((resolve) => {
            worker.onmessage = (event) => {
                resolve(event.data);
                worker.terminate();
            };
        });
    }
    exports_158("compare", compare);
    /**
     * Check if a plaintext password matches a hash
     * This function is blocking and computationally expensive but requires no additonal flags.
     * Using the async variant is highly recommended.
     *
     * @export
     * @param {string} plaintext The plaintext password to check
     * @param {string} hash The hash to compare to
     * @returns {boolean} Whether the password matches the hash
     */
    function compareSync(plaintext, hash) {
        try {
            return bcrypt.checkpw(plaintext, hash);
        }
        catch {
            return false;
        }
    }
    exports_158("compareSync", compareSync);
    /**
     * Generates a salt using a number of log rounds
     * This function is blocking and computationally expensive but requires no additonal flags.
     * Using the async variant is highly recommended.
     *
     * @export
     * @param {(number | undefined)} [log_rounds=undefined] Number of log rounds to use. Recommended to leave this undefined.
     * @returns {string} The generated salt
     */
    function genSaltSync(log_rounds = undefined) {
        return bcrypt.gensalt(log_rounds);
    }
    exports_158("genSaltSync", genSaltSync);
    /**
     * Generate a hash for the plaintext password
     * This function is blocking and computationally expensive but requires no additonal flags.
     * Using the async variant is highly recommended.
     *
     * @export
     * @param {string} plaintext The password to hash
     * @param {(string | undefined)} [salt=undefined] The salt to use when hashing. Recommended to leave this undefined.
     * @returns {string} The hashed password
     */
    function hashSync(plaintext, salt = undefined) {
        return bcrypt.hashpw(plaintext, salt);
    }
    exports_158("hashSync", hashSync);
    return {
        setters: [
            function (bcrypt_1) {
                bcrypt = bcrypt_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/bcrypt/mod", ["https://deno.land/x/bcrypt/main"], function (exports_159, context_159) {
    "use strict";
    var __moduleName = context_159 && context_159.id;
    return {
        setters: [
            function (main_ts_1_1) {
                exports_159({
                    "genSalt": main_ts_1_1["genSalt"],
                    "compare": main_ts_1_1["compare"],
                    "hash": main_ts_1_1["hash"],
                    "genSaltSync": main_ts_1_1["genSaltSync"],
                    "compareSync": main_ts_1_1["compareSync"],
                    "hashSync": main_ts_1_1["hashSync"]
                });
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/nanoid/random", [], function (exports_160, context_160) {
    "use strict";
    var buffers;
    var __moduleName = context_160 && context_160.id;
    return {
        setters: [],
        execute: function () {
            // Storing the buffers should conserve memory. Have to do more benchmarks to test if this is true
            buffers = {};
            exports_160("default", (bytes) => {
                let buf = buffers[bytes];
                if (!buf) {
                    buf = new Uint32Array(bytes);
                    if (bytes <= 255)
                        buffers[bytes] = buf;
                }
                return crypto.getRandomValues(buf);
            });
        }
    };
});
System.register("https://deno.land/x/nanoid/url", [], function (exports_161, context_161) {
    "use strict";
    var i;
    var __moduleName = context_161 && context_161.id;
    return {
        setters: [],
        execute: function () {
            exports_161("default", '_-' + String.fromCharCode(
            // ASCII codes for 0...9
            i = 48, i += 1, i += 1, i += 1, i += 1, i += 1, i += 1, i += 1, i += 1, i += 1, 
            // ASCII codes for A...Z
            i += 8, i += 1, i += 1, i += 1, i += 1, i += 1, i += 1, i += 1, i += 1, i += 1, i += 1, i += 1, i += 1, i += 1, i += 1, i += 1, i += 1, i += 1, i += 1, i += 1, i += 1, i += 1, i += 1, i += 1, i += 1, i += 1, 
            // ASCII codes for a...z
            i += 7, i += 1, i += 1, i += 1, i += 1, i += 1, i += 1, i += 1, i += 1, i += 1, i += 1, i += 1, i += 1, i += 1, i += 1, i += 1, i += 1, i += 1, i += 1, i += 1, i += 1, i += 1, i += 1, i += 1, i += 1, i += 1));
        }
    };
});
System.register("https://deno.land/x/nanoid/customRandom", [], function (exports_162, context_162) {
    "use strict";
    var customRandom;
    var __moduleName = context_162 && context_162.id;
    return {
        setters: [],
        execute: function () {
            exports_162("customRandom", customRandom = (random, alphabet, size) => {
                const mask = (2 << Math.log(alphabet.length - 1) / Math.LN2) - 1;
                const step = -~(1.6 * mask * size / alphabet.length);
                return () => {
                    let id = "";
                    while (true) {
                        const bytes = random(step);
                        let i = step;
                        while (i--) {
                            // If random byte is bigger than alphabet even after bitmask,
                            // we refuse it by `|| ''`.
                            id += alphabet[bytes[i] & mask] || '';
                            if (id.length === +size)
                                return id;
                        }
                    }
                };
            });
            exports_162("default", customRandom);
        }
    };
});
System.register("https://deno.land/x/nanoid/customAlphabet", ["https://deno.land/x/nanoid/random", "https://deno.land/x/nanoid/customRandom"], function (exports_163, context_163) {
    "use strict";
    var random_ts_1, customRandom_ts_1, customAlphabet;
    var __moduleName = context_163 && context_163.id;
    return {
        setters: [
            function (random_ts_1_1) {
                random_ts_1 = random_ts_1_1;
            },
            function (customRandom_ts_1_1) {
                customRandom_ts_1 = customRandom_ts_1_1;
            }
        ],
        execute: function () {
            /**
             * Low-level function to change alphabet and ID size.
             *
             * Alphabet must contain 256 symbols or less. Otherwise, the generator
             * will not be secure.
             *
             * @param {string} alphabet Symbols to be used in ID.
             * @param {number} size The number of symbols in ID.
             *
             * @return {string} Unique ID.
             *
             * @example
             * const generate = require('nanoid/generate')
             * model.id = generate('0123456789абвгдеё', 5) //=> "8ё56а"
             *
             * @name generate
             * @function
             */
            exports_163("customAlphabet", customAlphabet = (alphabet, size) => customRandom_ts_1.default(random_ts_1.default, alphabet, size));
            exports_163("default", customAlphabet);
        }
    };
});
System.register("https://deno.land/x/nanoid/mod", ["https://deno.land/x/nanoid/random", "https://deno.land/x/nanoid/url", "https://deno.land/x/nanoid/customAlphabet", "https://deno.land/x/nanoid/customRandom"], function (exports_164, context_164) {
    "use strict";
    var random_ts_2, url_ts_1, nanoid;
    var __moduleName = context_164 && context_164.id;
    var exportedNames_4 = {
        "nanoid": true
    };
    function exportStar_7(m) {
        var exports = {};
        for (var n in m) {
            if (n !== "default" && !exportedNames_4.hasOwnProperty(n)) exports[n] = m[n];
        }
        exports_164(exports);
    }
    return {
        setters: [
            function (random_ts_2_1) {
                random_ts_2 = random_ts_2_1;
                exportStar_7(random_ts_2_1);
            },
            function (url_ts_1_1) {
                url_ts_1 = url_ts_1_1;
                exportStar_7(url_ts_1_1);
            },
            function (customAlphabet_ts_1_1) {
                exportStar_7(customAlphabet_ts_1_1);
            },
            function (customRandom_ts_2_1) {
                exportStar_7(customRandom_ts_2_1);
            }
        ],
        execute: function () {
            exports_164("nanoid", nanoid = (size = 21) => {
                let id = "";
                const bytes = random_ts_2.default(size);
                // Compact alternative for `for (var i = 0; i < size; i++)`
                // We can’t use bytes bigger than the alphabet. 63 is 00111111 bitmask.
                // This mask reduces random byte 0-255 to 0-63 values.
                // There is no need in `|| ''` and `* 1.6` hacks in here,
                // because bitmask trim bytes exact to alphabet size.
                while (size--)
                    id += url_ts_1.default[bytes[size] & 63];
                return id;
            });
            exports_164("default", nanoid);
        }
    };
});
System.register("file:///home/jax/www/denoAPI2/src/controllers/user/UserModel", ["https://deno.land/x/dso@v1.0.0/mod"], function (exports_165, context_165) {
    "use strict";
    var mod_ts_25, UserModel, userModel;
    var __moduleName = context_165 && context_165.id;
    return {
        setters: [
            function (mod_ts_25_1) {
                mod_ts_25 = mod_ts_25_1;
            }
        ],
        execute: function () {
            UserModel = /** @class */ (() => {
                let UserModel = class UserModel extends mod_ts_25.BaseModel {
                    get modelFields() {
                        return (Reflect.getMetadata("model:fields", this) || []);
                    }
                };
                __decorate([
                    mod_ts_25.Field({ type: mod_ts_25.FieldType.INT, primary: true, length: 11, autoIncrement: true }),
                    __metadata("design:type", Number)
                ], UserModel.prototype, "id", void 0);
                __decorate([
                    mod_ts_25.Field({ type: mod_ts_25.FieldType.STRING, length: 26, notNull: true }),
                    __metadata("design:type", String)
                ], UserModel.prototype, "hash", void 0);
                __decorate([
                    mod_ts_25.Field({ type: mod_ts_25.FieldType.STRING, length: 80, notNull: true }),
                    __metadata("design:type", String)
                ], UserModel.prototype, "username", void 0);
                __decorate([
                    mod_ts_25.Field({ type: mod_ts_25.FieldType.STRING, length: 80, notNull: true }),
                    __metadata("design:type", String)
                ], UserModel.prototype, "password", void 0);
                __decorate([
                    mod_ts_25.Field({ type: mod_ts_25.FieldType.STRING, length: 80 }),
                    __metadata("design:type", String)
                ], UserModel.prototype, "namespace", void 0);
                __decorate([
                    mod_ts_25.Field({ type: mod_ts_25.FieldType.DATE, default: mod_ts_25.Defaults.CURRENT_TIMESTAMP }),
                    __metadata("design:type", String)
                ], UserModel.prototype, "created", void 0);
                __decorate([
                    mod_ts_25.Field({ type: mod_ts_25.FieldType.DATE, default: mod_ts_25.Defaults.CURRENT_TIMESTAMP, autoUpdate: true }),
                    __metadata("design:type", String)
                ], UserModel.prototype, "updated", void 0);
                UserModel = __decorate([
                    mod_ts_25.Model("users")
                ], UserModel);
                return UserModel;
            })();
            exports_165("UserModel", UserModel);
            userModel = mod_ts_25.dso.define(UserModel);
            exports_165("userModel", userModel);
        }
    };
});
System.register("https://deno.land/x/djwt/base64/base64", [], function (exports_166, context_166) {
    "use strict";
    var __moduleName = context_166 && context_166.id;
    function convertBase64ToUint8Array(data) {
        const binString = atob(data);
        const size = binString.length;
        const bytes = new Uint8Array(size);
        for (let i = 0; i < size; i++) {
            bytes[i] = binString.charCodeAt(i);
        }
        return bytes;
    }
    exports_166("convertBase64ToUint8Array", convertBase64ToUint8Array);
    // credit: https://gist.github.com/enepomnyaschih/72c423f727d395eeaa09697058238727
    function convertUint8ArrayToBase64(bytes) {
        const base64abc = (() => {
            const abc = [], A = "A".charCodeAt(0), a = "a".charCodeAt(0), n = "0".charCodeAt(0);
            for (let i = 0; i < 26; ++i) {
                abc.push(String.fromCharCode(A + i));
            }
            for (let i = 0; i < 26; ++i) {
                abc.push(String.fromCharCode(a + i));
            }
            for (let i = 0; i < 10; ++i) {
                abc.push(String.fromCharCode(n + i));
            }
            abc.push("+");
            abc.push("/");
            return abc;
        })();
        let result = "", i, l = bytes.length;
        for (i = 2; i < l; i += 3) {
            result += base64abc[bytes[i - 2] >> 2];
            result += base64abc[((bytes[i - 2] & 0x03) << 4) | (bytes[i - 1] >> 4)];
            result += base64abc[((bytes[i - 1] & 0x0f) << 2) | (bytes[i] >> 6)];
            result += base64abc[bytes[i] & 0x3f];
        }
        if (i === l + 1) {
            // 1 octet missing
            result += base64abc[bytes[i - 2] >> 2];
            result += base64abc[(bytes[i - 2] & 0x03) << 4];
            result += "==";
        }
        if (i === l) {
            // 2 octets missing
            result += base64abc[bytes[i - 2] >> 2];
            result += base64abc[((bytes[i - 2] & 0x03) << 4) | (bytes[i - 1] >> 4)];
            result += base64abc[(bytes[i - 1] & 0x0f) << 2];
            result += "=";
        }
        return result;
    }
    exports_166("convertUint8ArrayToBase64", convertUint8ArrayToBase64);
    // ucs-2 string to base64 encoded ascii
    function convertStringToBase64(str) {
        return btoa(unescape(encodeURIComponent(str)));
    }
    exports_166("convertStringToBase64", convertStringToBase64);
    // base64 encoded ascii to ucs-2 string
    function convertBase64ToString(str) {
        return decodeURIComponent(escape(atob(str)));
    }
    exports_166("convertBase64ToString", convertBase64ToString);
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/djwt/base64/base64url", ["https://deno.land/x/djwt/base64/base64"], function (exports_167, context_167) {
    "use strict";
    var base64_ts_1;
    var __moduleName = context_167 && context_167.id;
    function addPaddingToBase64url(base64url) {
        if (base64url.length % 4 === 2)
            return base64url + "==";
        if (base64url.length % 4 === 3)
            return base64url + "=";
        if (base64url.length % 4 === 1)
            throw new TypeError("Illegal base64url string!");
        return base64url;
    }
    exports_167("addPaddingToBase64url", addPaddingToBase64url);
    function convertBase64urlToBase64(base64url) {
        return addPaddingToBase64url(base64url).replace(/\-/g, "+").replace(/_/g, "/");
    }
    exports_167("convertBase64urlToBase64", convertBase64urlToBase64);
    function convertBase64ToBase64url(base64) {
        return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    exports_167("convertBase64ToBase64url", convertBase64ToBase64url);
    function convertBase64urlToUint8Array(base64url) {
        return base64_ts_1.convertBase64ToUint8Array(convertBase64urlToBase64(base64url));
    }
    exports_167("convertBase64urlToUint8Array", convertBase64urlToUint8Array);
    function convertUint8ArrayToBase64url(uint8Array) {
        return convertBase64ToBase64url(base64_ts_1.convertUint8ArrayToBase64(uint8Array));
    }
    exports_167("convertUint8ArrayToBase64url", convertUint8ArrayToBase64url);
    return {
        setters: [
            function (base64_ts_1_1) {
                base64_ts_1 = base64_ts_1_1;
            }
        ],
        execute: function () {
        }
    };
});
// Ported from Go
// https://github.com/golang/go/blob/go1.12.5/src/encoding/hex/hex.go
// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
// Copyright 2018-2020 the Deno authors. All rights reserved. MIT license.
System.register("https://deno.land/std@v0.56.0/encoding/hex", [], function (exports_168, context_168) {
    "use strict";
    var hextable;
    var __moduleName = context_168 && context_168.id;
    function errInvalidByte(byte) {
        return new Error("encoding/hex: invalid byte: " +
            new TextDecoder().decode(new Uint8Array([byte])));
    }
    exports_168("errInvalidByte", errInvalidByte);
    function errLength() {
        return new Error("encoding/hex: odd length hex string");
    }
    exports_168("errLength", errLength);
    // fromHexChar converts a hex character into its value and a success flag.
    function fromHexChar(byte) {
        switch (true) {
            case 48 <= byte && byte <= 57: // '0' <= byte && byte <= '9'
                return [byte - 48, true];
            case 97 <= byte && byte <= 102: // 'a' <= byte && byte <= 'f'
                return [byte - 97 + 10, true];
            case 65 <= byte && byte <= 70: // 'A' <= byte && byte <= 'F'
                return [byte - 65 + 10, true];
        }
        return [0, false];
    }
    /**
     * EncodedLen returns the length of an encoding of n source bytes. Specifically,
     * it returns n * 2.
     * @param n
     */
    function encodedLen(n) {
        return n * 2;
    }
    exports_168("encodedLen", encodedLen);
    /**
     * Encode encodes `src` into `encodedLen(src.length)` bytes of `dst`.
     * As a convenience, it returns the number of bytes written to `dst`
     * but this value is always `encodedLen(src.length)`.
     * Encode implements hexadecimal encoding.
     * @param dst
     * @param src
     */
    function encode(dst, src) {
        const srcLength = encodedLen(src.length);
        if (dst.length !== srcLength) {
            throw new Error("Out of index.");
        }
        for (let i = 0; i < src.length; i++) {
            const v = src[i];
            dst[i * 2] = hextable[v >> 4];
            dst[i * 2 + 1] = hextable[v & 0x0f];
        }
        return srcLength;
    }
    exports_168("encode", encode);
    /**
     * EncodeToString returns the hexadecimal encoding of `src`.
     * @param src
     */
    function encodeToString(src) {
        const dest = new Uint8Array(encodedLen(src.length));
        encode(dest, src);
        return new TextDecoder().decode(dest);
    }
    exports_168("encodeToString", encodeToString);
    /**
     * Decode decodes `src` into `decodedLen(src.length)` bytes
     * returning the actual number of bytes written to `dst`.
     * Decode expects that `src` contains only hexadecimal characters and that `src`
     * has even length.
     * If the input is malformed, Decode returns the number of bytes decoded before
     * the error.
     * @param dst
     * @param src
     */
    function decode(dst, src) {
        let i = 0;
        for (; i < Math.floor(src.length / 2); i++) {
            const [a, aOK] = fromHexChar(src[i * 2]);
            if (!aOK) {
                return [i, errInvalidByte(src[i * 2])];
            }
            const [b, bOK] = fromHexChar(src[i * 2 + 1]);
            if (!bOK) {
                return [i, errInvalidByte(src[i * 2 + 1])];
            }
            dst[i] = (a << 4) | b;
        }
        if (src.length % 2 == 1) {
            // Check for invalid char before reporting bad length,
            // since the invalid char (if present) is an earlier problem.
            const [, ok] = fromHexChar(src[i * 2]);
            if (!ok) {
                return [i, errInvalidByte(src[i * 2])];
            }
            return [i, errLength()];
        }
        return [i, undefined];
    }
    exports_168("decode", decode);
    /**
     * DecodedLen returns the length of a decoding of `x` source bytes.
     * Specifically, it returns `x / 2`.
     * @param x
     */
    function decodedLen(x) {
        return Math.floor(x / 2);
    }
    exports_168("decodedLen", decodedLen);
    /**
     * DecodeString returns the bytes represented by the hexadecimal string `s`.
     * DecodeString expects that src contains only hexadecimal characters and that
     * src has even length.
     * If the input is malformed, DecodeString will throws an error.
     * @param s the `string` need to decode to `Uint8Array`
     */
    function decodeString(s) {
        const src = new TextEncoder().encode(s);
        // We can use the source slice itself as the destination
        // because the decode loop increments by one and then the 'seen' byte is not
        // used anymore.
        const [n, err] = decode(src, src);
        if (err) {
            throw err;
        }
        return src.slice(0, n);
    }
    exports_168("decodeString", decodeString);
    return {
        setters: [],
        execute: function () {
            hextable = new TextEncoder().encode("0123456789abcdef");
        }
    };
});
/*
 * Adapted to deno from:
 *
 * [js-sha256]{@link https://github.com/emn178/js-sha256}
 *
 * @version 0.9.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2014-2017
 * @license MIT
 */
System.register("https://deno.land/std@v0.56.0/hash/sha256", [], function (exports_169, context_169) {
    "use strict";
    var HEX_CHARS, EXTRA, SHIFT, K, blocks, Sha256, HmacSha256;
    var __moduleName = context_169 && context_169.id;
    return {
        setters: [],
        execute: function () {
            HEX_CHARS = "0123456789abcdef".split("");
            EXTRA = [-2147483648, 8388608, 32768, 128];
            SHIFT = [24, 16, 8, 0];
            // prettier-ignore
            // deno-fmt-ignore
            K = [
                0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1,
                0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
                0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786,
                0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
                0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147,
                0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
                0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b,
                0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
                0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a,
                0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
                0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2,
            ];
            blocks = [];
            Sha256 = class Sha256 {
                constructor(is224 = false, sharedMemory = false) {
                    this.#lastByteIndex = 0;
                    this.init(is224, sharedMemory);
                }
                #block;
                #blocks;
                #bytes;
                #finalized;
                #first;
                #h0;
                #h1;
                #h2;
                #h3;
                #h4;
                #h5;
                #h6;
                #h7;
                #hashed;
                #hBytes;
                #is224;
                #lastByteIndex;
                #start;
                init(is224, sharedMemory) {
                    if (sharedMemory) {
                        blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
                        this.#blocks = blocks;
                    }
                    else {
                        this.#blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
                    }
                    if (is224) {
                        this.#h0 = 0xc1059ed8;
                        this.#h1 = 0x367cd507;
                        this.#h2 = 0x3070dd17;
                        this.#h3 = 0xf70e5939;
                        this.#h4 = 0xffc00b31;
                        this.#h5 = 0x68581511;
                        this.#h6 = 0x64f98fa7;
                        this.#h7 = 0xbefa4fa4;
                    }
                    else {
                        // 256
                        this.#h0 = 0x6a09e667;
                        this.#h1 = 0xbb67ae85;
                        this.#h2 = 0x3c6ef372;
                        this.#h3 = 0xa54ff53a;
                        this.#h4 = 0x510e527f;
                        this.#h5 = 0x9b05688c;
                        this.#h6 = 0x1f83d9ab;
                        this.#h7 = 0x5be0cd19;
                    }
                    this.#block = this.#start = this.#bytes = this.#hBytes = 0;
                    this.#finalized = this.#hashed = false;
                    this.#first = true;
                    this.#is224 = is224;
                }
                /** Update hash
                 *
                 * @param message The message you want to hash.
                 */
                update(message) {
                    if (this.#finalized) {
                        return this;
                    }
                    let msg;
                    if (message instanceof ArrayBuffer) {
                        msg = new Uint8Array(message);
                    }
                    else {
                        msg = message;
                    }
                    let index = 0;
                    const length = msg.length;
                    const blocks = this.#blocks;
                    while (index < length) {
                        let i;
                        if (this.#hashed) {
                            this.#hashed = false;
                            blocks[0] = this.#block;
                            blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
                        }
                        if (typeof msg !== "string") {
                            for (i = this.#start; index < length && i < 64; ++index) {
                                blocks[i >> 2] |= msg[index] << SHIFT[i++ & 3];
                            }
                        }
                        else {
                            for (i = this.#start; index < length && i < 64; ++index) {
                                let code = msg.charCodeAt(index);
                                if (code < 0x80) {
                                    blocks[i >> 2] |= code << SHIFT[i++ & 3];
                                }
                                else if (code < 0x800) {
                                    blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
                                }
                                else if (code < 0xd800 || code >= 0xe000) {
                                    blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
                                }
                                else {
                                    code =
                                        0x10000 +
                                            (((code & 0x3ff) << 10) | (msg.charCodeAt(++index) & 0x3ff));
                                    blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
                                }
                            }
                        }
                        this.#lastByteIndex = i;
                        this.#bytes += i - this.#start;
                        if (i >= 64) {
                            this.#block = blocks[16];
                            this.#start = i - 64;
                            this.hash();
                            this.#hashed = true;
                        }
                        else {
                            this.#start = i;
                        }
                    }
                    if (this.#bytes > 4294967295) {
                        this.#hBytes += (this.#bytes / 4294967296) << 0;
                        this.#bytes = this.#bytes % 4294967296;
                    }
                    return this;
                }
                finalize() {
                    if (this.#finalized) {
                        return;
                    }
                    this.#finalized = true;
                    const blocks = this.#blocks;
                    const i = this.#lastByteIndex;
                    blocks[16] = this.#block;
                    blocks[i >> 2] |= EXTRA[i & 3];
                    this.#block = blocks[16];
                    if (i >= 56) {
                        if (!this.#hashed) {
                            this.hash();
                        }
                        blocks[0] = this.#block;
                        blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
                    }
                    blocks[14] = (this.#hBytes << 3) | (this.#bytes >>> 29);
                    blocks[15] = this.#bytes << 3;
                    this.hash();
                }
                hash() {
                    let a = this.#h0;
                    let b = this.#h1;
                    let c = this.#h2;
                    let d = this.#h3;
                    let e = this.#h4;
                    let f = this.#h5;
                    let g = this.#h6;
                    let h = this.#h7;
                    const blocks = this.#blocks;
                    let s0;
                    let s1;
                    let maj;
                    let t1;
                    let t2;
                    let ch;
                    let ab;
                    let da;
                    let cd;
                    let bc;
                    for (let j = 16; j < 64; ++j) {
                        // rightrotate
                        t1 = blocks[j - 15];
                        s0 = ((t1 >>> 7) | (t1 << 25)) ^ ((t1 >>> 18) | (t1 << 14)) ^ (t1 >>> 3);
                        t1 = blocks[j - 2];
                        s1 =
                            ((t1 >>> 17) | (t1 << 15)) ^ ((t1 >>> 19) | (t1 << 13)) ^ (t1 >>> 10);
                        blocks[j] = (blocks[j - 16] + s0 + blocks[j - 7] + s1) << 0;
                    }
                    bc = b & c;
                    for (let j = 0; j < 64; j += 4) {
                        if (this.#first) {
                            if (this.#is224) {
                                ab = 300032;
                                t1 = blocks[0] - 1413257819;
                                h = (t1 - 150054599) << 0;
                                d = (t1 + 24177077) << 0;
                            }
                            else {
                                ab = 704751109;
                                t1 = blocks[0] - 210244248;
                                h = (t1 - 1521486534) << 0;
                                d = (t1 + 143694565) << 0;
                            }
                            this.#first = false;
                        }
                        else {
                            s0 =
                                ((a >>> 2) | (a << 30)) ^
                                    ((a >>> 13) | (a << 19)) ^
                                    ((a >>> 22) | (a << 10));
                            s1 =
                                ((e >>> 6) | (e << 26)) ^
                                    ((e >>> 11) | (e << 21)) ^
                                    ((e >>> 25) | (e << 7));
                            ab = a & b;
                            maj = ab ^ (a & c) ^ bc;
                            ch = (e & f) ^ (~e & g);
                            t1 = h + s1 + ch + K[j] + blocks[j];
                            t2 = s0 + maj;
                            h = (d + t1) << 0;
                            d = (t1 + t2) << 0;
                        }
                        s0 =
                            ((d >>> 2) | (d << 30)) ^
                                ((d >>> 13) | (d << 19)) ^
                                ((d >>> 22) | (d << 10));
                        s1 =
                            ((h >>> 6) | (h << 26)) ^
                                ((h >>> 11) | (h << 21)) ^
                                ((h >>> 25) | (h << 7));
                        da = d & a;
                        maj = da ^ (d & b) ^ ab;
                        ch = (h & e) ^ (~h & f);
                        t1 = g + s1 + ch + K[j + 1] + blocks[j + 1];
                        t2 = s0 + maj;
                        g = (c + t1) << 0;
                        c = (t1 + t2) << 0;
                        s0 =
                            ((c >>> 2) | (c << 30)) ^
                                ((c >>> 13) | (c << 19)) ^
                                ((c >>> 22) | (c << 10));
                        s1 =
                            ((g >>> 6) | (g << 26)) ^
                                ((g >>> 11) | (g << 21)) ^
                                ((g >>> 25) | (g << 7));
                        cd = c & d;
                        maj = cd ^ (c & a) ^ da;
                        ch = (g & h) ^ (~g & e);
                        t1 = f + s1 + ch + K[j + 2] + blocks[j + 2];
                        t2 = s0 + maj;
                        f = (b + t1) << 0;
                        b = (t1 + t2) << 0;
                        s0 =
                            ((b >>> 2) | (b << 30)) ^
                                ((b >>> 13) | (b << 19)) ^
                                ((b >>> 22) | (b << 10));
                        s1 =
                            ((f >>> 6) | (f << 26)) ^
                                ((f >>> 11) | (f << 21)) ^
                                ((f >>> 25) | (f << 7));
                        bc = b & c;
                        maj = bc ^ (b & d) ^ cd;
                        ch = (f & g) ^ (~f & h);
                        t1 = e + s1 + ch + K[j + 3] + blocks[j + 3];
                        t2 = s0 + maj;
                        e = (a + t1) << 0;
                        a = (t1 + t2) << 0;
                    }
                    this.#h0 = (this.#h0 + a) << 0;
                    this.#h1 = (this.#h1 + b) << 0;
                    this.#h2 = (this.#h2 + c) << 0;
                    this.#h3 = (this.#h3 + d) << 0;
                    this.#h4 = (this.#h4 + e) << 0;
                    this.#h5 = (this.#h5 + f) << 0;
                    this.#h6 = (this.#h6 + g) << 0;
                    this.#h7 = (this.#h7 + h) << 0;
                }
                /** Return hash in hex string. */
                hex() {
                    this.finalize();
                    const h0 = this.#h0;
                    const h1 = this.#h1;
                    const h2 = this.#h2;
                    const h3 = this.#h3;
                    const h4 = this.#h4;
                    const h5 = this.#h5;
                    const h6 = this.#h6;
                    const h7 = this.#h7;
                    let hex = HEX_CHARS[(h0 >> 28) & 0x0f] +
                        HEX_CHARS[(h0 >> 24) & 0x0f] +
                        HEX_CHARS[(h0 >> 20) & 0x0f] +
                        HEX_CHARS[(h0 >> 16) & 0x0f] +
                        HEX_CHARS[(h0 >> 12) & 0x0f] +
                        HEX_CHARS[(h0 >> 8) & 0x0f] +
                        HEX_CHARS[(h0 >> 4) & 0x0f] +
                        HEX_CHARS[h0 & 0x0f] +
                        HEX_CHARS[(h1 >> 28) & 0x0f] +
                        HEX_CHARS[(h1 >> 24) & 0x0f] +
                        HEX_CHARS[(h1 >> 20) & 0x0f] +
                        HEX_CHARS[(h1 >> 16) & 0x0f] +
                        HEX_CHARS[(h1 >> 12) & 0x0f] +
                        HEX_CHARS[(h1 >> 8) & 0x0f] +
                        HEX_CHARS[(h1 >> 4) & 0x0f] +
                        HEX_CHARS[h1 & 0x0f] +
                        HEX_CHARS[(h2 >> 28) & 0x0f] +
                        HEX_CHARS[(h2 >> 24) & 0x0f] +
                        HEX_CHARS[(h2 >> 20) & 0x0f] +
                        HEX_CHARS[(h2 >> 16) & 0x0f] +
                        HEX_CHARS[(h2 >> 12) & 0x0f] +
                        HEX_CHARS[(h2 >> 8) & 0x0f] +
                        HEX_CHARS[(h2 >> 4) & 0x0f] +
                        HEX_CHARS[h2 & 0x0f] +
                        HEX_CHARS[(h3 >> 28) & 0x0f] +
                        HEX_CHARS[(h3 >> 24) & 0x0f] +
                        HEX_CHARS[(h3 >> 20) & 0x0f] +
                        HEX_CHARS[(h3 >> 16) & 0x0f] +
                        HEX_CHARS[(h3 >> 12) & 0x0f] +
                        HEX_CHARS[(h3 >> 8) & 0x0f] +
                        HEX_CHARS[(h3 >> 4) & 0x0f] +
                        HEX_CHARS[h3 & 0x0f] +
                        HEX_CHARS[(h4 >> 28) & 0x0f] +
                        HEX_CHARS[(h4 >> 24) & 0x0f] +
                        HEX_CHARS[(h4 >> 20) & 0x0f] +
                        HEX_CHARS[(h4 >> 16) & 0x0f] +
                        HEX_CHARS[(h4 >> 12) & 0x0f] +
                        HEX_CHARS[(h4 >> 8) & 0x0f] +
                        HEX_CHARS[(h4 >> 4) & 0x0f] +
                        HEX_CHARS[h4 & 0x0f] +
                        HEX_CHARS[(h5 >> 28) & 0x0f] +
                        HEX_CHARS[(h5 >> 24) & 0x0f] +
                        HEX_CHARS[(h5 >> 20) & 0x0f] +
                        HEX_CHARS[(h5 >> 16) & 0x0f] +
                        HEX_CHARS[(h5 >> 12) & 0x0f] +
                        HEX_CHARS[(h5 >> 8) & 0x0f] +
                        HEX_CHARS[(h5 >> 4) & 0x0f] +
                        HEX_CHARS[h5 & 0x0f] +
                        HEX_CHARS[(h6 >> 28) & 0x0f] +
                        HEX_CHARS[(h6 >> 24) & 0x0f] +
                        HEX_CHARS[(h6 >> 20) & 0x0f] +
                        HEX_CHARS[(h6 >> 16) & 0x0f] +
                        HEX_CHARS[(h6 >> 12) & 0x0f] +
                        HEX_CHARS[(h6 >> 8) & 0x0f] +
                        HEX_CHARS[(h6 >> 4) & 0x0f] +
                        HEX_CHARS[h6 & 0x0f];
                    if (!this.#is224) {
                        hex +=
                            HEX_CHARS[(h7 >> 28) & 0x0f] +
                                HEX_CHARS[(h7 >> 24) & 0x0f] +
                                HEX_CHARS[(h7 >> 20) & 0x0f] +
                                HEX_CHARS[(h7 >> 16) & 0x0f] +
                                HEX_CHARS[(h7 >> 12) & 0x0f] +
                                HEX_CHARS[(h7 >> 8) & 0x0f] +
                                HEX_CHARS[(h7 >> 4) & 0x0f] +
                                HEX_CHARS[h7 & 0x0f];
                    }
                    return hex;
                }
                /** Return hash in hex string. */
                toString() {
                    return this.hex();
                }
                /** Return hash in integer array. */
                digest() {
                    this.finalize();
                    const h0 = this.#h0;
                    const h1 = this.#h1;
                    const h2 = this.#h2;
                    const h3 = this.#h3;
                    const h4 = this.#h4;
                    const h5 = this.#h5;
                    const h6 = this.#h6;
                    const h7 = this.#h7;
                    const arr = [
                        (h0 >> 24) & 0xff,
                        (h0 >> 16) & 0xff,
                        (h0 >> 8) & 0xff,
                        h0 & 0xff,
                        (h1 >> 24) & 0xff,
                        (h1 >> 16) & 0xff,
                        (h1 >> 8) & 0xff,
                        h1 & 0xff,
                        (h2 >> 24) & 0xff,
                        (h2 >> 16) & 0xff,
                        (h2 >> 8) & 0xff,
                        h2 & 0xff,
                        (h3 >> 24) & 0xff,
                        (h3 >> 16) & 0xff,
                        (h3 >> 8) & 0xff,
                        h3 & 0xff,
                        (h4 >> 24) & 0xff,
                        (h4 >> 16) & 0xff,
                        (h4 >> 8) & 0xff,
                        h4 & 0xff,
                        (h5 >> 24) & 0xff,
                        (h5 >> 16) & 0xff,
                        (h5 >> 8) & 0xff,
                        h5 & 0xff,
                        (h6 >> 24) & 0xff,
                        (h6 >> 16) & 0xff,
                        (h6 >> 8) & 0xff,
                        h6 & 0xff,
                    ];
                    if (!this.#is224) {
                        arr.push((h7 >> 24) & 0xff, (h7 >> 16) & 0xff, (h7 >> 8) & 0xff, h7 & 0xff);
                    }
                    return arr;
                }
                /** Return hash in integer array. */
                array() {
                    return this.digest();
                }
                /** Return hash in ArrayBuffer. */
                arrayBuffer() {
                    this.finalize();
                    const buffer = new ArrayBuffer(this.#is224 ? 28 : 32);
                    const dataView = new DataView(buffer);
                    dataView.setUint32(0, this.#h0);
                    dataView.setUint32(4, this.#h1);
                    dataView.setUint32(8, this.#h2);
                    dataView.setUint32(12, this.#h3);
                    dataView.setUint32(16, this.#h4);
                    dataView.setUint32(20, this.#h5);
                    dataView.setUint32(24, this.#h6);
                    if (!this.#is224) {
                        dataView.setUint32(28, this.#h7);
                    }
                    return buffer;
                }
            };
            exports_169("Sha256", Sha256);
            HmacSha256 = class HmacSha256 extends Sha256 {
                constructor(secretKey, is224 = false, sharedMemory = false) {
                    super(is224, sharedMemory);
                    let key;
                    if (typeof secretKey === "string") {
                        const bytes = [];
                        const length = secretKey.length;
                        let index = 0;
                        for (let i = 0; i < length; ++i) {
                            let code = secretKey.charCodeAt(i);
                            if (code < 0x80) {
                                bytes[index++] = code;
                            }
                            else if (code < 0x800) {
                                bytes[index++] = 0xc0 | (code >> 6);
                                bytes[index++] = 0x80 | (code & 0x3f);
                            }
                            else if (code < 0xd800 || code >= 0xe000) {
                                bytes[index++] = 0xe0 | (code >> 12);
                                bytes[index++] = 0x80 | ((code >> 6) & 0x3f);
                                bytes[index++] = 0x80 | (code & 0x3f);
                            }
                            else {
                                code =
                                    0x10000 +
                                        (((code & 0x3ff) << 10) | (secretKey.charCodeAt(++i) & 0x3ff));
                                bytes[index++] = 0xf0 | (code >> 18);
                                bytes[index++] = 0x80 | ((code >> 12) & 0x3f);
                                bytes[index++] = 0x80 | ((code >> 6) & 0x3f);
                                bytes[index++] = 0x80 | (code & 0x3f);
                            }
                        }
                        key = bytes;
                    }
                    else {
                        if (secretKey instanceof ArrayBuffer) {
                            key = new Uint8Array(secretKey);
                        }
                        else {
                            key = secretKey;
                        }
                    }
                    if (key.length > 64) {
                        key = new Sha256(is224, true).update(key).array();
                    }
                    const oKeyPad = [];
                    const iKeyPad = [];
                    for (let i = 0; i < 64; ++i) {
                        const b = key[i] || 0;
                        oKeyPad[i] = 0x5c ^ b;
                        iKeyPad[i] = 0x36 ^ b;
                    }
                    this.update(iKeyPad);
                    this.#oKeyPad = oKeyPad;
                    this.#inner = true;
                    this.#is224 = is224;
                    this.#sharedMemory = sharedMemory;
                }
                #inner;
                #is224;
                #oKeyPad;
                #sharedMemory;
                finalize() {
                    super.finalize();
                    if (this.#inner) {
                        this.#inner = false;
                        const innerHash = this.array();
                        super.init(this.#is224, this.#sharedMemory);
                        this.update(this.#oKeyPad);
                        this.update(innerHash);
                        super.finalize();
                    }
                }
            };
            exports_169("HmacSha256", HmacSha256);
        }
    };
});
/*
 * [js-sha512]{@link https://github.com/emn178/js-sha512}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2014-2018
 * @license MIT
 */
System.register("https://deno.land/std@v0.56.0/hash/sha512", [], function (exports_170, context_170) {
    "use strict";
    var HEX_CHARS, EXTRA, SHIFT, K, blocks, Sha512, HmacSha512;
    var __moduleName = context_170 && context_170.id;
    return {
        setters: [],
        execute: function () {
            // prettier-ignore
            HEX_CHARS = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
            EXTRA = [-2147483648, 8388608, 32768, 128];
            SHIFT = [24, 16, 8, 0];
            // prettier-ignore
            K = [
                0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd, 0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc, 0x3956c25b,
                0xf348b538, 0x59f111f1, 0xb605d019, 0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118, 0xd807aa98, 0xa3030242,
                0x12835b01, 0x45706fbe, 0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2, 0x72be5d74, 0xf27b896f, 0x80deb1fe,
                0x3b1696b1, 0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694, 0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
                0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65, 0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483, 0x5cb0a9dc,
                0xbd41fbd4, 0x76f988da, 0x831153b5, 0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210, 0xb00327c8, 0x98fb213f,
                0xbf597fc7, 0xbeef0ee4, 0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725, 0x06ca6351, 0xe003826f, 0x14292967,
                0x0a0e6e70, 0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926, 0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
                0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8, 0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b, 0xa2bfe8a1,
                0x4cf10364, 0xa81a664b, 0xbc423001, 0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30, 0xd192e819, 0xd6ef5218,
                0xd6990624, 0x5565a910, 0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8, 0x19a4c116, 0xb8d2d0c8, 0x1e376c08,
                0x5141ab53, 0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8, 0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
                0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3, 0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60, 0x84c87814,
                0xa1f0ab72, 0x8cc70208, 0x1a6439ec, 0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9, 0xbef9a3f7, 0xb2c67915,
                0xc67178f2, 0xe372532b, 0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207, 0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f,
                0xee6ed178, 0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6, 0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
                0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493, 0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c, 0x4cc5d4be,
                0xcb3e42b6, 0x597f299c, 0xfc657e2a, 0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
            ];
            blocks = [];
            // prettier-ignore
            Sha512 = class Sha512 {
                constructor(bits = 512, sharedMemory = false) {
                    this.#lastByteIndex = 0;
                    this.init(bits, sharedMemory);
                }
                #blocks;
                #block;
                #bits;
                #start;
                #bytes;
                #hBytes;
                #lastByteIndex;
                #finalized;
                #hashed;
                #h0h;
                #h0l;
                #h1h;
                #h1l;
                #h2h;
                #h2l;
                #h3h;
                #h3l;
                #h4h;
                #h4l;
                #h5h;
                #h5l;
                #h6h;
                #h6l;
                #h7h;
                #h7l;
                init(bits, sharedMemory) {
                    if (sharedMemory) {
                        blocks[0] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] =
                            blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = blocks[16] =
                                blocks[17] = blocks[18] = blocks[19] = blocks[20] = blocks[21] = blocks[22] = blocks[23] = blocks[24] =
                                    blocks[25] = blocks[26] = blocks[27] = blocks[28] = blocks[29] = blocks[30] = blocks[31] = blocks[32] = 0;
                        this.#blocks = blocks;
                    }
                    else {
                        this.#blocks =
                            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
                    }
                    if (bits === 224) {
                        this.#h0h = 0x8c3d37c8;
                        this.#h0l = 0x19544da2;
                        this.#h1h = 0x73e19966;
                        this.#h1l = 0x89dcd4d6;
                        this.#h2h = 0x1dfab7ae;
                        this.#h2l = 0x32ff9c82;
                        this.#h3h = 0x679dd514;
                        this.#h3l = 0x582f9fcf;
                        this.#h4h = 0x0f6d2b69;
                        this.#h4l = 0x7bd44da8;
                        this.#h5h = 0x77e36f73;
                        this.#h5l = 0x04c48942;
                        this.#h6h = 0x3f9d85a8;
                        this.#h6l = 0x6a1d36c8;
                        this.#h7h = 0x1112e6ad;
                        this.#h7l = 0x91d692a1;
                    }
                    else if (bits === 256) {
                        this.#h0h = 0x22312194;
                        this.#h0l = 0xfc2bf72c;
                        this.#h1h = 0x9f555fa3;
                        this.#h1l = 0xc84c64c2;
                        this.#h2h = 0x2393b86b;
                        this.#h2l = 0x6f53b151;
                        this.#h3h = 0x96387719;
                        this.#h3l = 0x5940eabd;
                        this.#h4h = 0x96283ee2;
                        this.#h4l = 0xa88effe3;
                        this.#h5h = 0xbe5e1e25;
                        this.#h5l = 0x53863992;
                        this.#h6h = 0x2b0199fc;
                        this.#h6l = 0x2c85b8aa;
                        this.#h7h = 0x0eb72ddc;
                        this.#h7l = 0x81c52ca2;
                    }
                    else if (bits === 384) {
                        this.#h0h = 0xcbbb9d5d;
                        this.#h0l = 0xc1059ed8;
                        this.#h1h = 0x629a292a;
                        this.#h1l = 0x367cd507;
                        this.#h2h = 0x9159015a;
                        this.#h2l = 0x3070dd17;
                        this.#h3h = 0x152fecd8;
                        this.#h3l = 0xf70e5939;
                        this.#h4h = 0x67332667;
                        this.#h4l = 0xffc00b31;
                        this.#h5h = 0x8eb44a87;
                        this.#h5l = 0x68581511;
                        this.#h6h = 0xdb0c2e0d;
                        this.#h6l = 0x64f98fa7;
                        this.#h7h = 0x47b5481d;
                        this.#h7l = 0xbefa4fa4;
                    }
                    else { // 512
                        this.#h0h = 0x6a09e667;
                        this.#h0l = 0xf3bcc908;
                        this.#h1h = 0xbb67ae85;
                        this.#h1l = 0x84caa73b;
                        this.#h2h = 0x3c6ef372;
                        this.#h2l = 0xfe94f82b;
                        this.#h3h = 0xa54ff53a;
                        this.#h3l = 0x5f1d36f1;
                        this.#h4h = 0x510e527f;
                        this.#h4l = 0xade682d1;
                        this.#h5h = 0x9b05688c;
                        this.#h5l = 0x2b3e6c1f;
                        this.#h6h = 0x1f83d9ab;
                        this.#h6l = 0xfb41bd6b;
                        this.#h7h = 0x5be0cd19;
                        this.#h7l = 0x137e2179;
                    }
                    this.#bits = bits;
                    this.#block = this.#start = this.#bytes = this.#hBytes = 0;
                    this.#finalized = this.#hashed = false;
                }
                update(message) {
                    if (this.#finalized) {
                        return this;
                    }
                    let msg;
                    if (message instanceof ArrayBuffer) {
                        msg = new Uint8Array(message);
                    }
                    else {
                        msg = message;
                    }
                    const length = msg.length;
                    const blocks = this.#blocks;
                    let index = 0;
                    while (index < length) {
                        let i;
                        if (this.#hashed) {
                            this.#hashed = false;
                            blocks[0] = this.#block;
                            blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] =
                                blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = blocks[16] =
                                    blocks[17] = blocks[18] = blocks[19] = blocks[20] = blocks[21] = blocks[22] = blocks[23] = blocks[24] =
                                        blocks[25] = blocks[26] = blocks[27] = blocks[28] = blocks[29] = blocks[30] = blocks[31] = blocks[32] = 0;
                        }
                        if (typeof msg !== "string") {
                            for (i = this.#start; index < length && i < 128; ++index) {
                                blocks[i >> 2] |= msg[index] << SHIFT[i++ & 3];
                            }
                        }
                        else {
                            for (i = this.#start; index < length && i < 128; ++index) {
                                let code = msg.charCodeAt(index);
                                if (code < 0x80) {
                                    blocks[i >> 2] |= code << SHIFT[i++ & 3];
                                }
                                else if (code < 0x800) {
                                    blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
                                }
                                else if (code < 0xd800 || code >= 0xe000) {
                                    blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
                                }
                                else {
                                    code = 0x10000 + (((code & 0x3ff) << 10) | (msg.charCodeAt(++index) & 0x3ff));
                                    blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
                                }
                            }
                        }
                        this.#lastByteIndex = i;
                        this.#bytes += i - this.#start;
                        if (i >= 128) {
                            this.#block = blocks[32];
                            this.#start = i - 128;
                            this.hash();
                            this.#hashed = true;
                        }
                        else {
                            this.#start = i;
                        }
                    }
                    if (this.#bytes > 4294967295) {
                        this.#hBytes += (this.#bytes / 4294967296) << 0;
                        this.#bytes = this.#bytes % 4294967296;
                    }
                    return this;
                }
                finalize() {
                    if (this.#finalized) {
                        return;
                    }
                    this.#finalized = true;
                    const blocks = this.#blocks;
                    const i = this.#lastByteIndex;
                    blocks[32] = this.#block;
                    blocks[i >> 2] |= EXTRA[i & 3];
                    this.#block = blocks[32];
                    if (i >= 112) {
                        if (!this.#hashed) {
                            this.hash();
                        }
                        blocks[0] = this.#block;
                        blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] =
                            blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = blocks[16] =
                                blocks[17] = blocks[18] = blocks[19] = blocks[20] = blocks[21] = blocks[22] = blocks[23] = blocks[24] =
                                    blocks[25] = blocks[26] = blocks[27] = blocks[28] = blocks[29] = blocks[30] = blocks[31] = blocks[32] = 0;
                    }
                    blocks[30] = (this.#hBytes << 3) | (this.#bytes >>> 29);
                    blocks[31] = this.#bytes << 3;
                    this.hash();
                }
                hash() {
                    const h0h = this.#h0h, h0l = this.#h0l, h1h = this.#h1h, h1l = this.#h1l, h2h = this.#h2h, h2l = this.#h2l, h3h = this.#h3h, h3l = this.#h3l, h4h = this.#h4h, h4l = this.#h4l, h5h = this.#h5h, h5l = this.#h5l, h6h = this.#h6h, h6l = this.#h6l, h7h = this.#h7h, h7l = this.#h7l;
                    let s0h, s0l, s1h, s1l, c1, c2, c3, c4, abh, abl, dah, dal, cdh, cdl, bch, bcl, majh, majl, t1h, t1l, t2h, t2l, chh, chl;
                    const blocks = this.#blocks;
                    for (let j = 32; j < 160; j += 2) {
                        t1h = blocks[j - 30];
                        t1l = blocks[j - 29];
                        s0h = ((t1h >>> 1) | (t1l << 31)) ^ ((t1h >>> 8) | (t1l << 24)) ^ (t1h >>> 7);
                        s0l = ((t1l >>> 1) | (t1h << 31)) ^ ((t1l >>> 8) | (t1h << 24)) ^ ((t1l >>> 7) | (t1h << 25));
                        t1h = blocks[j - 4];
                        t1l = blocks[j - 3];
                        s1h = ((t1h >>> 19) | (t1l << 13)) ^ ((t1l >>> 29) | (t1h << 3)) ^ (t1h >>> 6);
                        s1l = ((t1l >>> 19) | (t1h << 13)) ^ ((t1h >>> 29) | (t1l << 3)) ^ ((t1l >>> 6) | (t1h << 26));
                        t1h = blocks[j - 32];
                        t1l = blocks[j - 31];
                        t2h = blocks[j - 14];
                        t2l = blocks[j - 13];
                        c1 = (t2l & 0xffff) + (t1l & 0xffff) + (s0l & 0xffff) + (s1l & 0xffff);
                        c2 = (t2l >>> 16) + (t1l >>> 16) + (s0l >>> 16) + (s1l >>> 16) + (c1 >>> 16);
                        c3 = (t2h & 0xffff) + (t1h & 0xffff) + (s0h & 0xffff) + (s1h & 0xffff) + (c2 >>> 16);
                        c4 = (t2h >>> 16) + (t1h >>> 16) + (s0h >>> 16) + (s1h >>> 16) + (c3 >>> 16);
                        blocks[j] = (c4 << 16) | (c3 & 0xffff);
                        blocks[j + 1] = (c2 << 16) | (c1 & 0xffff);
                    }
                    let ah = h0h, al = h0l, bh = h1h, bl = h1l, ch = h2h, cl = h2l, dh = h3h, dl = h3l, eh = h4h, el = h4l, fh = h5h, fl = h5l, gh = h6h, gl = h6l, hh = h7h, hl = h7l;
                    bch = bh & ch;
                    bcl = bl & cl;
                    for (let j = 0; j < 160; j += 8) {
                        s0h = ((ah >>> 28) | (al << 4)) ^ ((al >>> 2) | (ah << 30)) ^ ((al >>> 7) | (ah << 25));
                        s0l = ((al >>> 28) | (ah << 4)) ^ ((ah >>> 2) | (al << 30)) ^ ((ah >>> 7) | (al << 25));
                        s1h = ((eh >>> 14) | (el << 18)) ^ ((eh >>> 18) | (el << 14)) ^ ((el >>> 9) | (eh << 23));
                        s1l = ((el >>> 14) | (eh << 18)) ^ ((el >>> 18) | (eh << 14)) ^ ((eh >>> 9) | (el << 23));
                        abh = ah & bh;
                        abl = al & bl;
                        majh = abh ^ (ah & ch) ^ bch;
                        majl = abl ^ (al & cl) ^ bcl;
                        chh = (eh & fh) ^ (~eh & gh);
                        chl = (el & fl) ^ (~el & gl);
                        t1h = blocks[j];
                        t1l = blocks[j + 1];
                        t2h = K[j];
                        t2l = K[j + 1];
                        c1 = (t2l & 0xffff) + (t1l & 0xffff) + (chl & 0xffff) + (s1l & 0xffff) + (hl & 0xffff);
                        c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (hl >>> 16) + (c1 >>> 16);
                        c3 = (t2h & 0xffff) + (t1h & 0xffff) + (chh & 0xffff) + (s1h & 0xffff) + (hh & 0xffff) + (c2 >>> 16);
                        c4 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (hh >>> 16) + (c3 >>> 16);
                        t1h = (c4 << 16) | (c3 & 0xffff);
                        t1l = (c2 << 16) | (c1 & 0xffff);
                        c1 = (majl & 0xffff) + (s0l & 0xffff);
                        c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16);
                        c3 = (majh & 0xffff) + (s0h & 0xffff) + (c2 >>> 16);
                        c4 = (majh >>> 16) + (s0h >>> 16) + (c3 >>> 16);
                        t2h = (c4 << 16) | (c3 & 0xffff);
                        t2l = (c2 << 16) | (c1 & 0xffff);
                        c1 = (dl & 0xffff) + (t1l & 0xffff);
                        c2 = (dl >>> 16) + (t1l >>> 16) + (c1 >>> 16);
                        c3 = (dh & 0xffff) + (t1h & 0xffff) + (c2 >>> 16);
                        c4 = (dh >>> 16) + (t1h >>> 16) + (c3 >>> 16);
                        hh = (c4 << 16) | (c3 & 0xffff);
                        hl = (c2 << 16) | (c1 & 0xffff);
                        c1 = (t2l & 0xffff) + (t1l & 0xffff);
                        c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16);
                        c3 = (t2h & 0xffff) + (t1h & 0xffff) + (c2 >>> 16);
                        c4 = (t2h >>> 16) + (t1h >>> 16) + (c3 >>> 16);
                        dh = (c4 << 16) | (c3 & 0xffff);
                        dl = (c2 << 16) | (c1 & 0xffff);
                        s0h = ((dh >>> 28) | (dl << 4)) ^ ((dl >>> 2) | (dh << 30)) ^ ((dl >>> 7) | (dh << 25));
                        s0l = ((dl >>> 28) | (dh << 4)) ^ ((dh >>> 2) | (dl << 30)) ^ ((dh >>> 7) | (dl << 25));
                        s1h = ((hh >>> 14) | (hl << 18)) ^ ((hh >>> 18) | (hl << 14)) ^ ((hl >>> 9) | (hh << 23));
                        s1l = ((hl >>> 14) | (hh << 18)) ^ ((hl >>> 18) | (hh << 14)) ^ ((hh >>> 9) | (hl << 23));
                        dah = dh & ah;
                        dal = dl & al;
                        majh = dah ^ (dh & bh) ^ abh;
                        majl = dal ^ (dl & bl) ^ abl;
                        chh = (hh & eh) ^ (~hh & fh);
                        chl = (hl & el) ^ (~hl & fl);
                        t1h = blocks[j + 2];
                        t1l = blocks[j + 3];
                        t2h = K[j + 2];
                        t2l = K[j + 3];
                        c1 = (t2l & 0xffff) + (t1l & 0xffff) + (chl & 0xffff) + (s1l & 0xffff) + (gl & 0xffff);
                        c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (gl >>> 16) + (c1 >>> 16);
                        c3 = (t2h & 0xffff) + (t1h & 0xffff) + (chh & 0xffff) + (s1h & 0xffff) + (gh & 0xffff) + (c2 >>> 16);
                        c4 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (gh >>> 16) + (c3 >>> 16);
                        t1h = (c4 << 16) | (c3 & 0xffff);
                        t1l = (c2 << 16) | (c1 & 0xffff);
                        c1 = (majl & 0xffff) + (s0l & 0xffff);
                        c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16);
                        c3 = (majh & 0xffff) + (s0h & 0xffff) + (c2 >>> 16);
                        c4 = (majh >>> 16) + (s0h >>> 16) + (c3 >>> 16);
                        t2h = (c4 << 16) | (c3 & 0xffff);
                        t2l = (c2 << 16) | (c1 & 0xffff);
                        c1 = (cl & 0xffff) + (t1l & 0xffff);
                        c2 = (cl >>> 16) + (t1l >>> 16) + (c1 >>> 16);
                        c3 = (ch & 0xffff) + (t1h & 0xffff) + (c2 >>> 16);
                        c4 = (ch >>> 16) + (t1h >>> 16) + (c3 >>> 16);
                        gh = (c4 << 16) | (c3 & 0xffff);
                        gl = (c2 << 16) | (c1 & 0xffff);
                        c1 = (t2l & 0xffff) + (t1l & 0xffff);
                        c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16);
                        c3 = (t2h & 0xffff) + (t1h & 0xffff) + (c2 >>> 16);
                        c4 = (t2h >>> 16) + (t1h >>> 16) + (c3 >>> 16);
                        ch = (c4 << 16) | (c3 & 0xffff);
                        cl = (c2 << 16) | (c1 & 0xffff);
                        s0h = ((ch >>> 28) | (cl << 4)) ^ ((cl >>> 2) | (ch << 30)) ^ ((cl >>> 7) | (ch << 25));
                        s0l = ((cl >>> 28) | (ch << 4)) ^ ((ch >>> 2) | (cl << 30)) ^ ((ch >>> 7) | (cl << 25));
                        s1h = ((gh >>> 14) | (gl << 18)) ^ ((gh >>> 18) | (gl << 14)) ^ ((gl >>> 9) | (gh << 23));
                        s1l = ((gl >>> 14) | (gh << 18)) ^ ((gl >>> 18) | (gh << 14)) ^ ((gh >>> 9) | (gl << 23));
                        cdh = ch & dh;
                        cdl = cl & dl;
                        majh = cdh ^ (ch & ah) ^ dah;
                        majl = cdl ^ (cl & al) ^ dal;
                        chh = (gh & hh) ^ (~gh & eh);
                        chl = (gl & hl) ^ (~gl & el);
                        t1h = blocks[j + 4];
                        t1l = blocks[j + 5];
                        t2h = K[j + 4];
                        t2l = K[j + 5];
                        c1 = (t2l & 0xffff) + (t1l & 0xffff) + (chl & 0xffff) + (s1l & 0xffff) + (fl & 0xffff);
                        c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (fl >>> 16) + (c1 >>> 16);
                        c3 = (t2h & 0xffff) + (t1h & 0xffff) + (chh & 0xffff) + (s1h & 0xffff) + (fh & 0xffff) + (c2 >>> 16);
                        c4 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (fh >>> 16) + (c3 >>> 16);
                        t1h = (c4 << 16) | (c3 & 0xffff);
                        t1l = (c2 << 16) | (c1 & 0xffff);
                        c1 = (majl & 0xffff) + (s0l & 0xffff);
                        c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16);
                        c3 = (majh & 0xffff) + (s0h & 0xffff) + (c2 >>> 16);
                        c4 = (majh >>> 16) + (s0h >>> 16) + (c3 >>> 16);
                        t2h = (c4 << 16) | (c3 & 0xffff);
                        t2l = (c2 << 16) | (c1 & 0xffff);
                        c1 = (bl & 0xffff) + (t1l & 0xffff);
                        c2 = (bl >>> 16) + (t1l >>> 16) + (c1 >>> 16);
                        c3 = (bh & 0xffff) + (t1h & 0xffff) + (c2 >>> 16);
                        c4 = (bh >>> 16) + (t1h >>> 16) + (c3 >>> 16);
                        fh = (c4 << 16) | (c3 & 0xffff);
                        fl = (c2 << 16) | (c1 & 0xffff);
                        c1 = (t2l & 0xffff) + (t1l & 0xffff);
                        c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16);
                        c3 = (t2h & 0xffff) + (t1h & 0xffff) + (c2 >>> 16);
                        c4 = (t2h >>> 16) + (t1h >>> 16) + (c3 >>> 16);
                        bh = (c4 << 16) | (c3 & 0xffff);
                        bl = (c2 << 16) | (c1 & 0xffff);
                        s0h = ((bh >>> 28) | (bl << 4)) ^ ((bl >>> 2) | (bh << 30)) ^ ((bl >>> 7) | (bh << 25));
                        s0l = ((bl >>> 28) | (bh << 4)) ^ ((bh >>> 2) | (bl << 30)) ^ ((bh >>> 7) | (bl << 25));
                        s1h = ((fh >>> 14) | (fl << 18)) ^ ((fh >>> 18) | (fl << 14)) ^ ((fl >>> 9) | (fh << 23));
                        s1l = ((fl >>> 14) | (fh << 18)) ^ ((fl >>> 18) | (fh << 14)) ^ ((fh >>> 9) | (fl << 23));
                        bch = bh & ch;
                        bcl = bl & cl;
                        majh = bch ^ (bh & dh) ^ cdh;
                        majl = bcl ^ (bl & dl) ^ cdl;
                        chh = (fh & gh) ^ (~fh & hh);
                        chl = (fl & gl) ^ (~fl & hl);
                        t1h = blocks[j + 6];
                        t1l = blocks[j + 7];
                        t2h = K[j + 6];
                        t2l = K[j + 7];
                        c1 = (t2l & 0xffff) + (t1l & 0xffff) + (chl & 0xffff) + (s1l & 0xffff) + (el & 0xffff);
                        c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (el >>> 16) + (c1 >>> 16);
                        c3 = (t2h & 0xffff) + (t1h & 0xffff) + (chh & 0xffff) + (s1h & 0xffff) + (eh & 0xffff) + (c2 >>> 16);
                        c4 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (eh >>> 16) + (c3 >>> 16);
                        t1h = (c4 << 16) | (c3 & 0xffff);
                        t1l = (c2 << 16) | (c1 & 0xffff);
                        c1 = (majl & 0xffff) + (s0l & 0xffff);
                        c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16);
                        c3 = (majh & 0xffff) + (s0h & 0xffff) + (c2 >>> 16);
                        c4 = (majh >>> 16) + (s0h >>> 16) + (c3 >>> 16);
                        t2h = (c4 << 16) | (c3 & 0xffff);
                        t2l = (c2 << 16) | (c1 & 0xffff);
                        c1 = (al & 0xffff) + (t1l & 0xffff);
                        c2 = (al >>> 16) + (t1l >>> 16) + (c1 >>> 16);
                        c3 = (ah & 0xffff) + (t1h & 0xffff) + (c2 >>> 16);
                        c4 = (ah >>> 16) + (t1h >>> 16) + (c3 >>> 16);
                        eh = (c4 << 16) | (c3 & 0xffff);
                        el = (c2 << 16) | (c1 & 0xffff);
                        c1 = (t2l & 0xffff) + (t1l & 0xffff);
                        c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16);
                        c3 = (t2h & 0xffff) + (t1h & 0xffff) + (c2 >>> 16);
                        c4 = (t2h >>> 16) + (t1h >>> 16) + (c3 >>> 16);
                        ah = (c4 << 16) | (c3 & 0xffff);
                        al = (c2 << 16) | (c1 & 0xffff);
                    }
                    c1 = (h0l & 0xffff) + (al & 0xffff);
                    c2 = (h0l >>> 16) + (al >>> 16) + (c1 >>> 16);
                    c3 = (h0h & 0xffff) + (ah & 0xffff) + (c2 >>> 16);
                    c4 = (h0h >>> 16) + (ah >>> 16) + (c3 >>> 16);
                    this.#h0h = (c4 << 16) | (c3 & 0xffff);
                    this.#h0l = (c2 << 16) | (c1 & 0xffff);
                    c1 = (h1l & 0xffff) + (bl & 0xffff);
                    c2 = (h1l >>> 16) + (bl >>> 16) + (c1 >>> 16);
                    c3 = (h1h & 0xffff) + (bh & 0xffff) + (c2 >>> 16);
                    c4 = (h1h >>> 16) + (bh >>> 16) + (c3 >>> 16);
                    this.#h1h = (c4 << 16) | (c3 & 0xffff);
                    this.#h1l = (c2 << 16) | (c1 & 0xffff);
                    c1 = (h2l & 0xffff) + (cl & 0xffff);
                    c2 = (h2l >>> 16) + (cl >>> 16) + (c1 >>> 16);
                    c3 = (h2h & 0xffff) + (ch & 0xffff) + (c2 >>> 16);
                    c4 = (h2h >>> 16) + (ch >>> 16) + (c3 >>> 16);
                    this.#h2h = (c4 << 16) | (c3 & 0xffff);
                    this.#h2l = (c2 << 16) | (c1 & 0xffff);
                    c1 = (h3l & 0xffff) + (dl & 0xffff);
                    c2 = (h3l >>> 16) + (dl >>> 16) + (c1 >>> 16);
                    c3 = (h3h & 0xffff) + (dh & 0xffff) + (c2 >>> 16);
                    c4 = (h3h >>> 16) + (dh >>> 16) + (c3 >>> 16);
                    this.#h3h = (c4 << 16) | (c3 & 0xffff);
                    this.#h3l = (c2 << 16) | (c1 & 0xffff);
                    c1 = (h4l & 0xffff) + (el & 0xffff);
                    c2 = (h4l >>> 16) + (el >>> 16) + (c1 >>> 16);
                    c3 = (h4h & 0xffff) + (eh & 0xffff) + (c2 >>> 16);
                    c4 = (h4h >>> 16) + (eh >>> 16) + (c3 >>> 16);
                    this.#h4h = (c4 << 16) | (c3 & 0xffff);
                    this.#h4l = (c2 << 16) | (c1 & 0xffff);
                    c1 = (h5l & 0xffff) + (fl & 0xffff);
                    c2 = (h5l >>> 16) + (fl >>> 16) + (c1 >>> 16);
                    c3 = (h5h & 0xffff) + (fh & 0xffff) + (c2 >>> 16);
                    c4 = (h5h >>> 16) + (fh >>> 16) + (c3 >>> 16);
                    this.#h5h = (c4 << 16) | (c3 & 0xffff);
                    this.#h5l = (c2 << 16) | (c1 & 0xffff);
                    c1 = (h6l & 0xffff) + (gl & 0xffff);
                    c2 = (h6l >>> 16) + (gl >>> 16) + (c1 >>> 16);
                    c3 = (h6h & 0xffff) + (gh & 0xffff) + (c2 >>> 16);
                    c4 = (h6h >>> 16) + (gh >>> 16) + (c3 >>> 16);
                    this.#h6h = (c4 << 16) | (c3 & 0xffff);
                    this.#h6l = (c2 << 16) | (c1 & 0xffff);
                    c1 = (h7l & 0xffff) + (hl & 0xffff);
                    c2 = (h7l >>> 16) + (hl >>> 16) + (c1 >>> 16);
                    c3 = (h7h & 0xffff) + (hh & 0xffff) + (c2 >>> 16);
                    c4 = (h7h >>> 16) + (hh >>> 16) + (c3 >>> 16);
                    this.#h7h = (c4 << 16) | (c3 & 0xffff);
                    this.#h7l = (c2 << 16) | (c1 & 0xffff);
                }
                hex() {
                    this.finalize();
                    const h0h = this.#h0h, h0l = this.#h0l, h1h = this.#h1h, h1l = this.#h1l, h2h = this.#h2h, h2l = this.#h2l, h3h = this.#h3h, h3l = this.#h3l, h4h = this.#h4h, h4l = this.#h4l, h5h = this.#h5h, h5l = this.#h5l, h6h = this.#h6h, h6l = this.#h6l, h7h = this.#h7h, h7l = this.#h7l, bits = this.#bits;
                    let hex = HEX_CHARS[(h0h >> 28) & 0x0f] + HEX_CHARS[(h0h >> 24) & 0x0f] +
                        HEX_CHARS[(h0h >> 20) & 0x0f] + HEX_CHARS[(h0h >> 16) & 0x0f] +
                        HEX_CHARS[(h0h >> 12) & 0x0f] + HEX_CHARS[(h0h >> 8) & 0x0f] +
                        HEX_CHARS[(h0h >> 4) & 0x0f] + HEX_CHARS[h0h & 0x0f] +
                        HEX_CHARS[(h0l >> 28) & 0x0f] + HEX_CHARS[(h0l >> 24) & 0x0f] +
                        HEX_CHARS[(h0l >> 20) & 0x0f] + HEX_CHARS[(h0l >> 16) & 0x0f] +
                        HEX_CHARS[(h0l >> 12) & 0x0f] + HEX_CHARS[(h0l >> 8) & 0x0f] +
                        HEX_CHARS[(h0l >> 4) & 0x0f] + HEX_CHARS[h0l & 0x0f] +
                        HEX_CHARS[(h1h >> 28) & 0x0f] + HEX_CHARS[(h1h >> 24) & 0x0f] +
                        HEX_CHARS[(h1h >> 20) & 0x0f] + HEX_CHARS[(h1h >> 16) & 0x0f] +
                        HEX_CHARS[(h1h >> 12) & 0x0f] + HEX_CHARS[(h1h >> 8) & 0x0f] +
                        HEX_CHARS[(h1h >> 4) & 0x0f] + HEX_CHARS[h1h & 0x0f] +
                        HEX_CHARS[(h1l >> 28) & 0x0f] + HEX_CHARS[(h1l >> 24) & 0x0f] +
                        HEX_CHARS[(h1l >> 20) & 0x0f] + HEX_CHARS[(h1l >> 16) & 0x0f] +
                        HEX_CHARS[(h1l >> 12) & 0x0f] + HEX_CHARS[(h1l >> 8) & 0x0f] +
                        HEX_CHARS[(h1l >> 4) & 0x0f] + HEX_CHARS[h1l & 0x0f] +
                        HEX_CHARS[(h2h >> 28) & 0x0f] + HEX_CHARS[(h2h >> 24) & 0x0f] +
                        HEX_CHARS[(h2h >> 20) & 0x0f] + HEX_CHARS[(h2h >> 16) & 0x0f] +
                        HEX_CHARS[(h2h >> 12) & 0x0f] + HEX_CHARS[(h2h >> 8) & 0x0f] +
                        HEX_CHARS[(h2h >> 4) & 0x0f] + HEX_CHARS[h2h & 0x0f] +
                        HEX_CHARS[(h2l >> 28) & 0x0f] + HEX_CHARS[(h2l >> 24) & 0x0f] +
                        HEX_CHARS[(h2l >> 20) & 0x0f] + HEX_CHARS[(h2l >> 16) & 0x0f] +
                        HEX_CHARS[(h2l >> 12) & 0x0f] + HEX_CHARS[(h2l >> 8) & 0x0f] +
                        HEX_CHARS[(h2l >> 4) & 0x0f] + HEX_CHARS[h2l & 0x0f] +
                        HEX_CHARS[(h3h >> 28) & 0x0f] + HEX_CHARS[(h3h >> 24) & 0x0f] +
                        HEX_CHARS[(h3h >> 20) & 0x0f] + HEX_CHARS[(h3h >> 16) & 0x0f] +
                        HEX_CHARS[(h3h >> 12) & 0x0f] + HEX_CHARS[(h3h >> 8) & 0x0f] +
                        HEX_CHARS[(h3h >> 4) & 0x0f] + HEX_CHARS[h3h & 0x0f];
                    if (bits >= 256) {
                        hex +=
                            HEX_CHARS[(h3l >> 28) & 0x0f] + HEX_CHARS[(h3l >> 24) & 0x0f] +
                                HEX_CHARS[(h3l >> 20) & 0x0f] + HEX_CHARS[(h3l >> 16) & 0x0f] +
                                HEX_CHARS[(h3l >> 12) & 0x0f] + HEX_CHARS[(h3l >> 8) & 0x0f] +
                                HEX_CHARS[(h3l >> 4) & 0x0f] + HEX_CHARS[h3l & 0x0f];
                    }
                    if (bits >= 384) {
                        hex +=
                            HEX_CHARS[(h4h >> 28) & 0x0f] + HEX_CHARS[(h4h >> 24) & 0x0f] +
                                HEX_CHARS[(h4h >> 20) & 0x0f] + HEX_CHARS[(h4h >> 16) & 0x0f] +
                                HEX_CHARS[(h4h >> 12) & 0x0f] + HEX_CHARS[(h4h >> 8) & 0x0f] +
                                HEX_CHARS[(h4h >> 4) & 0x0f] + HEX_CHARS[h4h & 0x0f] +
                                HEX_CHARS[(h4l >> 28) & 0x0f] + HEX_CHARS[(h4l >> 24) & 0x0f] +
                                HEX_CHARS[(h4l >> 20) & 0x0f] + HEX_CHARS[(h4l >> 16) & 0x0f] +
                                HEX_CHARS[(h4l >> 12) & 0x0f] + HEX_CHARS[(h4l >> 8) & 0x0f] +
                                HEX_CHARS[(h4l >> 4) & 0x0f] + HEX_CHARS[h4l & 0x0f] +
                                HEX_CHARS[(h5h >> 28) & 0x0f] + HEX_CHARS[(h5h >> 24) & 0x0f] +
                                HEX_CHARS[(h5h >> 20) & 0x0f] + HEX_CHARS[(h5h >> 16) & 0x0f] +
                                HEX_CHARS[(h5h >> 12) & 0x0f] + HEX_CHARS[(h5h >> 8) & 0x0f] +
                                HEX_CHARS[(h5h >> 4) & 0x0f] + HEX_CHARS[h5h & 0x0f] +
                                HEX_CHARS[(h5l >> 28) & 0x0f] + HEX_CHARS[(h5l >> 24) & 0x0f] +
                                HEX_CHARS[(h5l >> 20) & 0x0f] + HEX_CHARS[(h5l >> 16) & 0x0f] +
                                HEX_CHARS[(h5l >> 12) & 0x0f] + HEX_CHARS[(h5l >> 8) & 0x0f] +
                                HEX_CHARS[(h5l >> 4) & 0x0f] + HEX_CHARS[h5l & 0x0f];
                    }
                    if (bits === 512) {
                        hex +=
                            HEX_CHARS[(h6h >> 28) & 0x0f] + HEX_CHARS[(h6h >> 24) & 0x0f] +
                                HEX_CHARS[(h6h >> 20) & 0x0f] + HEX_CHARS[(h6h >> 16) & 0x0f] +
                                HEX_CHARS[(h6h >> 12) & 0x0f] + HEX_CHARS[(h6h >> 8) & 0x0f] +
                                HEX_CHARS[(h6h >> 4) & 0x0f] + HEX_CHARS[h6h & 0x0f] +
                                HEX_CHARS[(h6l >> 28) & 0x0f] + HEX_CHARS[(h6l >> 24) & 0x0f] +
                                HEX_CHARS[(h6l >> 20) & 0x0f] + HEX_CHARS[(h6l >> 16) & 0x0f] +
                                HEX_CHARS[(h6l >> 12) & 0x0f] + HEX_CHARS[(h6l >> 8) & 0x0f] +
                                HEX_CHARS[(h6l >> 4) & 0x0f] + HEX_CHARS[h6l & 0x0f] +
                                HEX_CHARS[(h7h >> 28) & 0x0f] + HEX_CHARS[(h7h >> 24) & 0x0f] +
                                HEX_CHARS[(h7h >> 20) & 0x0f] + HEX_CHARS[(h7h >> 16) & 0x0f] +
                                HEX_CHARS[(h7h >> 12) & 0x0f] + HEX_CHARS[(h7h >> 8) & 0x0f] +
                                HEX_CHARS[(h7h >> 4) & 0x0f] + HEX_CHARS[h7h & 0x0f] +
                                HEX_CHARS[(h7l >> 28) & 0x0f] + HEX_CHARS[(h7l >> 24) & 0x0f] +
                                HEX_CHARS[(h7l >> 20) & 0x0f] + HEX_CHARS[(h7l >> 16) & 0x0f] +
                                HEX_CHARS[(h7l >> 12) & 0x0f] + HEX_CHARS[(h7l >> 8) & 0x0f] +
                                HEX_CHARS[(h7l >> 4) & 0x0f] + HEX_CHARS[h7l & 0x0f];
                    }
                    return hex;
                }
                toString() {
                    return this.hex();
                }
                digest() {
                    this.finalize();
                    const h0h = this.#h0h, h0l = this.#h0l, h1h = this.#h1h, h1l = this.#h1l, h2h = this.#h2h, h2l = this.#h2l, h3h = this.#h3h, h3l = this.#h3l, h4h = this.#h4h, h4l = this.#h4l, h5h = this.#h5h, h5l = this.#h5l, h6h = this.#h6h, h6l = this.#h6l, h7h = this.#h7h, h7l = this.#h7l, bits = this.#bits;
                    const arr = [
                        (h0h >> 24) & 0xff, (h0h >> 16) & 0xff, (h0h >> 8) & 0xff, h0h & 0xff,
                        (h0l >> 24) & 0xff, (h0l >> 16) & 0xff, (h0l >> 8) & 0xff, h0l & 0xff,
                        (h1h >> 24) & 0xff, (h1h >> 16) & 0xff, (h1h >> 8) & 0xff, h1h & 0xff,
                        (h1l >> 24) & 0xff, (h1l >> 16) & 0xff, (h1l >> 8) & 0xff, h1l & 0xff,
                        (h2h >> 24) & 0xff, (h2h >> 16) & 0xff, (h2h >> 8) & 0xff, h2h & 0xff,
                        (h2l >> 24) & 0xff, (h2l >> 16) & 0xff, (h2l >> 8) & 0xff, h2l & 0xff,
                        (h3h >> 24) & 0xff, (h3h >> 16) & 0xff, (h3h >> 8) & 0xff, h3h & 0xff
                    ];
                    if (bits >= 256) {
                        arr.push((h3l >> 24) & 0xff, (h3l >> 16) & 0xff, (h3l >> 8) & 0xff, h3l & 0xff);
                    }
                    if (bits >= 384) {
                        arr.push((h4h >> 24) & 0xff, (h4h >> 16) & 0xff, (h4h >> 8) & 0xff, h4h & 0xff, (h4l >> 24) & 0xff, (h4l >> 16) & 0xff, (h4l >> 8) & 0xff, h4l & 0xff, (h5h >> 24) & 0xff, (h5h >> 16) & 0xff, (h5h >> 8) & 0xff, h5h & 0xff, (h5l >> 24) & 0xff, (h5l >> 16) & 0xff, (h5l >> 8) & 0xff, h5l & 0xff);
                    }
                    if (bits === 512) {
                        arr.push((h6h >> 24) & 0xff, (h6h >> 16) & 0xff, (h6h >> 8) & 0xff, h6h & 0xff, (h6l >> 24) & 0xff, (h6l >> 16) & 0xff, (h6l >> 8) & 0xff, h6l & 0xff, (h7h >> 24) & 0xff, (h7h >> 16) & 0xff, (h7h >> 8) & 0xff, h7h & 0xff, (h7l >> 24) & 0xff, (h7l >> 16) & 0xff, (h7l >> 8) & 0xff, h7l & 0xff);
                    }
                    return arr;
                }
                array() {
                    return this.digest();
                }
                arrayBuffer() {
                    this.finalize();
                    const bits = this.#bits;
                    const buffer = new ArrayBuffer(bits / 8);
                    const dataView = new DataView(buffer);
                    dataView.setUint32(0, this.#h0h);
                    dataView.setUint32(4, this.#h0l);
                    dataView.setUint32(8, this.#h1h);
                    dataView.setUint32(12, this.#h1l);
                    dataView.setUint32(16, this.#h2h);
                    dataView.setUint32(20, this.#h2l);
                    dataView.setUint32(24, this.#h3h);
                    if (bits >= 256) {
                        dataView.setUint32(28, this.#h3l);
                    }
                    if (bits >= 384) {
                        dataView.setUint32(32, this.#h4h);
                        dataView.setUint32(36, this.#h4l);
                        dataView.setUint32(40, this.#h5h);
                        dataView.setUint32(44, this.#h5l);
                    }
                    if (bits === 512) {
                        dataView.setUint32(48, this.#h6h);
                        dataView.setUint32(52, this.#h6l);
                        dataView.setUint32(56, this.#h7h);
                        dataView.setUint32(60, this.#h7l);
                    }
                    return buffer;
                }
            };
            exports_170("Sha512", Sha512);
            HmacSha512 = class HmacSha512 extends Sha512 {
                constructor(secretKey, bits = 512, sharedMemory = false) {
                    super(bits, sharedMemory);
                    let key;
                    if (secretKey instanceof ArrayBuffer) {
                        key = new Uint8Array(secretKey);
                    }
                    else if (typeof secretKey === "string") {
                        const bytes = [];
                        const length = secretKey.length;
                        let index = 0;
                        let code;
                        for (let i = 0; i < length; ++i) {
                            code = secretKey.charCodeAt(i);
                            if (code < 0x80) {
                                bytes[index++] = code;
                            }
                            else if (code < 0x800) {
                                bytes[index++] = 0xc0 | (code >> 6);
                                bytes[index++] = 0x80 | (code & 0x3f);
                            }
                            else if (code < 0xd800 || code >= 0xe000) {
                                bytes[index++] = 0xe0 | (code >> 12);
                                bytes[index++] = 0x80 | ((code >> 6) & 0x3f);
                                bytes[index++] = 0x80 | (code & 0x3f);
                            }
                            else {
                                code =
                                    0x10000 +
                                        (((code & 0x3ff) << 10) | (secretKey.charCodeAt(++i) & 0x3ff));
                                bytes[index++] = 0xf0 | (code >> 18);
                                bytes[index++] = 0x80 | ((code >> 12) & 0x3f);
                                bytes[index++] = 0x80 | ((code >> 6) & 0x3f);
                                bytes[index++] = 0x80 | (code & 0x3f);
                            }
                        }
                        key = bytes;
                    }
                    else {
                        key = secretKey;
                    }
                    if (key.length > 128) {
                        key = new Sha512(bits, true).update(key).array();
                    }
                    const oKeyPad = [];
                    const iKeyPad = [];
                    for (let i = 0; i < 128; ++i) {
                        const b = key[i] || 0;
                        oKeyPad[i] = 0x5c ^ b;
                        iKeyPad[i] = 0x36 ^ b;
                    }
                    this.update(iKeyPad);
                    this.#inner = true;
                    this.#bits = bits;
                    this.#oKeyPad = oKeyPad;
                    this.#sharedMemory = sharedMemory;
                }
                #inner;
                #bits;
                #oKeyPad;
                #sharedMemory;
                finalize() {
                    super.finalize();
                    if (this.#inner) {
                        this.#inner = false;
                        const innerHash = this.array();
                        super.init(this.#bits, this.#sharedMemory);
                        this.update(this.#oKeyPad);
                        this.update(innerHash);
                        super.finalize();
                    }
                }
            };
            exports_170("HmacSha512", HmacSha512);
        }
    };
});
System.register("https://deno.land/x/djwt/create", ["https://deno.land/x/djwt/base64/base64url", "https://deno.land/std@v0.56.0/encoding/hex", "https://deno.land/std@v0.56.0/hash/sha256", "https://deno.land/std@v0.56.0/hash/sha512"], function (exports_171, context_171) {
    "use strict";
    var base64url_ts_2, hex_ts_1, sha256_ts_2, sha512_ts_1;
    var __moduleName = context_171 && context_171.id;
    // Helper function: setExpiration()
    // returns the number of milliseconds since January 1, 1970, 00:00:00 UTC
    function setExpiration(exp) {
        return (exp instanceof Date ? exp : new Date(exp)).getTime();
    }
    exports_171("setExpiration", setExpiration);
    function convertHexToBase64url(input) {
        return base64url_ts_2.convertUint8ArrayToBase64url(hex_ts_1.decodeString(input));
    }
    exports_171("convertHexToBase64url", convertHexToBase64url);
    function convertStringToBase64url(input) {
        return base64url_ts_2.convertUint8ArrayToBase64url(new TextEncoder().encode(input));
    }
    exports_171("convertStringToBase64url", convertStringToBase64url);
    function makeSigningInput(header, payload) {
        return `${convertStringToBase64url(JSON.stringify(header))}.${convertStringToBase64url(JSON.stringify(payload || ""))}`;
    }
    function encrypt(alg, key, msg) {
        function assertNever(alg) {
            throw new RangeError("no matching crypto algorithm in the header: " + alg);
        }
        switch (alg) {
            case "none":
                return null;
            case "HS256":
                return new sha256_ts_2.HmacSha256(key).update(msg).toString();
            case "HS512":
                return new sha512_ts_1.HmacSha512(key).update(msg).toString();
            default:
                assertNever(alg);
        }
    }
    function makeSignature(alg, key, input) {
        const encryptionInHex = encrypt(alg, key, input);
        return encryptionInHex ? convertHexToBase64url(encryptionInHex) : "";
    }
    exports_171("makeSignature", makeSignature);
    function makeJwt({ key, header, payload }) {
        try {
            const signingInput = makeSigningInput(header, payload);
            return `${signingInput}.${makeSignature(header.alg, key, signingInput)}`;
        }
        catch (err) {
            err.message = `Failed to create JWT: ${err.message}`;
            throw err;
        }
    }
    exports_171("makeJwt", makeJwt);
    return {
        setters: [
            function (base64url_ts_2_1) {
                base64url_ts_2 = base64url_ts_2_1;
            },
            function (hex_ts_1_1) {
                hex_ts_1 = hex_ts_1_1;
            },
            function (sha256_ts_2_1) {
                sha256_ts_2 = sha256_ts_2_1;
            },
            function (sha512_ts_1_1) {
                sha512_ts_1 = sha512_ts_1_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("file:///home/jax/www/denoAPI2/src/controllers/user/IUser", [], function (exports_172, context_172) {
    "use strict";
    var __moduleName = context_172 && context_172.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("file:///home/jax/www/denoAPI2/src/controllers/config/validation", [], function (exports_173, context_173) {
    "use strict";
    var requiredValues, validateConfig;
    var __moduleName = context_173 && context_173.id;
    return {
        setters: [],
        execute: function () {
            /**
             * Walkaround
             * interfaces are not available in runtime
             * @substitution IConfigJWT, ClientConfig, IConfigServer
             */
            exports_173("requiredValues", requiredValues = {
                jwtConfig: {
                    header: "string",
                    schema: "string",
                    secretKey: "string",
                    expirationTime: "number",
                    type: "string",
                    alg: "string"
                },
                mysqlConfig: {
                    hostname: "string",
                    port: "number",
                    username: "string",
                    password: "string",
                    db: "string",
                },
                serverConfig: {
                    hostname: "string",
                    port: "number"
                }
            });
            /**
             * Check if object has all necessary values with right type
             * @param requiredProperties
             * @param configObj
             * @param name
             */
            exports_173("validateConfig", validateConfig = (requiredProperties, configObj, name = "unknown") => {
                for (const key in requiredProperties) {
                    if (!configObj.hasOwnProperty(key))
                        throw `Key "${key}" not found in configuration ${name}.`;
                    if (typeof configObj[key] !== requiredProperties[key])
                        throw `Key "${key}" is not type of ${requiredProperties[key]} in configuration ${name}.`;
                }
            });
        }
    };
});
System.register("file:///home/jax/www/denoAPI2/src/controllers/config/IConfig", [], function (exports_174, context_174) {
    "use strict";
    var __moduleName = context_174 && context_174.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("file:///home/jax/www/denoAPI2/src/controllers/config/config", ["file:///home/jax/www/denoAPI2/src/controllers/config/validation"], function (exports_175, context_175) {
    "use strict";
    var validation_ts_1, decoder, content, config, serverConfig, mysqlConfig, jwtConfig;
    var __moduleName = context_175 && context_175.id;
    return {
        setters: [
            function (validation_ts_1_1) {
                validation_ts_1 = validation_ts_1_1;
            }
        ],
        execute: function () {
            /** Load config.json file and parse it */
            decoder = new TextDecoder("utf-8");
            content = decoder.decode(Deno.readFileSync("./config.json"));
            config = JSON.parse(content);
            /**
             * validate values through requiredValues variable
             * because interfaces are not available in runtime
             */
            for (const [key, configSection] of Object.entries(config))
                validation_ts_1.validateConfig(validation_ts_1.requiredValues[key], configSection, key);
            /** assing and export */
            exports_175("serverConfig", serverConfig = config.serverConfig);
            exports_175("mysqlConfig", mysqlConfig = config.mysqlConfig);
            exports_175("jwtConfig", jwtConfig = config.jwtConfig);
        }
    };
});
System.register("file:///home/jax/www/denoAPI2/src/controllers/user/UserController", ["https://deno.land/x/bcrypt/mod", "https://deno.land/x/dso@v1.0.0/mod", "https://deno.land/x/nanoid/mod", "file:///home/jax/www/denoAPI2/src/controllers/user/UserModel", "https://deno.land/x/djwt/create", "file:///home/jax/www/denoAPI2/src/controllers/config/config"], function (exports_176, context_176) {
    "use strict";
    var bcrypt, mod_ts_26, mod_ts_27, UserModel_ts_1, create_ts_1, config_ts_1, UserController;
    var __moduleName = context_176 && context_176.id;
    return {
        setters: [
            function (bcrypt_2) {
                bcrypt = bcrypt_2;
            },
            function (mod_ts_26_1) {
                mod_ts_26 = mod_ts_26_1;
            },
            function (mod_ts_27_1) {
                mod_ts_27 = mod_ts_27_1;
            },
            function (UserModel_ts_1_1) {
                UserModel_ts_1 = UserModel_ts_1_1;
            },
            function (create_ts_1_1) {
                create_ts_1 = create_ts_1_1;
            },
            function (config_ts_1_1) {
                config_ts_1 = config_ts_1_1;
            }
        ],
        execute: function () {
            UserController = class UserController {
                constructor() {
                    /**
                     * Password is being hashed during this function
                     * @param values
                     */
                    this.create = async (values) => {
                        const password = this.hashPassword(values.password);
                        const user = {
                            ...values,
                            hash: mod_ts_27.default(),
                            password,
                        };
                        const id = await UserModel_ts_1.userModel.insert(user);
                        console.info(`Created user "${user.username}" in namespace ${user.namespace}.`);
                        return id;
                    };
                    /**
                     * Update user by `id`. Requires whole IUser values.
                     * @param id
                     * @param values
                     */
                    this.delete = async (id) => !!await UserModel_ts_1.userModel.delete(mod_ts_26.Where.from({ id: id }));
                    /**
                     * Fetch one row by `id` column
                     * @param id
                     */
                    this.get = (id) => UserModel_ts_1.userModel.findOne(mod_ts_26.Where.from({ id: id }));
                    /**
                     * Fetch one row by `hash` column
                     * @param hash
                     */
                    this.getByHash = (hash) => UserModel_ts_1.userModel.findOne(mod_ts_26.Where.from({ hash: hash }));
                    /**
                     * Synchronised hash input string with bcrypt
                     * @param password
                     */
                    this.hashPassword = (password) => bcrypt.hashSync(password, bcrypt.genSaltSync(8));
                }
                /**
                 * Update user by `id`. Requires whole IUser values.
                 * @param id
                 * @param values
                 */
                async update(id, values) {
                    const user = this.get(id);
                    if (user === undefined)
                        throw 'User not found';
                    await UserModel_ts_1.userModel.update(values, mod_ts_26.Where.from({ id: id }));
                    return user;
                }
                /**
                 * Main function of auth server
                 * @param username
                 * @param password
                 * @param namespace
                 */
                async authenticate(username, password, namespace) {
                    const user = await UserModel_ts_1.userModel.findOne(mod_ts_26.Where.from({ username: username, namespace: namespace }));
                    if (user === undefined)
                        return false;
                    if (user.hash === undefined)
                        return false;
                    if (user.password === undefined)
                        return false;
                    if (!(bcrypt.compareSync(password, user.password)))
                        return false;
                    return this.generateJwt(user.hash);
                }
                /**
                 * Generates JSON web token with `id` and `exp` (expiration) in Payload
                 * @param id
                 */
                generateJwt(id) {
                    const payload = { id, exp: create_ts_1.setExpiration(new Date().getTime() + config_ts_1.jwtConfig.expirationTime) };
                    const header = {
                        alg: config_ts_1.jwtConfig.alg,
                        typ: config_ts_1.jwtConfig.type,
                    };
                    return create_ts_1.makeJwt({ header, payload, key: config_ts_1.jwtConfig.secretKey });
                }
            };
            exports_176("UserController", UserController);
        }
    };
});
System.register("file:///home/jax/www/denoAPI2/src/utils/responses", ["https://deno.land/x/oak/mod"], function (exports_177, context_177) {
    "use strict";
    var mod_ts_28, responseNotImplemented, responseBadRequest;
    var __moduleName = context_177 && context_177.id;
    return {
        setters: [
            function (mod_ts_28_1) {
                mod_ts_28 = mod_ts_28_1;
            }
        ],
        execute: function () {
            responseNotImplemented = (ctx) => {
                ctx.response.status = mod_ts_28.Status.NotImplemented;
                ctx.response.body = { message: "Method not implemented" };
                return;
            };
            exports_177("responseNotImplemented", responseNotImplemented);
            responseBadRequest = (ctx, msg) => {
                ctx.response.status = mod_ts_28.Status.BadRequest;
                ctx.response.body = { message: msg || "Bad request" };
                return;
            };
            exports_177("responseBadRequest", responseBadRequest);
        }
    };
});
System.register("file:///home/jax/www/denoAPI2/src/routers/authRouter", ["https://deno.land/x/oak/mod", "file:///home/jax/www/denoAPI2/src/controllers/user/UserController", "file:///home/jax/www/denoAPI2/src/utils/responses"], function (exports_178, context_178) {
    "use strict";
    var mod_ts_29, UserController_ts_1, responses_ts_1, controller, authRoutes;
    var __moduleName = context_178 && context_178.id;
    return {
        setters: [
            function (mod_ts_29_1) {
                mod_ts_29 = mod_ts_29_1;
            },
            function (UserController_ts_1_1) {
                UserController_ts_1 = UserController_ts_1_1;
            },
            function (responses_ts_1_1) {
                responses_ts_1 = responses_ts_1_1;
            }
        ],
        execute: function () {
            controller = new UserController_ts_1.UserController();
            /**
             * All allowed routes for authentication
             * @param router
             */
            authRoutes = (router) => router
                .post("/auth", async (ctx) => {
                if (!ctx.request.hasBody)
                    return responses_ts_1.responseBadRequest(ctx);
                const { value } = await ctx.request.body();
                const jwt = await controller.authenticate(value.username, value.password, value.namespace);
                if (!jwt)
                    return responses_ts_1.responseBadRequest(ctx, "Invalid credentials");
                ctx.response.status = mod_ts_29.Status.OK;
                ctx.response.body = { jwt };
            });
            exports_178("default", authRoutes);
        }
    };
});
System.register("file:///home/jax/www/denoAPI2/src/utils/requestLogger", [], function (exports_179, context_179) {
    "use strict";
    var requestLogger;
    var __moduleName = context_179 && context_179.id;
    return {
        setters: [],
        execute: function () {
            requestLogger = async (ctx, next) => {
                await next();
                console.log(ctx.request);
                console.info(`--> ${ctx.request.method} ${ctx.request.ips} ${ctx.request.url}`);
            };
            exports_179("default", requestLogger);
        }
    };
});
System.register("file:///home/jax/www/denoAPI2/src/utils/requestProfiler", [], function (exports_180, context_180) {
    "use strict";
    var requestProfiler;
    var __moduleName = context_180 && context_180.id;
    return {
        setters: [],
        execute: function () {
            requestProfiler = async (ctx, next) => {
                const start = Date.now();
                await next();
                const ms = Date.now() - start;
                console.info(`${ms}ms`);
            };
            exports_180("default", requestProfiler);
        }
    };
});
System.register("file:///home/jax/www/denoAPI2/src/server", ["https://deno.land/x/oak/mod", "file:///home/jax/www/denoAPI2/src/controllers/database/database", "file:///home/jax/www/denoAPI2/src/routers/authRouter", "file:///home/jax/www/denoAPI2/src/utils/responses", "file:///home/jax/www/denoAPI2/src/utils/requestLogger", "file:///home/jax/www/denoAPI2/src/utils/requestProfiler", "file:///home/jax/www/denoAPI2/src/controllers/config/config"], function (exports_181, context_181) {
    "use strict";
    var mod_ts_30, database_ts_1, authRouter_ts_1, responses_ts_2, requestLogger_ts_1, requestProfiler_ts_1, config_ts_2, app, userRoutes;
    var __moduleName = context_181 && context_181.id;
    return {
        setters: [
            function (mod_ts_30_1) {
                mod_ts_30 = mod_ts_30_1;
            },
            function (database_ts_1_1) {
                database_ts_1 = database_ts_1_1;
            },
            function (authRouter_ts_1_1) {
                authRouter_ts_1 = authRouter_ts_1_1;
            },
            function (responses_ts_2_1) {
                responses_ts_2 = responses_ts_2_1;
            },
            function (requestLogger_ts_1_1) {
                requestLogger_ts_1 = requestLogger_ts_1_1;
            },
            function (requestProfiler_ts_1_1) {
                requestProfiler_ts_1 = requestProfiler_ts_1_1;
            },
            function (config_ts_2_1) {
                config_ts_2 = config_ts_2_1;
            }
        ],
        execute: async function () {
            app = new mod_ts_30.Application();
            /** http server info */
            app.use(requestProfiler_ts_1.default);
            app.use(requestLogger_ts_1.default);
            /** routing */
            userRoutes = authRouter_ts_1.default(new mod_ts_30.Router());
            app.use(userRoutes.routes());
            app.use(userRoutes.allowedMethods());
            /** fallback, no route found */
            app.use(responses_ts_2.responseNotImplemented);
            await database_ts_1.connectMySQL(config_ts_2.mysqlConfig);
            console.info(`JWT provider started ${config_ts_2.serverConfig.hostname}:${config_ts_2.serverConfig.port}`);
            await app.listen(`${config_ts_2.serverConfig.hostname}:${config_ts_2.serverConfig.port}`);
        }
    };
});

await __instantiateAsync("file:///home/jax/www/denoAPI2/src/server");
